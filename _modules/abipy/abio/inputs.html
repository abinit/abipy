<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>abipy.abio.inputs &#8212; abipy 0.3.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/my_style.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          abipy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.3.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Getting AbiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zzbiblio.html">Bibliography</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">AbiPy Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../postprocessing_howto.html">Post-processing How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/taskmanager.html">TaskManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/manager_examples.html">Manager Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flow_gallery/index.html">Flow Gallery</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coding_guide.html">Coding guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">Documenting AbiPy</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for abipy.abio.inputs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines objects to facilitate the creation of ABINIT input files.</span>
<span class="sd">The syntax is similar to the one used in ABINIT with small differences.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">dict2namedtuple</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="k">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MontyDecoder</span><span class="p">,</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="k">import</span> <span class="n">Energy</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pymatgen.util.serialization</span> <span class="k">import</span> <span class="n">pmg_serialize</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="k">import</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">abipy.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">abipy.core.mixins</span> <span class="k">import</span> <span class="n">Has_Structure</span>
<span class="kn">from</span> <span class="nn">abipy.core.kpoints</span> <span class="k">import</span> <span class="n">has_timrev_from_kptopt</span>
<span class="kn">from</span> <span class="nn">abipy.abio.variable</span> <span class="k">import</span> <span class="n">InputVariable</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars</span> <span class="k">import</span> <span class="n">is_abivar</span><span class="p">,</span> <span class="n">is_anaddb_var</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars_db</span> <span class="k">import</span> <span class="n">get_abinit_variables</span>
<span class="kn">from</span> <span class="nn">abipy.abio.input_tags</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk</span> <span class="k">import</span> <span class="n">PseudoTable</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">,</span> <span class="n">AnaddbTask</span><span class="p">,</span> <span class="n">ParalHintsParser</span><span class="p">,</span> <span class="n">NetcdfReader</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk.abiinspect</span> <span class="k">import</span> <span class="n">yaml_read_irred_perts</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk</span> <span class="k">import</span> <span class="n">abiobjects</span> <span class="k">as</span> <span class="n">aobj</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>


<span class="c1"># List of Abinit variables used to specify the structure.</span>
<span class="c1"># This variables should not be passed to set_vars since</span>
<span class="c1"># they will be generated with structure.to_abivars()</span>
<span class="n">GEOVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;acell&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprimd&quot;</span>
    <span class="s2">&quot;angdeg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xred&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xcart&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xangst&quot;</span><span class="p">,</span>
    <span class="s2">&quot;znucl&quot;</span><span class="p">,</span>
    <span class="s2">&quot;typat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ntypat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;natom&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances (used in pop_tolerances)</span>
<span class="n">_TOLVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolimg&quot;</span><span class="p">,</span> <span class="c1"># ?</span>
    <span class="s2">&quot;tolmxf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolrde&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances for the SCF cycle that are mutally exclusive</span>
<span class="n">_TOLVARS_SCF</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables determining if data files should be read in input</span>
<span class="n">_IRDVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;irdbseig&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdbsreso&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdhaydock&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdddk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdden&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1den&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdqps&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdkss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdscr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdsuscep&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdvdw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfkfine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfq&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1wf&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># FIXME __mul__ operator in pymatgen should allow for grouping atoms by individual cells</span>
<span class="c1"># The present version group by image.</span>
<span class="c1">#def _repeat_array(name, values, from_natom, numcells):</span>
<span class="c1">#    if name in {&quot;spinat&quot;,}:</span>
<span class="c1">#        # [:, natom]</span>
<span class="c1">#        values = np.reshape(values, (-1, from_natom))</span>
<span class="c1">#        return np.repeat(values, numcells, axis=0)</span>
<span class="c1">#    else:</span>
<span class="c1">#        raise ValueError(&quot;Don&#39;t know how to reallocate variable %s&quot; % str(name))</span>


<div class="viewcode-block" id="AbstractInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput">[docs]</a><span class="k">class</span> <span class="nc">AbstractInput</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class defining the methods that must be implemented by Input objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ABC protocol: __delitem__, __getitem__, __iter__, __len__, __setitem__</span>
    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="AbstractInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the input file to file to ``filepath``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

        <span class="c1"># Write the input file.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbstractInput.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
        <span class="k">return</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars_ifnotin"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars_ifnotin">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars_ifnotin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables but only if the variable is not already present.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">added</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
                <span class="n">added</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
        <span class="k">return</span> <span class="n">added</span></div>

<div class="viewcode-block" id="AbstractInput.add_abiobjects"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.add_abiobjects">[docs]</a>    <span class="k">def</span> <span class="nf">add_abiobjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">abi_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receive a list of ``AbiVarable`` objects and add</span>
<span class="sd">        the corresponding variables to the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">aobj</span> <span class="ow">in</span> <span class="n">abi_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">aobj</span><span class="p">,</span> <span class="s2">&quot;to_abivars&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;type </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> does not have `to_abivars` method&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aobj</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">aobj</span><span class="p">)))</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">aobj</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="AbstractInput.pop_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.pop_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        Unlike remove_vars, no exception is raised if the variables are not in the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>

<span class="sd">        Example:</span>
<span class="sd">            inp.pop_vars([&quot;ionmov&quot;, &quot;optcell&quot;, &quot;ntime&quot;, &quot;dilatmx&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.remove_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.remove_vars">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>
<span class="sd">            strict: If True, KeyError is raised if at least one variable is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key: </span><span class="si">%s</span><span class="s2"> not in self:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">removed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">removed</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with the input variables. Used to implement dict-like interface.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if key is a valid name. Raise self.Error if not valid.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbstractInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.to_string">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string with the input.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AbstractInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.abivalidate">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should invoke the executable associated to the input object.</span>
<span class="sd">        to test whether the input variables are correct and consistent.</span>
<span class="sd">        The executable is supposed to implemente some sort of `--dry-run` option</span>
<span class="sd">        that invokes the parser to validate the input and exits.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            ``namedtuple`` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AbstractInput.generate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates new inputs by replacing the variables specified in kwargs.</span>

<span class="sd">        Args:</span>
<span class="sd">            kwargs: keyword arguments with the values used for each variable.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            gs_inp = call_function_to_generate_initial_template()</span>

<span class="sd">            # To generate two input files with different values of ecut:</span>
<span class="sd">            for inp_ecut in gs_inp.generate(ecut=[10, 20]):</span>
<span class="sd">                print(&quot;do something with inp_ecut %s&quot; % inp_ecut)</span>

<span class="sd">            # To generate four input files with all the possible combinations of ecut and nsppol:</span>
<span class="sd">            for inp_ecut in gs_inpt.generate(ecut=[10, 20], nsppol=[1, 2]):</span>
<span class="sd">                print(&quot;do something with inp_ecut %s&quot; % inp_ecut)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">new_vars</span> <span class="ow">in</span> <span class="n">product_dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">new_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="c1"># Remove the variable names to avoid annoying warnings if the variable is overwritten.</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">new_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">new_vars</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">new_inp</span></div></div>


<div class="viewcode-block" id="AbinitInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInputError">[docs]</a><span class="k">class</span> <span class="nc">AbinitInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by ``AbinitInput``.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AbinitInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput">[docs]</a><span class="k">class</span> <span class="nc">AbinitInput</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">AbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">,</span> <span class="nb">object</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the ABINIT variables for a single dataset.</span>

<span class="sd">    .. rubric:: Inheritance Diagram</span>
<span class="sd">    .. inheritance-diagram:: AbinitInput</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">abi_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: Parameters defining the crystalline structure. Accepts |Structure| object</span>
<span class="sd">            file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            pseudos: Pseudopotentials to be used for the calculation. Accepts: string or list of strings</span>
<span class="sd">                with the name of the pseudopotential files, list of |Pseudo| objects</span>
<span class="sd">                or |PseudoTable| object.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            decorators: List of `AbinitInputDecorator` objects.</span>
<span class="sd">            abi_args: list of tuples (key, value) with the initial set of variables. Default: Empty</span>
<span class="sd">            abi_kwargs: Dictionary with the initial set of variables. Default: Empty</span>
<span class="sd">            tags: list/set of tags describing the input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Internal dict with variables. we use an ordered dict so that</span>
        <span class="c1"># variables will be likely grouped by `topics` when we fill the input.</span>
        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">abi_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abi_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">abi_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">abi_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">abi_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abi_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">abi_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="c1">#print(args)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pseudo_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">):</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Directory </span><span class="si">%s</span><span class="s2"> does not exist&quot;</span> <span class="o">%</span> <span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="o">.</span><span class="n">as_table</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span><span class="o">.</span><span class="n">get_pseudos_for_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_comment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">decorators</span> <span class="k">else</span> <span class="n">decorators</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tags</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.variable_checksum"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.variable_checksum">[docs]</a>    <span class="k">def</span> <span class="nf">variable_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return string with sha1 value in hexadecimal format.</span>
<span class="sd">        This method is mainly used in unit tests to check the invariance</span>
<span class="sd">        of the input objects. Note, indeed, that AbintInput is mutable and therefore</span>
<span class="sd">        should not be used as keyword in dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use sha1 from hashlib because python builtin hash is not deterministic</span>
        <span class="c1"># (hash is version- and machine-dependent)</span>
        <span class="kn">import</span> <span class="nn">hashlib</span>
        <span class="n">sha1</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">tos</span> <span class="o">=</span> <span class="n">unicode</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="c1"># Py3K</span>
            <span class="k">def</span> <span class="nf">tos</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

        <span class="c1"># Add key, values to sha1</span>
        <span class="c1"># (not sure this is code is portable: roundoff errors and conversion to string)</span>
        <span class="c1"># We could just compute the hash from the keys (hash equality does not necessarily imply __eq__!)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="c1"># Use string representation to compute hash</span>
        <span class="c1"># Not perfect but it supposed to be better than the version above</span>
        <span class="c1"># Use alphabetical sorting, don&#39;t write pseudos (treated below).</span>
        <span class="c1">#s = self.to_string(sortmode=&quot;a&quot;, with_mnemonics=False, with_structure=True, with_pseudos=False)</span>
        <span class="c1">#sha1.update(tos(s))</span>

        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span>
        <span class="c1"># add pseudos (this is easy because we have md5)</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">md5</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]))</span>
        <span class="c1"># add the decorators, do we need to add them ?</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">dec</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">sha1</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbinitInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#vars = OrderedDict()</span>
        <span class="c1"># Use a list of (key, value) to serialize the OrderedDict</span>
        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">abi_args</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                    <span class="n">pseudos</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">],</span>
                    <span class="n">comment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span>
                    <span class="n">decorators</span><span class="o">=</span><span class="p">[</span><span class="n">dec</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">],</span>
                    <span class="n">abi_args</span><span class="o">=</span><span class="n">abi_args</span><span class="p">,</span>
                    <span class="n">tags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

<div class="viewcode-block" id="AbinitInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pseudo</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;filepath&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;pseudos&#39;</span><span class="p">]]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">MontyDecoder</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">],</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="n">dec</span><span class="o">.</span><span class="n">process_decoded</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;decorators&quot;</span><span class="p">]),</span>
                   <span class="n">comment</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">],</span> <span class="n">abi_args</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;abi_args&quot;</span><span class="p">],</span> <span class="n">tags</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tags&quot;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_vars&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">key</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacing previously set tolerance variable: </span><span class="si">{0}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS_SCF</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbinitInput</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">GEOVARS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;You cannot set the value of a variable associated to the structure.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Use Structure objects to prepare the input file.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abivar</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid ABINIT variable.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span> <span class="o">+</span>
                             <span class="s2">&quot;If the name is correct, try to remove ~/.abinit/abipy/abinit_vars.pickle</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;and rerun the code. If the problems persists, contact the abipy developers</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or use input.set_spell_check(False)</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or add the variable to ~abipy/data/variables/abinit_vars.json</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#def __eq__(self, other)</span>
    <span class="c1">#def __ne__(self, other)</span>
    <span class="c1">#    return not self.__eq__(other)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A set of strings defining the type of run of the current input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optdriver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optdriver&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optdriver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs&quot;</span><span class="p">):</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">GROUND_STATE</span><span class="p">)</span>
            <span class="n">iscf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">,</span> <span class="mi">17</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">else</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">ionmov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ionmov&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">optcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optcell&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ionmov</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iscf</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">NSCF</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptbounds&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">BANDS</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">SCF</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">RELAX</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">optcell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ION_RELAX</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">IONCELL_RELAX</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">23</span><span class="p">]:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MOLECULAR_DYNACMICS</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DFPT</span><span class="p">)</span>
            <span class="n">rfelfd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span>
            <span class="n">rfphon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DDK</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">BEC</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">DDE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">PH_Q_PERT</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs &quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">STRAIN</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">SCREENING</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">gwcalctyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gwcalctyp&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">gwcalctyp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">HYBRID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">SIGMA</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">99</span><span class="p">:</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">BSE</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">runlevel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span>

<div class="viewcode-block" id="AbinitInput.register_decorator"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.register_decorator">[docs]</a>    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a :class:`AbinitInputDecorator`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_mnemonics"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_mnemonics">[docs]</a>    <span class="k">def</span> <span class="nf">set_mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolean</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">boolean</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uses_ktimereversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if time-reversal symmetry is used to generate k-points in the IBZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_timrev_from_kptopt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptopt&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="AbinitInput.set_spell_check"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spell_check">[docs]</a>    <span class="k">def</span> <span class="nf">set_spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_or_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Activate/Deactivate spell-checking&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">false_or_true</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if spell checking is activated.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># TODO: This is to maintain compatibility with pickle</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="AbinitInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_mnemonics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span>
                  <span class="n">with_structure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;section&quot; if variables should be gruped by sections.</span>
<span class="sd">                &quot;a&quot; for alphabetical order, None if no sorting is wanted.</span>
<span class="sd">            with_mnemonics: True if mnemonics should be added.</span>
<span class="sd">            mode: Either `text` or `html` if HTML output with links is wanted.</span>
<span class="sd">            post: String that will be appended to the name of the variables</span>
<span class="sd">                Note that post is usually autodetected when we have multiple datatasets</span>
<span class="sd">                It is mainly used when we have an input file with a single dataset</span>
<span class="sd">                so that we can prevent the code from adding &quot;1&quot; to the name of the variables</span>
<span class="sd">                (In this case, indeed, Abinit complains if ndtset=1 is not specified</span>
<span class="sd">                and we don&#39;t want ndtset=1 simply because the code will start to add</span>
<span class="sd">                _DS1_ to all the input and output files.</span>
<span class="sd">            with_structure: False if section with structure variables should not be printed.</span>
<span class="sd">            with_pseudos: False if JSON section with pseudo data should not be added.</span>
<span class="sd">            exclude: List of variable names that should be ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">cgi</span>
            <span class="k">def</span> <span class="nf">escape</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">cgi</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">escape</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="n">post</span> <span class="o">=</span> <span class="n">post</span> <span class="k">if</span> <span class="n">post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">mnemonics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnemonics</span>
        <span class="k">if</span> <span class="n">with_mnemonics</span><span class="p">:</span> <span class="n">mnemonics</span> <span class="o">=</span> <span class="n">with_mnemonics</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span> <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># If spell checking is deactivates, we cannot use mmemonics or sormode == &quot;section&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span><span class="p">:</span>
            <span class="n">mnemonics</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">sortmode</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>

        <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">or</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">):</span>
            <span class="c1"># Default is no sorting else alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

            <span class="c1"># Extract the items from the dict and add the geo variables at the end</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

                <span class="c1"># Build variable, convert to string and append it</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="c1"># Group variables by section.</span>
            <span class="c1"># Get dict mapping section_name --&gt; list of variable names belonging to the section.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">sec2names</span> <span class="o">=</span> <span class="n">var_database</span><span class="o">.</span><span class="n">group_by_section</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">92</span>

            <span class="k">for</span> <span class="n">sec</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">sec2names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;SECTION: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sec</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">))</span>

                    <span class="c1"># Build variable, convert to string and append it</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>

                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;STRUCTURE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;# &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">definition</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">))</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">with_pseudos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;html&quot;</span> <span class="k">else</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>

        <span class="c1"># Add JSON section with pseudo potentials.</span>
        <span class="n">ppinfo</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">#&lt;JSON&gt;&quot;</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pseudos&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]}</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;/JSON&gt;&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="n">escape</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ppinfo</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">sortmode</span><span class="o">=</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">with_mnemonics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">,</span>
                              <span class="n">with_structure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional string with comment. None if comment is not set.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="AbinitInput.set_comment"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_comment">[docs]</a>    <span class="k">def</span> <span class="nf">set_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a comment to be included at the top of the file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="n">comment</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The |Structure| object associated to this input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AbinitInput.set_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set structure.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">as_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="c1"># Check volume</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The triple product of the lattice vector is negative. Use structure.abi_sanitize.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span></div>

    <span class="c1"># Helper functions to facilitate the specification of several variables.</span>
<div class="viewcode-block" id="AbinitInput.set_kmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_kmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Monkhorst-Pack divisions</span>
<span class="sd">            shiftk: List of shifts.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_gamma_sampling"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_gamma_sampling">[docs]</a>    <span class="k">def</span> <span class="nf">set_gamma_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gamma-only sampling of the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_kmesh</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbinitInput.set_autokmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autokmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autokmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nksmall</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (ngkpt, shift, kptopt) for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nksmall: Number of k-points used to sample the smallest lattice vector.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_shiftk</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nksmall</span><span class="p">),</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                             <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_phdos_qmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_phdos_qmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_phdos_qmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">ph_qshift</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (ngkpt, shift, kptopt) for the computation of the Phonon DOS in Abinit.</span>
<span class="sd">        Remember that the Phdos is computed via Fourier interpolation so there&#39;s no costraint</span>
<span class="sd">        of the q-mesh.</span>

<span class="sd">        Args:</span>
<span class="sd">            nqsmall: Number of k-points used to sample the smallest lattice vector.</span>
<span class="sd">            method: gaussian or tetra.</span>
<span class="sd">            ph_qshift:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># q-mesh for Fourier interpolatation of IFC and a2F(w)</span>
        <span class="n">ph_ngqpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>
        <span class="n">ph_qshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ph_qshift</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># TODO: Test default values of wstep and smear</span>
        <span class="n">ph_intmeth</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;tetra&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}[</span><span class="n">method</span><span class="p">]</span>
        <span class="n">ph_smear</span> <span class="o">=</span> <span class="s2">&quot;0.001 eV&quot;</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ph_intmeth</span><span class="o">=</span><span class="n">ph_intmeth</span><span class="p">,</span>
            <span class="n">ph_smear</span><span class="o">=</span><span class="n">ph_smear</span><span class="p">,</span>
            <span class="n">ph_wstep</span><span class="o">=</span><span class="s2">&quot;0.0001 eV&quot;</span><span class="p">,</span>
            <span class="n">ph_ngqpt</span><span class="o">=</span><span class="n">ph_ngqpt</span><span class="p">,</span>
            <span class="n">ph_qshift</span><span class="o">=</span><span class="n">ph_qshift</span><span class="p">,</span>
            <span class="n">ph_nqshift</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ph_qshift</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">kptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the electronic band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            kptbounds: k-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">kptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">kptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1">#self.pop_vars([&quot;ngkpt&quot;, &quot;shiftk&quot;]) ??</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptbounds</span><span class="o">=</span><span class="n">kptbounds</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=</span><span class="n">iscf</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_qpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_qpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the phonon band structure</span>
<span class="sd">        and phonon linewidths.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            qptbounds: q-points defining the path in q-space.</span>
<span class="sd">                If None, we use the default high-symmetry q-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">qptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ph_ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">ph_nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">),</span> <span class="n">ph_qpath</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kptgw"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kptgw">[docs]</a>    <span class="k">def</span> <span class="nf">set_kptgw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (k-points, bands) for the computation of GW corrections.</span>

<span class="sd">        Args:</span>
<span class="sd">            kptgw: List of k-points in reduced coordinates.</span>
<span class="sd">            bdgw: Specifies the range of bands for the GW corrections.</span>
<span class="sd">                Accepts iterable that be reshaped to (nkptgw, 2)</span>
<span class="sd">                or a tuple of two integers if the extrema are the same for each k-point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptgw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptgw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">nkptgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdgw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">bdgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span> <span class="o">*</span> <span class="n">bdgw</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptgw</span><span class="o">=</span><span class="n">kptgw</span><span class="p">,</span> <span class="n">nkptgw</span><span class="o">=</span><span class="n">nkptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bdgw</span><span class="p">,</span> <span class="p">(</span><span class="n">nkptgw</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span></div>

<div class="viewcode-block" id="AbinitInput.set_spin_mode"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spin_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_spin_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spin_mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables used to the treat the spin degree of freedom.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            spin_mode: :class:`SpinMode` object or string. Possible values for string are:</span>

<span class="sd">            - polarized</span>
<span class="sd">            - unpolarized</span>
<span class="sd">            - afm (anti-ferromagnetic)</span>
<span class="sd">            - spinor (non-collinear magnetism)</span>
<span class="sd">            - spinor_nomag (non-collinear, no magnetism)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove all variables used to treat spin</span>
        <span class="n">old_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;nsppol&quot;</span><span class="p">,</span> <span class="s2">&quot;nspden&quot;</span><span class="p">,</span> <span class="s2">&quot;nspinor&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_abiobjects</span><span class="p">(</span><span class="n">aobj</span><span class="o">.</span><span class="n">SpinMode</span><span class="o">.</span><span class="n">as_spinmode</span><span class="p">(</span><span class="n">spin_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">old_vars</span></div>

<div class="viewcode-block" id="AbinitInput.set_autospinat"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autospinat">[docs]</a>    <span class="k">def</span> <span class="nf">set_autospinat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable spinat for collinear calculation in the format (0, 0, m) with the value of m determined</span>
<span class="sd">        with the following order of preference:</span>

<span class="sd">        1. If the site of the structure has a magmom setting, that is used.</span>
<span class="sd">        2. If the species on the site has a spin setting, that is used.</span>
<span class="sd">        3. If the species itself has a particular setting in the config file, that</span>
<span class="sd">           is used, e.g., Mn3+ may have a different magmom than Mn4+.</span>
<span class="sd">        4. The element symbol itself is checked in the config file.</span>
<span class="sd">        5. If there are no settings, the default value is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These magnetic moments are from the Materials Project</span>
        <span class="c1"># (MPVaspInputSet.yaml, short_sha1 = a63bcdf)</span>

        <span class="n">magmom_mp_conf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Co&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Co3+&quot;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
            <span class="s2">&quot;Co4+&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;Cr&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Fe&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn3+&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s2">&quot;Mn4+&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s2">&quot;Mo&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ni&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ce&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Eu&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">spinat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;spin&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span> <span class="ow">in</span> <span class="n">magmom_mp_conf</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">spinat</span><span class="o">=</span><span class="n">spinat</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of |Pseudo| objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons computed from the pseudos and the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons for each atom in the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.linspace"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns `num` evenly spaced samples, calculated over the interval [`start`, `stop`].</span>

<span class="sd">        The endpoint of the interval can optionally be excluded.</span>

<span class="sd">        Args:</span>
<span class="sd">            start: The starting value of the sequence.</span>
<span class="sd">            stop: The end value of the sequence, unless `endpoint` is set to False.</span>
<span class="sd">                In that case, the sequence consists of all but the last of ``ndtset + 1``</span>
<span class="sd">                evenly spaced samples, so that `stop` is excluded.  Note that the step</span>
<span class="sd">                size changes when `endpoint` is False.</span>
<span class="sd">            num (int): Number of samples to generate. Default is 50.</span>
<span class="sd">            endpoint (bool): optional. If True, `stop` is the last sample. Otherwise, it is not included.</span>
<span class="sd">                Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.arange"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.arange">[docs]</a>    <span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return evenly spaced values within a given interval.</span>

<span class="sd">        Values are generated within the half-open interval ``[start, stop)``</span>
<span class="sd">        (in other words, the interval including `start` but excluding `stop`).</span>

<span class="sd">        When using a non-integer step, such as 0.1, the results will often not</span>
<span class="sd">        be consistent.  It is better to use ``linspace`` for these cases.</span>

<span class="sd">        Args:</span>
<span class="sd">            start:  Start of interval. The interval includes this value. The default start value is 0.</span>
<span class="sd">            stop: End of interval.  The interval does not include this value, except</span>
<span class="sd">                in some cases where `step` is not an integer and floating point</span>
<span class="sd">            step: Spacing between values.  For any output `out`, this is the distance</span>
<span class="sd">                between two adjacent values, ``out[i+1] - out[i]``.  The default</span>
<span class="sd">                step size is 1.  If `step` is specified, `start` must also be given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.product"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cartesian product of input iterables. Equivalent to nested for-loops.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            inp.product(&quot;ngkpt&quot;, &quot;tsmear&quot;, [[2,2,2], [4,4,4]], [0.1, 0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Split items into varnames and values</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string</span><span class="p">(</span><span class="n">item</span><span class="p">):</span> <span class="k">break</span>

        <span class="n">varnames</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The number of variables must equal the number of lists</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;varnames: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">values </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">varnames</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

        <span class="c1"># TODO: group varnames and varvalues!</span>
        <span class="c1">#varnames = [t[0] for t in items]</span>
        <span class="c1">#values = [t[1] for t in items]</span>

        <span class="n">varnames</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">varnames</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">varnames</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">names</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varnames</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)})</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_vars">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new input with the given variables.</span>

<span class="sd">        Example:</span>
<span class="sd">            new = input.new_with_vars(ecut=20)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

    <span class="c1">#def new_with_supercell(self, scdims):</span>
    <span class="c1">#    sucell = self.structure * scdims</span>
    <span class="c1">#    return new_with_structure(sucell, scdims=scdims)</span>

<div class="viewcode-block" id="AbinitInput.new_with_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_structure">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">,</span> <span class="n">scdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new |AbinitInput| with different structure.</span>
<span class="sd">        See notes below for the constraints that must be fulfilled by the new structure</span>

<span class="sd">        Args:</span>
<span class="sd">            new_structure: Parameters defining the crystalline structure. Accepts |Structure| object</span>
<span class="sd">                file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            scdims: 3 integer giving with the number of cells in the supercell along the three reduced directions.</span>
<span class="sd">                Must be used when `new_structure` represents a supercell of the initial structure defined</span>
<span class="sd">                in the input file.</span>
<span class="sd">            verbose: Verbosity level.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            If ``scdims`` is None (i.e. no supercell), the two structures must have the same value of</span>
<span class="sd">            `natom` and `typat`, they can only differ at the level of the lattice and of the atomic positions.</span>
<span class="sd">            When structure represents a supercell, `scdims` must be coherent with the `new_structure` passed</span>
<span class="sd">            as argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check structure</span>
        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assume same value of natom and typat</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structures must have same value of natom&quot;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">site1</span><span class="p">,</span> <span class="n">site2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">] </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structures must have same order of atomic types:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">scdims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scdims</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting 3 int in scdims but got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scdims</span><span class="p">))</span>

            <span class="n">numcells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numcells</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Number of atoms in the input structure should be </span><span class="si">%d</span><span class="s2"> * </span><span class="si">%d</span><span class="s2"> but found </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">numcells</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

            <span class="n">expected_symbols</span> <span class="o">=</span> <span class="n">numcells</span> <span class="o">*</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">]</span>
            <span class="n">supcell_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">new_structure</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">expected_symbols</span><span class="p">,</span> <span class="n">supcell_symbols</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Wrong supercell. The routine assumes the atoms in the other cells have the</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;same ordering as the atoms in the original cell.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;expected_symbols: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">supercell_symbols: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expected_symbols</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">supcell_symbols</span><span class="p">))</span>
                       <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># TODO Check angles and lengths</span>

        <span class="c1"># Build new input</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">AbinitInput</span><span class="p">(</span><span class="n">new_structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                          <span class="n">decorators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is the tricky part because variables whose shape depends on natom</span>
            <span class="c1"># must be changed in order to be consistent with the supercell.</span>
            <span class="c1"># Here we use the database of abinit variables to find the variables whose shape depends on `natom`.</span>
            <span class="c1"># The method raises ValueError if an array that depends on `natom` is found and no handler is implemented.</span>
            <span class="c1"># It&#39;s better to raise an exception here than having a error when Abinit parses the input file!</span>

            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1">#if var.depends_on_dimension(&quot;ntypat&quot;):</span>
                <span class="c1">#    errors.append(&quot;Found variable %s with ntypat in dimensions %s&quot; % (name, str(var.dimensions)))</span>

                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">depends_on_dimension</span><span class="p">(</span><span class="s2">&quot;natom&quot;</span><span class="p">):</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Found variable </span><span class="si">%s</span><span class="s2"> with natom in dimensions </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)))</span>
                    <span class="c1">#new[name] = _repeat_array(name, new[name], len(self.structure), numcells)</span>

            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">+</span>
                          <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The present version of new_with_structure is not able to handle this case.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

            <span class="c1"># Rescale nband and k-point sampling</span>
            <span class="n">iscale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)))</span>
            <span class="k">if</span> <span class="s2">&quot;nband&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">iscale</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">],</span> <span class="s2">&quot;new[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;ngkpt&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">scdims</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new ngkpt:&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span>

            <span class="c1"># TODO</span>
            <span class="k">elif</span> <span class="s2">&quot;kptrlatt&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;kptrlatt in new_with_structure&quot;</span><span class="p">)</span>
                <span class="c1">#new[&quot;kptrlatt&quot;] = (np.rint(np.array(new[&quot;kptrlatt&quot;]) / iscale)).astype(int)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="c1"># Single k-point</span>
               <span class="k">pass</span>

            <span class="c1"># Add chkprim if not yet done.</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars_ifnotin</span><span class="p">(</span><span class="n">chkprim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_decorators"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_decorators">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receives a list of :class:`AbinitInputDecorator` objects or just a single object,</span>
<span class="sd">        applies the decorators to the input and returns a new |AbinitInput| object. self is not changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decorators</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span> <span class="n">decorators</span> <span class="o">=</span> <span class="p">[</span><span class="n">decorators</span><span class="p">]</span>

        <span class="c1"># Deepcopy only at the first step to improve performance.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decorators</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">dec</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inp</span></div>

<div class="viewcode-block" id="AbinitInput.pop_tolerances"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_tolerances">[docs]</a>    <span class="k">def</span> <span class="nf">pop_tolerances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the tolerance variables present in self.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_irdvars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_irdvars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_irdvars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the `ird*` variables present in self.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_IRDVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1">#def pop_relax_vars(self):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Remove all the `ird*` variables present in self.</span>
    <span class="c1">#    Return dictionary with the variables that have been removed.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    return scf_input.pop_vars([&quot;ionmov&quot;, &quot;optcell&quot;, &quot;ntime&quot;, &quot;dilatmx&quot;])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scf_tolvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tolerance variable and value relative to the SCF convergence.</span>
<span class="sd">        If more than one is present raise an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tolvar</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tolvar</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;More than one tolerance set.&#39;</span><span class="p">)</span>
                <span class="n">tolvar</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tolvar</span><span class="p">,</span> <span class="n">value</span>

<div class="viewcode-block" id="AbinitInput.make_ph_inputs_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ph_inputs_qpoint">[docs]</a>    <span class="k">def</span> <span class="nf">make_ph_inputs_qpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This functions builds and returns a list of input files</span>
<span class="sd">        for the calculation of phonons at the given q-point `qpt`.</span>
<span class="sd">        It should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: q-point in reduced coordinates.</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolvrs&quot;: 1.0e-10}.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of |AbinitInput| objects for DFPT runs.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            The routine assumes the q-point is such that k + q belongs to the initial GS mesh.</span>
<span class="sd">            so that the DFPT run can be started from the WFK file directly without having</span>
<span class="sd">            to generate WFQ files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="c1"># Remove iscf if any (required if we pass an input for NSCF calculation)</span>
        <span class="n">ph_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>
        <span class="n">ph_inputs</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">)</span>

        <span class="c1"># Set kptopt depending on the q-points i.e use time-reversal if Gamma</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Note: this will work for phonons, but not for the other types of perturbations.</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">ph_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">ph_inputs</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                           <span class="c1"># Will consider phonon-type perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                             <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="n">pert</span><span class="o">.</span><span class="n">qpt</span><span class="p">,</span>                       <span class="c1"># q-wavevector.</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ph_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_ddk_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ddk_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_ddk_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for performing DDK calculations.</span>
<span class="sd">        This functions should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            kptopt: 2 to take into account time-reversal symmetry. note that kptopt 1 is not available.</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolwfr&quot;: 1.0e-22}.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of |AbinitInput| objects for DFPT runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;tolvrs&quot;</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;tolvrs should not be used in a DDK calculation&quot;</span><span class="p">)</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1">#perts = self.abiget_irred_phperts(qpt=qpt)</span>
        <span class="c1"># TODO Add symmetries when implemented.</span>
        <span class="n">ddk_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">ddk_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in</span>
        <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">ddk_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">,</span> <span class="n">ddk_inputs</span><span class="p">):</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the d/dk perturbation</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>          <span class="c1"># Direction of the per ddk.</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>        <span class="c1"># 2 to take into account time-reversal symmetry.</span>
                <span class="n">iscf</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span>              <span class="c1"># The d/dk perturbation must be treated in a non-self-consistent way</span>
            <span class="p">)</span>

            <span class="n">ddk_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ddk_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_dde_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dde_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dde_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_symmetries</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the calculation of the electric field perturbations.</span>
<span class="sd">        This functions should be called with an input the represents a gs run.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolwfr&quot;: 1.0e-22}.</span>
<span class="sd">            use_symmetries: boolean that computes the irreducible components of the perturbation.</span>
<span class="sd">                Default to True. Should be set to False for nonlinear coefficients calculation.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of |AbinitInput| objects for DFPT runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">use_symmetries</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Call Abinit to get the list of irred perts.</span>
            <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_ddeperts</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

            <span class="c1"># Build list of datasets (one input per irreducible perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
            <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the dde perturbation.</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute all the directions of the perturbation</span>
            <span class="n">dde_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

            <span class="c1"># Build list of datasets (one input per perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/tnlo_2.in dataset 4</span>
            <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the per ddk.</span>
                    <span class="n">prepanl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>    <span class="c1"># Prepare Non-linear RF calculations.</span>
                <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>       <span class="c1"># Activate the calculation of the electric field perturbation</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>         <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
            <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>       <span class="c1"># Take into account time-reversal symmetry.</span>
        <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_dte_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dte_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dte_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_permutations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the DTE calculation.</span>
<span class="sd">        This functions should be called with an input that represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            phonon_pert: is True also the phonon perturbations will be considered. Default False.</span>
<span class="sd">            skip_permutations: Since the current version of abinit always performs all the permutations</span>
<span class="sd">                of the perturbations, even if only one is asked, if True avoids the creation of inputs that</span>
<span class="sd">                will produce duplicated outputs.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_dteperts</span><span class="p">(</span><span class="n">phonon_pert</span><span class="o">=</span><span class="n">phonon_pert</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">skip_permutations</span><span class="p">:</span>
            <span class="n">perts_to_skip</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">reduced_perts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pert</span> <span class="ow">in</span> <span class="n">perts</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1dir</span><span class="p">),</span> <span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2dir</span><span class="p">),</span> <span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3dir</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">perts_to_skip</span><span class="p">:</span>
                    <span class="n">reduced_perts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>
                    <span class="n">perts_to_skip</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

            <span class="n">perts</span> <span class="o">=</span> <span class="n">reduced_perts</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/tnlo_2.in</span>

        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir1</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i1dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir2</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i2dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir3</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i3dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># atpol if needed. Since there can be only one spatial perturbation</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span><span class="p">)</span>
            <span class="n">atpol</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span> <span class="o">==</span> <span class="n">na</span><span class="o">+</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span> <span class="o">==</span> <span class="n">na</span><span class="o">+</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span> <span class="o">==</span> <span class="n">na</span><span class="o">+</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="n">rfdir1</span><span class="p">,</span>  <span class="c1"># Direction of the dte perturbation.</span>
                <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="n">rfdir2</span><span class="p">,</span>
                <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="n">rfdir3</span><span class="p">,</span>
                <span class="n">d3e_pert1_phon</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert2_phon</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert3_phon</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert1_atpol</span> <span class="o">=</span> <span class="n">atpol</span><span class="p">,</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>         <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
                <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>    <span class="c1"># non-linear response functions, using the 2n+1 theorem.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>       <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_bec_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_bec_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_bec_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for the calculation of the Born effective charges.</span>

<span class="sd">        This functions should be called with an input that represents a GS run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1"># TODO:</span>
        <span class="c1"># Check that one can use the same list of irred perts as in phonons</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_strain_perts_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_strain_perts_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_strain_perts_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-12</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)))</span>

        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_strainperts</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                             <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>
            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (uniaxial)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>
            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (shear)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># No symmetries</span>
                             <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="c1"># Adding buffer to help convergence ...</span>
            <span class="k">if</span> <span class="s1">&#39;nbdbuf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">:</span>
                <span class="n">nbdbuf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;nband&#39;</span><span class="p">]),</span> <span class="mi">4</span><span class="p">)</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nband</span><span class="o">=</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;nband&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">nbdbuf</span><span class="p">,</span> <span class="n">nbdbuf</span><span class="o">=</span><span class="n">nbdbuf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run ABINIT in dry-run mode to validate the input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;--dry-run&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="n">retcode</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_spacegroup"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_spacegroup">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_spacegroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolsym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function invokes Abinit to get the space group (as detected by Abinit, not by spglib)</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolsym: Abinit tolsym input variable. None correspondes to the default value.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            |Structure| object with AbinitSpaceGroup obtained from the main output file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tolsym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;tolsym&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tolsym</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Build a Task to run Abinit in --dry-run mode.</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;--dry-run&quot;</span><span class="p">])</span>

        <span class="c1"># Parse the output file and return structure extracted from run.abo</span>
        <span class="kn">from</span> <span class="nn">abipy.abio.outputs</span> <span class="k">import</span> <span class="n">AbinitOutputFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">AbinitOutputFile</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">initial_structure</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_ibz"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_ibz">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the list of points in the IBZ and the corresponding weights.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: List of shifts (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `namedtuple` with attributes:</span>
<span class="sd">                points: |numpy-array| with points in the IBZ in reduced coordinates.</span>
<span class="sd">                weights: |numpy-array| with weights of the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="c1"># The magic value that makes ABINIT print the ibz and then stop.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;prtkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>
        <span class="c1">#print(&quot;Computing ibz with input:\n&quot;, str(inp))</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Read the list of k-points from the netcdf file.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">NetcdfReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;kpts.nc&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">ibz</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ibz&quot;</span><span class="p">,</span> <span class="s2">&quot;points weights&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ibz</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">),</span>
                           <span class="n">weights</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_weights&quot;</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_handle_task_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">prev_exc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when we have executed a temporary task but we encounter</span>
<span class="sd">        an exception when we try to extract data from the output results produced by Abinit</span>
<span class="sd">        It tries to extract information about the error and finally raises self.Error.</span>

<span class="sd">        .. example::</span>

<span class="sd">            try:</span>

<span class="sd">                do_something_with_the_output_files_produced_by_the_task</span>

<span class="sd">            except Exception as exc:</span>

<span class="sd">                self._handle_task_exception(task, exc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if there are errors in the log file.</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="p">))</span>

        <span class="c1"># Weird condition. Possible explanations:</span>
        <span class="c1"># 1) Abinit cannot be executed or runtime errors due e.g to libraries</span>
        <span class="c1"># 2) IO buffering (Abinit called MPI_ABORT but files are not flushed before aborting.</span>
        <span class="c1"># Try to return as much iformation as possible to aid debugging</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Problem in temp Task executed in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>
                  <span class="s2">&quot;Previous exception </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">prev_exc</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Last 50 line from </span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>
            <span class="n">log_lines</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">50</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_lines</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">50</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">log_lines</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># TODO: in principle task.debug() but I have to change pymatgen.io.abinit</span>
            <span class="n">task</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">debug</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_abiget_irred_perts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            perts_vars: list of variables to be added to get the appropriate perturbation</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="n">qpt</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qpt&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">qpt</span>
        <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;qpt is not in the input and therefore it must be passed explicitly&quot;</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;shiftk&#39;</span><span class="p">]))</span>

        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>       <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span>      <span class="c1"># q-wavevector.</span>
            <span class="n">paral_rf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Magic value to get the list of irreducible perturbations for this q-point.</span>
            <span class="o">**</span><span class="n">perts_vars</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>
        <span class="c1">#print(&quot;Computing irred_perts with input:\n&quot;, str(inp))</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Parse the file to get the perturbations.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">yaml_read_irred_perts</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Sometimes the previous call raises: Cannot find next YAML document in /tmp/tmpskvdr_bo/run.log</span>
            <span class="c1"># perhaps because the log file is still being written (?) so let&#39;s wait a bit.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">yaml_read_irred_perts</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.abiget_irred_phperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_phperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_phperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                         <span class="c1"># Will consider phonon-type perturbation</span>
                            <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)],</span> <span class="c1"># Set of atoms to displace.</span>
                            <span class="n">rfdir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>                  <span class="c1"># Along this set of reduced coordinate axis.</span>
                            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">phperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_ddeperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_ddeperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_ddeperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddeperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># No phonon-type perturbation</span>
                             <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Electric field</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">ddeperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_dteperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_dteperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_dteperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            phonon_pert: if True also the phonon perturbations will be considered. Default False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dteperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d3e_pert1_phon</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">phonon_pert</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>           <span class="c1"># phonon-type perturbation</span>
                             <span class="n">d3e_pert2_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert3_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert1_atpol</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)]</span> <span class="k">if</span> <span class="n">phonon_pert</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>           <span class="c1"># Electric field perturbation</span>
                             <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>                <span class="c1"># non-linear response functions , using the 2n+1 theorem</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>                   <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">dteperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_strainperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_strainperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_strainperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for strain perturbations in DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strainperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                        <span class="c1"># No phonon-type perturbation</span>
                                <span class="n">rfatpol</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)),</span> <span class="c1"># Perturbation of all atoms</span>
                                <span class="n">rfstrs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>                        <span class="c1"># Do the strain perturbations</span>
                                <span class="n">rfdir</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>                   <span class="c1"># All directions</span>
                                <span class="c1"># nqpt=1,                        # One wavevector is to be considered</span>
                                <span class="c1"># qpt=(0, 0, 0),                 # q-wavevector.</span>
                                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>                   <span class="c1"># Take into account time-reversal symmetry.</span>
                                <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span>                           <span class="c1"># Just so that it works with PAW ... #TODO: check this</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">strainperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span>
                                        <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_par_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_par_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_par_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the variables associated to parallelism from the input file.</span>
<span class="sd">        Useful in case of a restart when we need to remove the parallel variables before rerunning autoparal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parvars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;npkpt&#39;</span><span class="p">,</span> <span class="s1">&#39;npfft&#39;</span><span class="p">,</span> <span class="s1">&#39;npband&#39;</span><span class="p">,</span> <span class="s1">&#39;npspinor&#39;</span><span class="p">,</span> <span class="s1">&#39;npimage&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">:</span>
            <span class="n">parvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gwpara&#39;</span><span class="p">)</span>
        <span class="n">popped</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">parvars</span><span class="p">:</span>
            <span class="n">popped</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">popped</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_autoparal_pconfs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_autoparal_pconfs">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_autoparal_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">,</span> <span class="n">autoparal</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the possible configurations up to ``max_ncpus``.</span>
<span class="sd">        Return list of parallel configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c1"># Return code is always != 0</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running in:&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">##############################################################</span>
        <span class="c1"># Parse the autoparal configurations from the main output file</span>
        <span class="c1">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pconfs</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the input</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the input</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MultiDataset"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset">[docs]</a><span class="k">class</span> <span class="nc">MultiDataset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is essentially a list of |AbinitInput| objects.</span>
<span class="sd">    that provides an easy-to-use interface to apply global changes to the</span>
<span class="sd">    the inputs stored in the objects.</span>

<span class="sd">    Let&#39;s assume for example that multi contains two ``AbinitInput`` objects and we</span>
<span class="sd">    want to set `ecut` to 1 in both dictionaries. The direct approach would be:</span>

<span class="sd">        for inp in multi:</span>
<span class="sd">            inp.set_vars(ecut=1)</span>

<span class="sd">    or alternatively:</span>

<span class="sd">        for i in range(multi.ndtset):</span>
<span class="sd">            multi[i].set_vars(ecut=1)</span>

<span class="sd">    MultiDataset provides its own implementaion of __getattr__ so that one can simply use:</span>

<span class="sd">         multi.set_vars(ecut=1)</span>

<span class="sd">        multi.get(&quot;ecut&quot;) returns a list of values. It&#39;s equivalent to:</span>

<span class="sd">            [inp[&quot;ecut&quot;] for inp in multi]</span>

<span class="sd">        Note that if &quot;ecut&quot; is not present in one of the input of multi, the corresponding entry is set to None.</span>
<span class="sd">        A default value can be specified with:</span>

<span class="sd">            multi.get(&quot;paral_kgb&quot;, 0)</span>

<span class="sd">    .. warning::</span>

<span class="sd">        MultiDataset does not support calculations done with different sets of pseudopotentials.</span>
<span class="sd">        The inputs can have different crystalline structures (as long as the atom types are equal)</span>
<span class="sd">        but each input in MultiDataset must have the same set of pseudopotentials.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

<div class="viewcode-block" id="MultiDataset.from_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.from_inputs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_inputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build object from a list of |AbinitInput| objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>

        <span class="c1"># Build MultiDataset from input structures and pseudos and add inputs.</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>

        <span class="c1"># Add variables, decorators and tags.</span>
        <span class="k">for</span> <span class="n">inp</span><span class="p">,</span> <span class="n">new_inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">inp</span><span class="p">)</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">decorators</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="MultiDataset.replicate_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.replicate_input">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">replicate_input</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">ndtset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a multidataset with ndtset from the |AbinitInput| input.&quot;&quot;&quot;</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="n">ndtset</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: file with the structure, |Structure| object or dictionary with ABINIT geo variable</span>
<span class="sd">                Accepts also list of objects that can be converted to Structure object.</span>
<span class="sd">                In this case, however, ndtset must be equal to the length of the list.</span>
<span class="sd">            pseudos: String or list of string with the name of the pseudopotential files.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Setup of the pseudopotential files.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pseudos</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">PseudoTable</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">pseudos</span>

        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudos</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># String(s)</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="n">pseudo_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudo_paths</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find the following pseudopotential files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudo_paths</span><span class="p">)</span>

        <span class="c1"># Build the list of AbinitInput objects.</span>
        <span class="k">if</span> <span class="n">ndtset</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2"> cannot be &lt;=0&quot;</span> <span class="o">%</span> <span class="n">ndtset</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndtset</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndtset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]</span>

        <span class="c1"># Check pseudos</span>
        <span class="c1">#for i in range(self.ndtset):</span>
        <span class="c1">#    if any(p1 != p2 for p1, p2 in zip(self[0].pseudos, self[i].pseudos)):</span>
        <span class="c1">#        raise selfError(&quot;Pseudos must be consistent when from_inputs is invoked.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndtset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of inputs in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pseudopotential objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1">#print(&quot;in getname with name: %s&quot; % name)</span>
        <span class="c1">#m = getattr(self._inputs[0], name)</span>
        <span class="n">_inputs</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_inputs&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot find attribute </span><span class="si">%s</span><span class="s2">. Tried in </span><span class="si">%s</span><span class="s2"> and then in AbinitInput object&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">isattr</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_all</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="c1">#print(&quot;name&quot;, name, &quot;, type:&quot;, type(a), &quot;callable: &quot;,callable(a))</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">results</span>

        <span class="k">if</span> <span class="n">isattr</span><span class="p">:</span> <span class="n">on_all</span> <span class="o">=</span> <span class="n">on_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">on_all</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;self + other&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Operation not supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Operation not supported&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MultiDataset.append"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a |AbinitInput| to the list.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.extend"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extends self with a list of |AbinitInput| objects.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">abinit_inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.addnew_from"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.addnew_from">[docs]</a>    <span class="k">def</span> <span class="nf">addnew_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new entry in the multidataset by copying the input with index ``dtindex``.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">dtindex</span><span class="p">]</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">())</span></div>

<div class="viewcode-block" id="MultiDataset.split_datasets"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.split_datasets">[docs]</a>    <span class="k">def</span> <span class="nf">split_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of |AbinitInput| objects..&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span></div>

<div class="viewcode-block" id="MultiDataset.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the MultiDataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_same_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if all inputs in MultiDataset are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="MultiDataset.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation i.e. the input file read by Abinit.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode: Either ``text`` or ``html`` if HTML output with links is wanted.</span>
<span class="sd">            with_pseudos: False if JSON section with pseudo data should not be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Multi dataset mode.</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">has_same_variable</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">other_inp</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;True if variable kref is present in other_inp with the same value.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">kref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other_inp</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="n">otherv</span> <span class="o">=</span> <span class="n">other_inp</span><span class="p">[</span><span class="n">kref</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">otherv</span><span class="p">)</span>

            <span class="c1"># Don&#39;t repeat variable that are common to the different datasets.</span>
            <span class="c1"># Put them in the `Global Variables` section and exclude these variables in inp.to_string</span>
            <span class="n">global_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k0</span><span class="p">,</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">isame</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span><span class="p">):</span>
                    <span class="n">isame</span> <span class="o">=</span> <span class="n">has_same_variable</span><span class="p">(</span><span class="n">k0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">isame</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">isame</span><span class="p">:</span>
                    <span class="n">global_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k0</span><span class="p">)</span>
            <span class="c1">#print(&quot;global_vars vars&quot;, global_vars)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="mi">92</span>
            <span class="k">if</span> <span class="n">global_vars</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;### Global Variables.&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">global_vars</span><span class="p">:</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="n">var_database</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">])))</span>

            <span class="n">has_same_structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_same_structures</span>
            <span class="k">if</span> <span class="n">has_same_structures</span><span class="p">:</span>
                <span class="c1"># Write structure here and disable structure output in input.to_string</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;STRUCTURE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="n">var_database</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;### DATASET </span><span class="si">%d</span><span class="s2"> ###&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">is_last</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="n">is_last</span> <span class="ow">and</span> <span class="n">with_pseudos</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                  <span class="n">with_structure</span><span class="o">=</span><span class="ow">not</span> <span class="n">has_same_structures</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">global_vars</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># single datasets ==&gt; don&#39;t append the dataset index to the variables.</span>
            <span class="c1"># this trick is needed because Abinit complains if ndtset is not specified</span>
            <span class="c1"># and we have variables that end with the dataset index e.g. acell1</span>
            <span class="c1"># We don&#39;t want to specify ndtset here since abinit will start to add DS# to</span>
            <span class="c1"># the input and output files thus complicating the algorithms we have to use to locate the files.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="n">with_pseudos</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter_ notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MultiDataset.filter_by_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_tags">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_tags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the input according to the tags</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            exclude_tags: A single tag or list/tuple/set of tags that should be excluded</span>

<span class="sd">        Returns:</span>
<span class="sd">            A |MultiDataset| containing the inputs containing all the requested tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">exclude_tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">tags</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_tags</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices to which the tags will be added. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices from which the tags will be removed. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.filter_by_runlevel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_runlevel">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runlevel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new |MultiDataset| object in which only the inputs with the given runlevel are selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">runlevel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="p">{</span><span class="n">runlevel</span><span class="p">}</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">runlevel</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">runlevel</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write ``ndset`` input files to disk. The name of the file</span>
<span class="sd">        is constructed from the dataset index e.g. run0.abi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;DS</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AnaddbInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInputError">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by `AnaddbInput`&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AnaddbInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInput</span><span class="p">(</span><span class="n">AbstractInput</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the anaddb variables.</span>


<span class="sd">    .. rubric:: Inheritance Diagram</span>
<span class="sd">    .. inheritance-diagram:: AnaddbInput</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">AnaddbInputError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>

        <span class="n">anaddb_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">anaddb_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">anaddb_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">anaddb_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">anaddb_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">anaddb_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">anaddb_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">anaddb_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

<div class="viewcode-block" id="AnaddbInput.set_spell_check"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_spell_check">[docs]</a>    <span class="k">def</span> <span class="nf">set_spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_or_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Activate/Deactivate spell-checking&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">false_or_true</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if spell checking is activated.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># This is to maintain compatibility with pickle</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_anaddb_var</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a registered Anaddb variable</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;If you are sure the name is correct, please contact the abipy developers</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or use input.set_spell_check(False)</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;or modify the JSON file abipy/data/variables/anaddb_vars.json&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="AnaddbInput.modes_at_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes_at_qpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">modes_at_qpoint</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">qpoint</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ifcflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input file for the calculation of the phonon frequencies at a given q-point.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            qpoint: Reduced coordinates of the q-point where phonon frequencies and modes are wanted</span>
<span class="sd">            asr, chneut, dipdp, ifcflag: Anaddb input variable. See official documentation.</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included if qpoint==Gamma</span>
<span class="sd">            directions: list of 3D directions along which the LO-TO splitting will be calculated. If None the three</span>
<span class="sd">                cartesian direction will be used</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for phonon frequencies at one q-point&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="c1"># We need a numpy array.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">):</span>
            <span class="n">qpoint</span> <span class="o">=</span> <span class="n">qpoint</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1">#print(type(qpoint), qpoint.shape)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong q-point </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qpoint</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="n">ifcflag</span><span class="p">,</span>        <span class="c1"># Interatomic force constant flag</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>                <span class="c1"># Acoustic Sum Rule</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>          <span class="c1"># Charge neutrality requirement for effective charges.</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>          <span class="c1"># Dipole-dipole interaction treatment</span>
            <span class="c1"># This part is fixed</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># append 0 to specify that these are directions,</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">directions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">))]</span>
            <span class="c1"># add</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.piezo_elastic"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.piezo_elastic">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">piezo_elastic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stress_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build Anaddb input file for the calculation of piezoelectric and elastic tensor calculations.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for piezoelectric and elastic tensor calculation&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stress_correction</span><span class="p">:</span>
            <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">elaflag</span><span class="o">=</span><span class="n">elaflag</span><span class="p">,</span>
            <span class="n">piezoflag</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">instrflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">asr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">symdynmat</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.phbands_and_dos"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.phbands_and_dos">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">phbands_and_dos</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                        <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dos_method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon bands and phonon DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            ndivsm: Used to generate a normalized path for the phonon bands.</span>
<span class="sd">                If gives the number of divisions for the smallest segment of the path.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            dos_method: Possible choices: &quot;tetra&quot;, &quot;gaussian&quot; or &quot;gaussian:0.001 eV&quot;.</span>
<span class="sd">                In the later case, the value 0.001 eV is used as gaussian broadening</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dosdeltae</span><span class="p">,</span> <span class="n">dossmear</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">dos_method</span> <span class="o">==</span> <span class="s2">&quot;tetra&quot;</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="s2">&quot;gaussian&quot;</span> <span class="ow">in</span> <span class="n">dos_method</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dos_method</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">eunit</span> <span class="o">=</span> <span class="n">dos_method</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">dossmear</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">eunit</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Ha&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Wrong value for dos_method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">dos_method</span><span class="p">))</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for phonon bands and DOS&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="c1"># Parameters for the dos.</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_autoqmesh</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">prtdos</span><span class="o">=</span><span class="n">prtdos</span><span class="p">,</span> <span class="n">dosdeltae</span><span class="o">=</span><span class="n">dosdeltae</span><span class="p">,</span> <span class="n">dossmear</span><span class="o">=</span><span class="n">dossmear</span><span class="p">)</span>

        <span class="c1"># Disable DOS computation.</span>
        <span class="k">if</span> <span class="n">nqsmall</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new</span><span class="p">[</span><span class="s2">&quot;prtdos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_qpath</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s1">&#39;qpath&#39;</span><span class="p">]</span>
        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span><span class="p">:</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="c1"># anaddb expects cartesian coordinates for the qph2l list</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">directions</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                    <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.thermo"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.thermo">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">thermo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">nchan</span><span class="o">=</span><span class="mi">1250</span><span class="p">,</span> <span class="n">nwchan</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">thmtol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">ntemper</span><span class="o">=</span><span class="mi">199</span><span class="p">,</span> <span class="n">temperinc</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tempermin</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ngrids</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
               <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon bands and phonon DOS.</span>
<span class="sd">        Note: This method is deprecated because now it&#39;s possible to compute Thermodynamical</span>
<span class="sd">        properties from PhDos</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            nchan:</span>
<span class="sd">            nwchan:</span>
<span class="sd">            thmtol:</span>
<span class="sd">            ntemper:</span>
<span class="sd">            temperinc:</span>
<span class="sd">            tempermin:</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            ngrids:</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>

<span class="sd">            #!Flags</span>
<span class="sd">            # ifcflag   1     ! Interatomic force constant flag</span>
<span class="sd">            # thmflag   1     ! Thermodynamical properties flag</span>
<span class="sd">            #!Wavevector grid number 1 (coarse grid, from DDB)</span>
<span class="sd">            #  brav    2      ! Bravais Lattice : 1-S.C., 2-F.C., 3-B.C., 4-Hex.)</span>
<span class="sd">            #  ngqpt   4  4  4   ! Monkhorst-Pack indices</span>
<span class="sd">            #  nqshft  1         ! number of q-points in repeated basic q-cell</span>
<span class="sd">            #  q1shft  3*0.0</span>
<span class="sd">            #!Effective charges</span>
<span class="sd">            #     asr   1     ! Acoustic Sum Rule. 1 =&gt; imposed asymetrically</span>
<span class="sd">            #  chneut   1     ! Charge neutrality requirement for effective charges.</span>
<span class="sd">            #!Interatomic force constant info</span>
<span class="sd">            #  dipdip  1      ! Dipole-dipole interaction treatment</span>
<span class="sd">            #!Wavevector grid number 2 (series of fine grids, extrapolated from interat forces)</span>
<span class="sd">            #  ng2qpt   20 20 20  ! sample the BZ up to ngqpt2</span>
<span class="sd">            #  ngrids   5         ! number of grids of increasing size#  q2shft   3*0.0</span>
<span class="sd">            #!Thermal information</span>
<span class="sd">            #  nchan   1250   ! # of channels for the DOS with channel width 1 cm-1</span>
<span class="sd">            #  nwchan  5      ! # of different channel widths from this integer down to 1 cm-1</span>
<span class="sd">            #  thmtol  0.120  ! Tolerance on thermodynamical function fluctuations</span>
<span class="sd">            #  ntemper 10     ! Number of temperatures</span>
<span class="sd">            #  temperinc 20.  ! Increment of temperature in K for temperature dependency</span>
<span class="sd">            #  tempermin 20.  ! Minimal temperature in Kelvin</span>
<span class="sd">            # This line added when defaults were changed (v5.3) to keep the previous, old behaviour</span>
<span class="sd">            #  symdynmat 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for thermodynamics&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_autoqmesh</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">thmflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">ngrids</span><span class="o">=</span><span class="n">ngrids</span><span class="p">,</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
            <span class="n">nchan</span><span class="o">=</span><span class="n">nchan</span><span class="p">,</span>
            <span class="n">nwchan</span><span class="o">=</span><span class="n">nwchan</span><span class="p">,</span>
            <span class="n">thmtol</span><span class="o">=</span><span class="n">thmtol</span><span class="p">,</span>
            <span class="n">ntemper</span><span class="o">=</span><span class="n">ntemper</span><span class="p">,</span>
            <span class="n">temperinc</span><span class="o">=</span><span class="n">temperinc</span><span class="p">,</span>
            <span class="n">tempermin</span><span class="o">=</span><span class="n">tempermin</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.modes"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">modes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">enunit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of phonon modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            Structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>

<span class="sd">        #!General information</span>
<span class="sd">        #enunit    2</span>
<span class="sd">        #eivec     1</span>
<span class="sd">        #!Flags</span>
<span class="sd">        #dieflag   1</span>
<span class="sd">        #ifcflag   1</span>
<span class="sd">        #ngqpt     1 1 1</span>
<span class="sd">        #!Effective charges</span>
<span class="sd">        #asr       2</span>
<span class="sd">        #chneut    2</span>
<span class="sd">        # Wavevector list number 1</span>
<span class="sd">        #nph1l     1</span>
<span class="sd">        #qph1l   0.0  0.0  0.0    1.0   ! (Gamma point)</span>
<span class="sd">        #!Wavevector list number 2</span>
<span class="sd">        #nph2l     3      ! number of phonons in list 1</span>
<span class="sd">        #qph2l   1.0  0.0  0.0    0.0</span>
<span class="sd">        #        0.0  1.0  0.0    0.0</span>
<span class="sd">        #        0.0  0.0  1.0    0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for modes&quot;</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">enunit</span><span class="o">=</span><span class="n">enunit</span><span class="p">,</span>
            <span class="n">eivec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dieflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">nph2l</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">qph2l</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.ifc"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.ifc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">ifc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">ifcout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an anaddb input file for the computation of interatomic force constants.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            ifcout: Number of neighbouring atoms for which the ifc&#39;s will be output. If None all the atoms in the big box.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            asr, chneut, dipdip: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADB input for IFC&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1">#TODO add in anaddb an option to get all the atoms if ifcout&lt;0</span>
        <span class="c1"># Huge number abinit will limit to the big box</span>
        <span class="n">ifcout</span> <span class="o">=</span> <span class="n">ifcout</span> <span class="ow">or</span> <span class="mi">10000000</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
            <span class="n">ifcout</span><span class="o">=</span><span class="n">ifcout</span><span class="p">,</span>
            <span class="n">natifc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span>
            <span class="n">atifc</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">ifcana</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">prt_ifc</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|Structure| object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AnaddbInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;a&quot; for alphabetical order, None if no sorting is wanted</span>
<span class="sd">            mode: Either `text` or `html` if HTML output with links is wanted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no sorting.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="c1"># alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="c1"># https://www.abinit.org/doc/helpfiles/for-v8.4/users/anaddb_help.html#mustar</span>
        <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;https://www.abinit.org/doc/helpfiles/for-v8.4/users/anaddb_help.html&quot;</span>
        <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">varname</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;#</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">varname</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter_ notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AnaddbInput.set_qpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_qpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the phonon band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            qptbounds: q-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">qptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">),</span> <span class="n">qpath</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnaddbInput.set_autoqmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_autoqmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autoqmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable nqpt for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nqsmall: Number of divisions used to sample the smallest lattice vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ng2qpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnaddbInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run ANADDB in dry-run mode to validate the input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AnaddbTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddb_node</span><span class="o">=</span><span class="s2">&quot;fake_DDB&quot;</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="c1"># TODO: Anaddb does not support --dry-run</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OpticVar"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticVar">[docs]</a><span class="k">class</span> <span class="nc">OpticVar</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;OpticVar&quot;</span><span class="p">,</span> <span class="s2">&quot;name default group help&quot;</span><span class="p">)):</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sval</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sval</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The url associated to the variable.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: root will change once we move to the new website.</span>
        <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;https://www.abinit.org/sites/default/files/last/users/optic_help.html&quot;</span>
        <span class="k">return</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;#</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="OpticVar.html_link"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticVar.html_link">[docs]</a>    <span class="k">def</span> <span class="nf">html_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the URL of the web page.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;a href=&quot;</span><span class="si">%s</span><span class="s1">&quot; target=&quot;_blank&quot;&gt;</span><span class="si">%s</span><span class="s1">&lt;/a&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">)</span></div></div>



<div class="viewcode-block" id="OpticError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticError">[docs]</a><span class="k">class</span> <span class="nc">OpticError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error class raised by OpticInput.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpticInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput">[docs]</a><span class="k">class</span> <span class="nc">OpticInput</span><span class="p">(</span><span class="n">AbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input file for optic executable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">OpticError</span>

    <span class="c1"># variable name --&gt; default value.</span>
    <span class="n">_VARIABLES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_x&quot;, default=None, help=&quot;Name of the first d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_y&quot;, default=None, help=&quot;Name of the second d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_z&quot;, default=None, help=&quot;Name of the third d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;wfkfile&quot;,   default=None, help=&quot;Name of the ground-state wavefunction file&quot;),</span>

        <span class="c1"># PARAMETERS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;broadening&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Value of the smearing factor, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;domega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.010</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Frequency step (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;maxomega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Maximum frequency (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;scissor&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.000</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Scissor shift if needed, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tolerance on closeness of singularities (in Hartree)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;autoparal&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Autoparal option&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;max_ncpus&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Max number of CPUs considered in autoparal mode&quot;</span><span class="p">),</span>

        <span class="c1"># COMPUTATIONS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of linear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear coefficients to be computed (x=1, y=2, z=3)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of linear electro-optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear electro-optic coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor v2 to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients v2 to be computed&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">_GROUPS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">]</span>

    <span class="c1"># Variable names supported</span>
    <span class="n">_VARNAMES</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">]</span>

    <span class="c1"># Mapping name --&gt; var object.</span>
    <span class="n">_NAME2VAR</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initalize with default values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">)</span>

        <span class="c1"># Update the variables with the values passed by the user</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;varname </span><span class="si">%s</span><span class="s2"> not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">)))</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid optic variable.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;If you are sure the name is correct, please change the _VARIABLES list in:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>  <span class="o">%</span>
                             <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="vm">__file__</span><span class="p">))</span>

<div class="viewcode-block" id="OpticInput.get_default"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.get_default">[docs]</a>    <span class="k">def</span> <span class="nf">get_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the default value of variable `key`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span> <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">default</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2"> in _VARIABLES&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="OpticInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">grp</span><span class="p">,</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">grp</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;@module&quot;</span><span class="p">,</span> <span class="s2">&quot;@class&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">section</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO</span>
    <span class="c1">#@pmg_serialize</span>
<div class="viewcode-block" id="OpticInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GROUPS</span><span class="p">:</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">group</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">my_dict</span></div>

<div class="viewcode-block" id="OpticInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">append</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># One line per variable --&gt; valperline set to None</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">InputVariable</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valperline</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">app</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s2">&quot;! &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">help</span><span class="p">])</span>

        <span class="c1"># Align</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    <span class="c1">#def _repr_html_(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Integration with jupyter notebooks.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.to_string(mode=&quot;html&quot;)</span>

<div class="viewcode-block" id="OpticInput.only_independent_chi_components"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.only_independent_chi_components">[docs]</a>    <span class="k">def</span> <span class="nf">only_independent_chi_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">assume_symmetric_tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the crystal system returned by spglib to find the independent components</span>
<span class="sd">        of the linear susceptibility tensor and set the appropriate variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: Crystalline structure</span>
<span class="sd">            assume_symmetric_tensor: True if tensor can be assumed symmetric.</span>
<span class="sd">                Note that the tensor is symmetric only for a lossless and non-optically active material.</span>
<span class="sd">            symprec, angle_tolerance: Parameters passed to spglib.</span>

<span class="sd">        Return:</span>
<span class="sd">            Set internal variables and return list of components to compute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
        <span class="n">spgan</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">spgan</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span>

        <span class="c1"># Table 1.5.1 of https://booksite.elsevier.com/samplechapters/9780123694706/Sample_Chapters/02~Chapter_1.pdf.</span>
        <span class="c1"># Note that the tensor is symmetric only for a lossless and non-optically active material.</span>
        <span class="n">components_for_system</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz xy yx xz zx yz zy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz xz zx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span> <span class="s2">&quot;xx zz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">assume_symmetric_tensor</span><span class="p">:</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;triclinic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xx yy zz xy xz yz&quot;</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;monoclinic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xx yy zz xz&quot;</span>

        <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;trigonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;tetragonal&quot;</span><span class="p">]</span>
        <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;hexagonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;tetragonal&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">components_for_system</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">ind_comps</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="n">system</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;num_lin_comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_comps</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;lin_comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">ind_comps</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ind_comps</span></div>

<div class="viewcode-block" id="OpticInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run OPTIC in dry-run mode to validate the input file.</span>
<span class="sd">        Note: This method is a stub, it always return retcode 0</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Optic does not support --dry-run</span>
        <span class="c1">#task = OpticTask.temp_shell_task(inp=self, workdir=workdir, manager=manager)</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cut3DInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput">[docs]</a><span class="k">class</span> <span class="nc">Cut3DInput</span><span class="p">(</span><span class="n">MSONable</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the options to run a single cut3d analysis.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Converters with nspden &gt; 1 won&#39;t work since cut3d asks for the ispden index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            options: a list of strings that defines the options to be passed to cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="o">=</span> <span class="n">infile_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span> <span class="o">=</span> <span class="n">output_filepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">options</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Cut3DInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string with the input.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes the input to a file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Infile path and options should be provided&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">out_option</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic function used to generate the input for convertions using cut3d</span>

<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            out_option: a number corresponding to the required converting option in cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">out_option</span><span class="p">)]</span>  <span class="c1"># Option to convert a _DEN file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="Cut3DInput.den_to_3d_formatted"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_formatted">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_3d_formatted</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D formatted format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit.</span>
<span class="sd">                Can be None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_3d_indexed"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_indexed">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_3d_indexed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D indexed format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_molekel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_molekel">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_molekel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Molekel format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_tecplot"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_tecplot">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_tecplot</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Tecplot format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_xsf"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_xsf">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_xsf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to an xsf format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            shift: a list of three integers defining the shift along the x, y, z axis.</span>
<span class="sd">                None if no shift is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;9&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert a _DEN file to an .xsf file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output .xsf file</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">shift</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_cube"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_cube">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_cube</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a cube format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.hirshfeld"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hirshfeld</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            all_el_dens_paths: a list of paths to the all-electron density files corresponding to the elements defined</span>
<span class="sd">                in the abinit input. See https://www.abinit.org/downloads/all_core_electron for files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert _DEN file to a .cube file</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_el_dens_paths</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.hirshfeld_from_fhi_path"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld_from_fhi_path">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hirshfeld_from_fhi_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">fhi_all_el_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density. Automatically</span>
<span class="sd">        selects the all-electron density files from a folder containing the fhi all-electron density files:</span>
<span class="sd">        https://www.abinit.org/downloads/all_core_electron</span>

<span class="sd">        This will work only if the input has been generated with AbinitInput and the Structure object is the same</span>
<span class="sd">        provided to AbinitInput.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            structure: the structure used for the ground state calculation. Used to determine the elements</span>
<span class="sd">            fhi_all_el_path: path to the folder containing the fhi all-electron density files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_el_dens_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This relies on AbinitInput using Structure.types_of_specie to define znucl</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">types_of_specie</span><span class="p">:</span>
            <span class="n">all_el_dens_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fhi_all_el_path</span><span class="p">,</span> <span class="s2">&quot;0.</span><span class="si">{:02}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">.8.density.AE&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">hirshfeld</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;infile_path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_filepath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">options</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="product_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.product_dict">[docs]</a><span class="k">def</span> <span class="nf">product_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function receives a dictionary d where each key defines a list of items or a simple scalar.</span>
<span class="sd">    It constructs the Cartesian product of the values (equivalent to nested for-loops),</span>
<span class="sd">    and returns a list of dictionaries with the values that would be used inside the loop.</span>

<span class="sd">    &gt;&gt;&gt; d = OrderedDict([(&quot;foo&quot;, [2, 4]), (&quot;bar&quot;, 1)])</span>
<span class="sd">    &gt;&gt;&gt; product_dict(d) == [OrderedDict([(&#39;foo&#39;, 2), (&#39;bar&#39;, 1)]), OrderedDict([(&#39;foo&#39;, 4), (&#39;bar&#39;, 1)])]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; d = OrderedDict([(&quot;bar&quot;, [1,2]), (&#39;foo&#39;, [3,4])])</span>
<span class="sd">    &gt;&gt;&gt; product_dict(d) == [{&#39;bar&#39;: 1, &#39;foo&#39;: 3},</span>
<span class="sd">    ... {&#39;bar&#39;: 1, &#39;foo&#39;: 4},</span>
<span class="sd">    ... {&#39;bar&#39;: 2, &#39;foo&#39;: 3},</span>
<span class="sd">    ... {&#39;bar&#39;: 2, &#39;foo&#39;: 4}]</span>
<span class="sd">    True</span>

<span class="sd">    .. warning:</span>

<span class="sd">        Dictionaries are not ordered, therefore one cannot assume that</span>
<span class="sd">        the order of the keys in the output equals the one used to loop.</span>
<span class="sd">        If the order is important, one should pass a :class:`OrderedDict` in input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># Each item in vals must be iterable.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># Build list of dictionaries. Use ordered dicts so that</span>
    <span class="c1"># we preserve the order when d is an OrderedDict.</span>
    <span class="n">vars_prod</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">prod_values</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">):</span>
        <span class="n">dprod</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">prod_values</span><span class="p">))</span>
        <span class="n">vars_prod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dprod</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vars_prod</span></div>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2018, The AbiPy group.<br/>
      Last updated on Feb 22, 2018.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>