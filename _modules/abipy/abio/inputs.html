

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>abipy.abio.inputs &mdash; abipy 0.9.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/my_style.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
    <script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script> 
    
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> abipy
          

          
          </a>

          
            
            
              <div class="version">
                0.9.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Getting AbiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zzbiblio.html">Bibliography</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphical_interface.html">Graphical interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">AbiPy Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../postprocessing_howto.html">Post-processing How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/taskmanager.html">TaskManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/manager_examples.html">Manager Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flow_gallery/index.html">Flow Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flows_howto.html">Flows How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coding_guide.html">Coding guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">Documenting AbiPy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">abipy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>abipy.abio.inputs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for abipy.abio.inputs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines objects to facilitate the creation of ABINIT input files.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">abipy.abio.input_tags</span> <span class="k">as</span> <span class="nn">atags</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="kn">import</span> <span class="n">dict2namedtuple</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="kn">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="kn">import</span> <span class="n">MontyDecoder</span><span class="p">,</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="kn">import</span> <span class="n">Energy</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.serialization</span> <span class="kn">import</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.bandstructure</span> <span class="kn">import</span> <span class="n">HighSymmKpath</span>
<span class="kn">from</span> <span class="nn">abipy.tools.numtools</span> <span class="kn">import</span> <span class="n">is_diagonal</span>
<span class="kn">from</span> <span class="nn">abipy.core.structure</span> <span class="kn">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">abipy.core.mixins</span> <span class="kn">import</span> <span class="n">Has_Structure</span>
<span class="kn">from</span> <span class="nn">abipy.core.kpoints</span> <span class="kn">import</span> <span class="n">has_timrev_from_kptopt</span>
<span class="kn">from</span> <span class="nn">abipy.abio.variable</span> <span class="kn">import</span> <span class="n">InputVariable</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars</span> <span class="kn">import</span> <span class="n">is_abivar</span><span class="p">,</span> <span class="n">is_anaddb_var</span>
<span class="kn">from</span> <span class="nn">abipy.abio.abivars_db</span> <span class="kn">import</span> <span class="n">get_abinit_variables</span><span class="p">,</span> <span class="n">get_anaddb_variables</span>
<span class="kn">from</span> <span class="nn">abipy.tools</span> <span class="kn">import</span> <span class="n">duck</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk</span> <span class="kn">import</span> <span class="n">PseudoTable</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">,</span> <span class="n">AnaddbTask</span><span class="p">,</span> <span class="n">ParalHintsParser</span><span class="p">,</span> <span class="n">NetcdfReader</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk.abiinspect</span> <span class="kn">import</span> <span class="n">yaml_read_irred_perts</span>
<span class="kn">from</span> <span class="nn">abipy.flowtk</span> <span class="kn">import</span> <span class="n">abiobjects</span> <span class="k">as</span> <span class="n">aobj</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span>


<span class="c1"># List of Abinit variables used to specify the structure.</span>
<span class="c1"># This variables should not be passed to set_vars since</span>
<span class="c1"># they will be automatically generated by calling structure.to_abivars()</span>
<span class="n">GEOVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;acell&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rprimd&quot;</span>
    <span class="s2">&quot;angdeg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xred&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xcart&quot;</span><span class="p">,</span>
    <span class="s2">&quot;xangst&quot;</span><span class="p">,</span>
    <span class="s2">&quot;znucl&quot;</span><span class="p">,</span>
    <span class="s2">&quot;typat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ntypat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;natom&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances (used in pop_tolerances)</span>
<span class="n">_TOLVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolimg&quot;</span><span class="p">,</span> <span class="c1"># ?</span>
    <span class="s2">&quot;tolmxf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;tolrde&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables defining tolerances for the SCF cycle (mutually exclusive).</span>
<span class="n">_TOLVARS_SCF</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s1">&#39;toldfe&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolvrs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolwfr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tolrff&#39;</span><span class="p">,</span>
    <span class="s2">&quot;toldff&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># Variables determining if data files should be read in input</span>
<span class="n">_IRDVARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
    <span class="s2">&quot;irdbseig&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdbsreso&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdhaydock&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdddk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdden&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1den&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdqps&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdkss&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdscr&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdsuscep&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdvdw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfk&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfkfine&quot;</span><span class="p">,</span>
    <span class="s2">&quot;irdwfq&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ird1wf&quot;</span><span class="p">,</span>
<span class="p">])</span>

<span class="c1"># FIXME __mul__ operator in pymatgen should allow for grouping atoms by individual cells</span>
<span class="c1"># The present version group by image.</span>
<span class="c1">#def _repeat_array(name, values, from_natom, numcells):</span>
<span class="c1">#    if name in {&quot;spinat&quot;,}:</span>
<span class="c1">#        # [:, natom]</span>
<span class="c1">#        values = np.reshape(values, (-1, from_natom))</span>
<span class="c1">#        return np.repeat(values, numcells, axis=0)</span>
<span class="c1">#    else:</span>
<span class="c1">#        raise ValueError(&quot;Don&#39;t know how to reallocate variable %s&quot; % str(name))</span>


<div class="viewcode-block" id="AbstractInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput">[docs]</a><span class="k">class</span> <span class="nc">AbstractInput</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class defining the methods that must be implemented by Input classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ABC protocol</span>
    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> at </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="AbstractInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the input file to file ``filepath``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbstractInput.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>

        <span class="c1"># Just to make life easier to the user, we update some dimensions</span>
        <span class="c1"># if only the &quot;array&quot; part is specified in input.</span>
        <span class="k">if</span> <span class="s2">&quot;shiftk&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nshiftk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;shiftk&quot;</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="AbstractInput.set_vars_ifnotin"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.set_vars_ifnotin">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars_ifnotin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of the variables only if the variable is not already present.</span>
<span class="sd">        Return dict with the variables added to the input.</span>

<span class="sd">        Example:</span>

<span class="sd">            input.set_vars(ecut=10, ionmov=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">added</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">varname</span><span class="p">,</span> <span class="n">varvalue</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">varname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
                <span class="n">added</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">varvalue</span>
        <span class="k">return</span> <span class="n">added</span></div>

<div class="viewcode-block" id="AbstractInput.pop_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.pop_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        Unlike remove_vars, no exception is raised if the variables are not in the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>

<span class="sd">        Example:</span>

<span class="sd">            inp.pop_vars([&quot;ionmov&quot;, &quot;optcell&quot;, &quot;ntime&quot;, &quot;dilatmx&quot;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbstractInput.remove_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.remove_vars">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the variables listed in keys.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            keys: string or list of strings with variable names.</span>
<span class="sd">            strict: If True, KeyError is raised if at least one variable is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">removed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;key: </span><span class="si">%s</span><span class="s2"> not in self:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">removed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">removed</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with the input variables. Used to implement the dict-like interface.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if key is a valid name. Raise self.Error if not valid.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbstractInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.to_string">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns string with the input.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AbstractInput.generate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbstractInput.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function generates new inputs by replacing the variables specified in kwargs.</span>

<span class="sd">        Args:</span>
<span class="sd">            kwargs: keyword arguments with the values used for each variable.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            gs_inp = call_function_to_generate_initial_template()</span>

<span class="sd">            # To generate two input files with different values of ecut:</span>
<span class="sd">            for inp_ecut in gs_inp.generate(ecut=[10, 20]):</span>
<span class="sd">                print(&quot;do something with inp_ecut %s&quot; % inp_ecut)</span>

<span class="sd">            # To generate four input files with all the possible combinations of ecut and nsppol:</span>
<span class="sd">            for inp_ecut in gs_inpt.generate(ecut=[10, 20], nsppol=[1, 2]):</span>
<span class="sd">                print(&quot;do something with inp_ecut %s&quot; % inp_ecut)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Is this method still used?</span>
        <span class="k">for</span> <span class="n">new_vars</span> <span class="ow">in</span> <span class="n">product_dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">new_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="c1"># Remove the variable names to avoid annoying warnings if the variable is overwritten.</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">new_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">new_vars</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">new_inp</span></div></div>


<div class="viewcode-block" id="AbiAbstractInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbiAbstractInput">[docs]</a><span class="k">class</span> <span class="nc">AbiAbstractInput</span><span class="p">(</span><span class="n">AbstractInput</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class defining the methods that must be implemented by Input objects.</span>
<span class="sd">    associated to Abinit executables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbiAbstractInput.add_abiobjects"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbiAbstractInput.add_abiobjects">[docs]</a>    <span class="k">def</span> <span class="nf">add_abiobjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">abi_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receive a list of ``AbiVarable`` objects and add</span>
<span class="sd">        the corresponding variables to the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">abi_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;to_abivars&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;type </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> does not have `to_abivars` method&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="AbiAbstractInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbiAbstractInput.abivalidate">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should invoke the executable associated to the input object.</span>
<span class="sd">        to test whether the input variables are correct and consistent.</span>
<span class="sd">        The executable is supposed to implement some sort of `--dry-run` option</span>
<span class="sd">        that invokes the parser to validate the input and exits immediately.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the IBZ. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            ``namedtuple`` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="AbinitInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInputError">[docs]</a><span class="k">class</span> <span class="nc">AbinitInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by ``AbinitInput``.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AbinitInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput">[docs]</a><span class="k">class</span> <span class="nc">AbinitInput</span><span class="p">(</span><span class="n">AbiAbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the ABINIT variables for a single dataset.</span>

<span class="sd">    .. rubric:: Inheritance Diagram</span>
<span class="sd">    .. inheritance-diagram:: AbinitInput</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">abi_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enforce_znucl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enforce_typat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: Parameters defining the crystalline structure. Accepts |Structure| object</span>
<span class="sd">            file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            pseudos: Pseudopotentials to be used for the calculation. Accepts: string or list of strings</span>
<span class="sd">                with the name of the pseudopotential files, list of |Pseudo| objects</span>
<span class="sd">                or |PseudoTable| object.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            decorators: List of `AbinitInputDecorator` objects.</span>
<span class="sd">            abi_args: list of tuples (key, value) with the initial set of variables. Default: Empty</span>
<span class="sd">            abi_kwargs: Dictionary with the initial set of variables. Default: Empty</span>
<span class="sd">            tags: list/set of tags describing the input</span>
<span class="sd">            enforce_znucl: Use this value of `znucl` (ntypat entries) when converting the structure to Abinit variables.</span>
<span class="sd">                Mainly used when we are running calculations that need to read external files</span>
<span class="sd">                with an ordering of the types that differ from the one used by AbiPy that is based on the first</span>
<span class="sd">                occurrence of the element in structure.sites.</span>
<span class="sd">            enforce_typat: Use this value of `typat` (natom array) when converting the structure to Abinit variables.</span>
<span class="sd">                Requires `enforce_typat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">abi_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abi_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">abi_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">abi_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">abi_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">abi_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abi_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">abi_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pseudo_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">):</span> <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Directory `</span><span class="si">%s</span><span class="s2">` does not exist&quot;</span> <span class="o">%</span> <span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="o">.</span><span class="n">as_table</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span><span class="o">.</span><span class="n">get_pseudos_for_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_comment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">decorators</span> <span class="k">else</span> <span class="n">decorators</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">tags</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl_and_typat</span><span class="p">(</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="n">enforce_typat</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.enforce_znucl_and_typat"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.enforce_znucl_and_typat">[docs]</a>    <span class="k">def</span> <span class="nf">enforce_znucl_and_typat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">znucl</span><span class="p">,</span> <span class="n">typat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These arrays are used to enforce a particular value of `znucl` and `typat` when writing the Abinit input file</span>
<span class="sd">        This trick may be useful if the ordering of the types based on the sites in the structure does not</span>
<span class="sd">        match the one used to produce other input file such as DDB/DVDB.</span>
<span class="sd">        The ordering indeed changed ...</span>

<span class="sd">        znucl[ntypat] =</span>
<span class="sd">        typat[natom] = Fortran convention. Start to count from 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl</span> <span class="o">=</span> <span class="n">znucl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enforce_typat</span> <span class="o">=</span> <span class="n">typat</span>
        <span class="k">if</span> <span class="n">znucl</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">typat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>

        <span class="c1"># Consistency check</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">typat</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;typat contains </span><span class="si">%d</span><span class="s2"> entries while it should be natom: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">typat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)))</span>

        <span class="n">ntypat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">ntypesp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">znucl</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ntypat</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;znucl contains </span><span class="si">%d</span><span class="s2"> entries while it should be ntypat: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">znucl</span><span class="p">),</span> <span class="n">ntypat</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbinitInput.variable_checksum"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.variable_checksum">[docs]</a>    <span class="k">def</span> <span class="nf">variable_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return string with sha1 value in hexadecimal format.</span>
<span class="sd">        This method is mainly used in unit tests to check the invariance of the input objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use sha1 from hashlib because python builtin hash is not deterministic</span>
        <span class="c1"># (hash is version- and machine-dependent)</span>
        <span class="kn">import</span> <span class="nn">hashlib</span>
        <span class="n">sha1</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">tos</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

        <span class="c1"># Add key, values to sha1</span>
        <span class="c1"># (not sure this is code is portable: roundoff errors and conversion to string)</span>
        <span class="c1"># We could just compute the hash from the keys (hash equality does not necessarily imply __eq__!)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="c1"># Use string representation to compute hash</span>
        <span class="c1"># Not perfect but it supposed to be better than the version above</span>
        <span class="c1"># Use alphabetical sorting, don&#39;t write pseudos (treated below).</span>
        <span class="c1">#s = self.to_string(sortmode=&quot;a&quot;, with_mnemonics=False, with_structure=True, with_pseudos=False)</span>
        <span class="c1">#sha1.update(tos(s))</span>

        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span>
        <span class="c1"># add pseudos (this is easy because we have md5)</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">md5</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]))</span>
        <span class="c1"># add the decorators, do we need to add them ?</span>
        <span class="n">sha1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tos</span><span class="p">([</span><span class="n">dec</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">sha1</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

<div class="viewcode-block" id="AbinitInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">abi_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">abi_args</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                    <span class="n">pseudos</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">],</span>
                    <span class="n">comment</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span>
                    <span class="n">decorators</span><span class="o">=</span><span class="p">[</span><span class="n">dec</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">dec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">],</span>
                    <span class="n">abi_args</span><span class="o">=</span><span class="n">abi_args</span><span class="p">,</span>
                    <span class="n">tags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">),</span>
                    <span class="n">enforce_znucl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span>
                    <span class="n">enforce_typat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">,</span>
                    <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with variables.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

<div class="viewcode-block" id="AbinitInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pseudo</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;filepath&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;pseudos&#39;</span><span class="p">]]</span>
        <span class="n">dec</span> <span class="o">=</span> <span class="n">MontyDecoder</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">],</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">decorators</span><span class="o">=</span><span class="n">dec</span><span class="o">.</span><span class="n">process_decoded</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;decorators&quot;</span><span class="p">]),</span>
                   <span class="n">comment</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">],</span> <span class="n">abi_args</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;abi_args&quot;</span><span class="p">],</span> <span class="n">tags</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tags&quot;</span><span class="p">],</span>
                   <span class="n">enforce_znucl</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;enforce_znucl&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">enforce_typat</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;enforce_typat&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements: self[key] = value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_vars&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">key</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Replacing previously set tolerance variable: </span><span class="si">{0}</span><span class="s2">.&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS_SCF</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether key is a valid (and allowed) variable name&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">GEOVARS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;You cannot set the value of a variable associated to the crystalline structure.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;Use Structure objects to prepare the input file.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_abivar</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Cannot find variable `</span><span class="si">%s</span><span class="s2">` in internal database. If you believe this is not a typo, use:</span>

<span class="s2">    input.set_spell_check(False)</span>

<span class="s2">to disable spell checking. Perhaps the internal database is not in synch</span>
<span class="s2">with the Abinit version you are using. Please contact the AbiPy developers.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A set of strings defining the calculation type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">optdriver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optdriver&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">optdriver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs&quot;</span><span class="p">):</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optdriver</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># GS run</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">GROUND_STATE</span><span class="p">)</span>
            <span class="n">iscf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">,</span> <span class="mi">17</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">else</span> <span class="mi">7</span><span class="p">)</span>
            <span class="n">ionmov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ionmov&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">optcell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;optcell&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ionmov</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iscf</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">NSCF</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptbounds&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">BANDS</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">SCF</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">RELAX</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">optcell</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">ION_RELAX</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">IONCELL_RELAX</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ionmov</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">23</span><span class="p">]:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">MOLECULAR_DYNAMICS</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># DFPT run.</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">DFPT</span><span class="p">)</span>
            <span class="n">rfelfd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">)</span>
            <span class="n">rfphon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfddk&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">DDK</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfelfd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">BEC</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">DDE</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rfphon</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">PH_Q_PERT</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs &quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">STRAIN</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># SCR run.</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">atags</span><span class="o">.</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">atags</span><span class="o">.</span><span class="n">SCREENING</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># SIGMA run.</span>
            <span class="n">gwcalctyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gwcalctyp&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">gwcalctyp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atags</span><span class="o">.</span><span class="n">HYBRID</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">atags</span><span class="o">.</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">atags</span><span class="o">.</span><span class="n">SIGMA</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">optdriver</span> <span class="o">==</span> <span class="mi">99</span><span class="p">:</span>
            <span class="c1"># BSE run</span>
            <span class="n">runlevel</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="n">atags</span><span class="o">.</span><span class="n">MANY_BODY</span><span class="p">,</span> <span class="n">atags</span><span class="o">.</span><span class="n">BSE</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">runlevel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of decorators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span>

<div class="viewcode-block" id="AbinitInput.register_decorator"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.register_decorator">[docs]</a>    <span class="k">def</span> <span class="nf">register_decorator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a :class:`AbinitInputDecorator`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_mnemonics"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_mnemonics">[docs]</a>    <span class="k">def</span> <span class="nf">set_mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolean</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">boolean</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mnemonics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if mnemonics should be printed&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mnemonics</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uses_ktimereversal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if time-reversal symmetry is used to generate k-points in the IBZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_timrev_from_kptopt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptopt&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="AbinitInput.set_spell_check"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spell_check">[docs]</a>    <span class="k">def</span> <span class="nf">set_spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_or_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Activate/Deactivate spell-checking&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">false_or_true</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if spell checking is activated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span>

<div class="viewcode-block" id="AbinitInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">post</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_mnemonics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span>
                  <span class="n">with_structure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;section&quot; if variables should be grouped by sections.</span>
<span class="sd">                &quot;a&quot; for alphabetical order, None if no sorting is wanted.</span>
<span class="sd">            with_mnemonics: True if mnemonics should be added.</span>
<span class="sd">            mode: Either `text` or `html` if HTML output with links is wanted.</span>
<span class="sd">            post: String that will be appended to the name of the variables</span>
<span class="sd">                Note that post is usually autodetected when we have multiple datatasets</span>
<span class="sd">                It is mainly used when we have an input file with a single dataset</span>
<span class="sd">                so that we can prevent the code from adding &quot;1&quot; to the name of the variables</span>
<span class="sd">                (In this case, indeed, Abinit complains if ndtset=1 is not specified</span>
<span class="sd">                and we don&#39;t want ndtset=1 simply because the code will start to add</span>
<span class="sd">                _DS1_ to all the input and output files.</span>
<span class="sd">            with_structure: False if section with structure variables should not be printed.</span>
<span class="sd">            with_pseudos: False if JSON section with pseudo data should not be added.</span>
<span class="sd">            exclude: List of variable names that should be ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">html</span>

            <span class="k">def</span> <span class="nf">escape</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">html</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">escape</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">text</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="n">post</span> <span class="o">=</span> <span class="n">post</span> <span class="k">if</span> <span class="n">post</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">mnemonics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mnemonics</span>
        <span class="k">if</span> <span class="n">with_mnemonics</span><span class="p">:</span> <span class="n">mnemonics</span> <span class="o">=</span> <span class="n">with_mnemonics</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span> <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># If spell checking is deactivated, we cannot use mmemonics or sormode == &quot;section&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span><span class="p">:</span>
            <span class="n">mnemonics</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">sortmode</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>

        <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">or</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">):</span>
            <span class="c1"># Default is no sorting else alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

            <span class="c1"># Extract the items from the dict and add the geo variables at the end</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">enforce_znucl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="n">enforce_typat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>
                <span class="n">items</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">app</span><span class="p">(</span><span class="s2">&quot;#### &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">mnemonics</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

                <span class="c1"># Build variable, convert to string and append it</span>
                <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;section&quot;</span><span class="p">:</span>
            <span class="c1"># Group variables by section.</span>
            <span class="c1"># Get dict mapping section_name --&gt; list of variable names belonging to the section.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">sec2names</span> <span class="o">=</span> <span class="n">var_database</span><span class="o">.</span><span class="n">group_by_varset</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">46</span>

            <span class="k">for</span> <span class="n">sec</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">sec2names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;####&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;SECTION: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sec</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;#### &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">mnemonics</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">))</span>

                    <span class="c1"># Build variable, convert to string and append it</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>

                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">with_structure</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;####&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;STRUCTURE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">enforce_znucl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="n">enforce_typat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">mnemonics</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">app</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;#### &lt;&quot;</span> <span class="o">+</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">mnemonics</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">))</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">post</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
                    <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
            <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>
            <span class="c1"># insert text inside div so that we can style it.</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;div class=&quot;abinit_input&quot;&gt;</span><span class="se">\n</span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="se">\n</span><span class="s1">&lt;div&gt;&#39;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">with_pseudos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;html&quot;</span> <span class="k">else</span> <span class="n">to_html</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="c1"># Add JSON section with pseudo potentials.</span>
        <span class="n">ppinfo</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">#&lt;JSON&gt;&quot;</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;pseudos&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">]}</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
        <span class="n">ppinfo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&lt;/JSON&gt;&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">+=</span> <span class="n">escape</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ppinfo</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">to_html</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">sortmode</span><span class="o">=</span><span class="s2">&quot;section&quot;</span><span class="p">,</span> <span class="n">with_mnemonics</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">,</span>
                              <span class="n">with_structure</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Optional string with comment. None if comment is not set.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="AbinitInput.set_comment"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_comment">[docs]</a>    <span class="k">def</span> <span class="nf">set_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set a comment to be included at the top of the file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="n">comment</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The |Structure| object associated to this input.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AbinitInput.set_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set structure.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">as_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="c1"># Check volume</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The triple product of the lattice vector is negative. Use structure.abi_sanitize.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span></div>

    <span class="k">def</span> <span class="nf">_check_nsppol_nspinor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsppol</span><span class="p">,</span> <span class="n">nspinor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal function to check consistency between nsppol and nspinor provided by the user.</span>
<span class="sd">        Raises: AbinitInputError if inconsistent values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eapp</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="n">nsppol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="n">eapp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nsppol should be either 1 or 2 while it is: </span><span class="si">{</span><span class="n">nsppol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nspinor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsppol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">eapp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nsppol should be 1 or 2 when nspinor == 2 while it is: </span><span class="si">{</span><span class="n">nsppol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">nspinor</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nsppol</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="n">eapp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nsppol must be 1 when nspinor == 1 while it is: </span><span class="si">{</span><span class="n">nsppol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">nspden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nspden&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nspden</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">nspden</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="n">eapp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nspden should be either 1 or 4 when nspinor == 2 while it is: </span><span class="si">{</span><span class="n">nspden</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eapp</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value for nspinor: </span><span class="si">{</span><span class="n">nspinor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1">########################################################################</span>
    <span class="c1"># Helper functions to facilitate the specification of several variables.</span>
    <span class="c1">########################################################################</span>

<div class="viewcode-block" id="AbinitInput.set_kmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_kmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Monkhorst-Pack divisions</span>
<span class="sd">            shiftk: List of shifts.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_gamma_sampling"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_gamma_sampling">[docs]</a>    <span class="k">def</span> <span class="nf">set_gamma_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gamma-only sampling of the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_kmesh</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="AbinitInput.set_autokmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autokmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autokmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nksmall</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (ngkpt, shift, kptopt) for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nksmall: Number of k-points used to sample the smallest lattice vector.</span>
<span class="sd">            kptopt: Option for the generation of the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_shiftk</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nksmall</span><span class="p">),</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                             <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">),</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.get_ngkpt_shiftk"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.get_ngkpt_shiftk">[docs]</a>    <span class="k">def</span> <span class="nf">get_ngkpt_shiftk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return info on the k-point sampling from the input file,</span>
<span class="sd">        more specifically a tuple with nkgpt and shift.</span>
<span class="sd">        ngkpt is set to None if the BZ sampling cannot be described in terms of</span>
<span class="sd">        three divisions + one shift.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ngkpt and kptrlatt are mutually exclusive.</span>
        <span class="n">nshiftk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nshiftk&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;shiftk&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[:</span><span class="n">nshiftk</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;kptrlatt&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kptrlatt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kptrlatt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># Check whether is diagonal with one shift.</span>
            <span class="n">ngkpt</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">nshiftk</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_diagonal</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">):</span>
                <span class="n">ngkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ngkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span></div>

<div class="viewcode-block" id="AbinitInput.set_phdos_qmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_phdos_qmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_phdos_qmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">ph_qshift</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (ngkpt, shift, kptopt) for the computation of the Phonon DOS in Abinit.</span>
<span class="sd">        Remember that the Phdos is computed via Fourier interpolation so there&#39;s no constraint</span>
<span class="sd">        of the q-mesh.</span>

<span class="sd">        Args:</span>
<span class="sd">            nqsmall: Number of k-points used to sample the smallest lattice vector.</span>
<span class="sd">            method: &quot;gaussian&quot; or &quot;tetra&quot;.</span>
<span class="sd">            ph_qshift: Shift for the mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># q-mesh for Fourier interpolatation of IFC and a2F(w)</span>
        <span class="n">ph_ngqpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>
        <span class="n">ph_qshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ph_qshift</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># TODO: Test default values of wstep and smear</span>
        <span class="n">ph_intmeth</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;gaussian&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;tetra&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}[</span><span class="n">method</span><span class="p">]</span>
        <span class="n">ph_smear</span> <span class="o">=</span> <span class="s2">&quot;0.001 eV&quot;</span> <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ph_intmeth</span><span class="o">=</span><span class="n">ph_intmeth</span><span class="p">,</span>
            <span class="n">ph_smear</span><span class="o">=</span><span class="n">ph_smear</span><span class="p">,</span>
            <span class="n">ph_wstep</span><span class="o">=</span><span class="s2">&quot;0.0001 eV&quot;</span><span class="p">,</span>
            <span class="n">ph_ngqpt</span><span class="o">=</span><span class="n">ph_ngqpt</span><span class="p">,</span>
            <span class="n">ph_qshift</span><span class="o">=</span><span class="n">ph_qshift</span><span class="p">,</span>
            <span class="n">ph_nqshift</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ph_qshift</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">kptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the NSCF computation of the electronic band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: if &gt; 0, it&#39;s the number of divisions for the smallest segment of the path (Abinit variable).</span>
<span class="sd">                if &lt; 0, it&#39;s interpreted as the pymatgen `line_density` parameter in which the number of points</span>
<span class="sd">                in the segment is proportional to its length. Typical value: -20.</span>
<span class="sd">                This option is the recommended one if the k-path contains two consecutive high symmetry k-points</span>
<span class="sd">                that are very close as ndivsm &gt; 0 may produce a very large number of wavevectors.</span>
<span class="sd">            kptbounds: k-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#self.pop_vars([&quot;ngkpt&quot;, &quot;shiftk&quot;]) ??</span>

        <span class="k">if</span> <span class="n">ndivsm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">kptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
            <span class="n">kptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptbounds</span><span class="o">=</span><span class="n">kptbounds</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kptbounds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=</span><span class="n">iscf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kpts</span> <span class="o">=</span> <span class="n">kpoints_from_line_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">),</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=</span><span class="n">iscf</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_qpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_qpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the phonon band structure</span>
<span class="sd">        and phonon linewidths in the EPH part.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment in the q-path.</span>
<span class="sd">            qptbounds: q-points defining the path in q-space.</span>
<span class="sd">                If None, we use the default high-symmetry q-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">qptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ph_ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">ph_nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">),</span> <span class="n">ph_qpath</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kptgw"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kptgw">[docs]</a>    <span class="k">def</span> <span class="nf">set_kptgw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables (k-points, bands) and nkptgw for the computation of self-energy matrix elements.</span>

<span class="sd">        Args:</span>
<span class="sd">            kptgw: List of k-points in reduced coordinates.</span>
<span class="sd">            bdgw: Specifies the range of bands for the GW corrections.</span>
<span class="sd">                Accepts iterable that can be reshaped as (nkptgw, 2)</span>
<span class="sd">                or a tuple of two integers if the extrema are the same for each k-point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptgw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptgw</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">nkptgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bdgw</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="n">bdgw</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kptgw</span><span class="p">)</span> <span class="o">*</span> <span class="n">bdgw</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptgw</span><span class="o">=</span><span class="n">kptgw</span><span class="p">,</span> <span class="n">nkptgw</span><span class="o">=</span><span class="n">nkptgw</span><span class="p">,</span> <span class="n">bdgw</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bdgw</span><span class="p">,</span> <span class="p">(</span><span class="n">nkptgw</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span></div>

<div class="viewcode-block" id="AbinitInput.set_spin_mode"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spin_mode">[docs]</a>    <span class="k">def</span> <span class="nf">set_spin_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spin_mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables used to the treat the spin degree of freedom.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            spin_mode: :class:`SpinMode` object or string. Possible values for string are:</span>

<span class="sd">            - polarized</span>
<span class="sd">            - unpolarized</span>
<span class="sd">            - afm (anti-ferromagnetic)</span>
<span class="sd">            - spinor (non-collinear magnetism)</span>
<span class="sd">            - spinor_nomag (non-collinear, no magnetism)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove all variables used to treat spin</span>
        <span class="n">old_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;nsppol&quot;</span><span class="p">,</span> <span class="s2">&quot;nspden&quot;</span><span class="p">,</span> <span class="s2">&quot;nspinor&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_abiobjects</span><span class="p">(</span><span class="n">aobj</span><span class="o">.</span><span class="n">SpinMode</span><span class="o">.</span><span class="n">as_spinmode</span><span class="p">(</span><span class="n">spin_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">old_vars</span></div>

<div class="viewcode-block" id="AbinitInput.set_autospinat"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_autospinat">[docs]</a>    <span class="k">def</span> <span class="nf">set_autospinat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable spinat for collinear calculation in the format (0, 0, m) with the value of m determined</span>
<span class="sd">        with the following order of preference:</span>

<span class="sd">        1. If the site of the structure has a magmom setting, that is used.</span>
<span class="sd">        2. If the species on the site has a spin setting, that is used.</span>
<span class="sd">        3. If the species itself has a particular setting in the config file, that</span>
<span class="sd">           is used, e.g., Mn3+ may have a different magmom than Mn4+.</span>
<span class="sd">        4. The element symbol itself is checked in the config file.</span>
<span class="sd">        5. If there are no settings, the default value is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># These magnetic moments are from the Materials Project</span>
        <span class="c1"># (MPVaspInputSet.yaml, short_sha1 = a63bcdf)</span>

        <span class="n">magmom_mp_conf</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Co&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Co3+&quot;</span><span class="p">:</span> <span class="mf">0.6</span><span class="p">,</span>
            <span class="s2">&quot;Co4+&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s2">&quot;Cr&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Fe&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Mn3+&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
            <span class="s2">&quot;Mn4+&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
            <span class="s2">&quot;Mo&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ni&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;V&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Ce&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;Eu&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">spinat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;spin&#39;</span><span class="p">):</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span> <span class="ow">in</span> <span class="n">magmom_mp_conf</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">))))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">magmom_mp_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">default</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">spinat</span><span class="o">=</span><span class="n">spinat</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_spinat_from_symbols"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_spinat_from_symbols">[docs]</a>    <span class="k">def</span> <span class="nf">set_spinat_from_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symb2spinat</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set spinat parameters from a dictionary mapping chemical simbol to spinat value.</span>
<span class="sd">        If an element in the structure is not present in symb2luj, default is used.</span>

<span class="sd">        Example:</span>

<span class="sd">            symb2spinat = {&quot;Eu&quot;: [0, 0, 7]}</span>
<span class="sd">            inp.set_spinat_from_symbols(symb2spinat)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spinat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">symb2spinat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species_string</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="n">spinat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)))</span>

        <span class="c1"># Use &quot;*&quot; Abinit syntax to shorten a bit the string by grouping repeated magnetization</span>
        <span class="c1"># vectors e.g. 0 0 0 0 0 0 0 0 7 --&gt; 9*0 0 0 7</span>
        <span class="c1"># TODO: This piece of code can be encapsulate in a more genering function</span>
        <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">spinat</span><span class="p">,</span> <span class="p">(</span><span class="n">natom</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[[</span><span class="n">spinat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">natom</span><span class="p">):</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">spinat</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">vec</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">vec</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">vec</span> <span class="o">==</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">count</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="c1">#print(s)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">spinat</span><span class="o">=</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_usepawu"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_usepawu">[docs]</a>    <span class="k">def</span> <span class="nf">set_usepawu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usepawu</span><span class="p">,</span> <span class="n">symb2luj</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set DFT+U parameters for PAW calculations.</span>

<span class="sd">        Args:</span>
<span class="sd">            usepawu: Option specifying the DFT+U flavor (Abinit input variable).</span>
<span class="sd">            symb2luj: Dictionary mapping chemical symbol to the values of `lpawu`, `upawu` and `jpawu`.</span>
<span class="sd">                If an element in the structure is not present in symb2luj, the U+J term is automatically</span>
<span class="sd">                disabled for this element. In other words, only the element on which U+J should be applied</span>
<span class="sd">                must be speficied.</span>
<span class="sd">            units: Energy units for U and J. Note that defaultis eV although ABINIT uses Hartree by default!</span>

<span class="sd">        Example:</span>

<span class="sd">            symb2luj = {&quot;Eu&quot;: {&quot;lpawu&quot;: 3, &quot;upawu&quot;: 7, &quot;jpawu&quot;: 0.7}</span>
<span class="sd">            inp.set_luj(symb2luj)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lpawu</span><span class="p">,</span> <span class="n">upawu</span><span class="p">,</span> <span class="n">jpawu</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">species_by_znucl</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">symb2luj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lpawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">upawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">jpawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lpawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;lpawu&quot;</span><span class="p">])</span>
                <span class="n">upawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;upawu&quot;</span><span class="p">])</span>
                <span class="n">jpawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;jpawu&quot;</span><span class="p">])</span>

        <span class="c1"># Add units.</span>
        <span class="n">upawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="n">jpawu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">usepawu</span><span class="o">=</span><span class="n">usepawu</span><span class="p">,</span> <span class="n">lpawu</span><span class="o">=</span><span class="n">lpawu</span><span class="p">,</span> <span class="n">upawu</span><span class="o">=</span><span class="n">upawu</span><span class="p">,</span> <span class="n">jpawu</span><span class="o">=</span><span class="n">jpawu</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.set_kmesh_nband_and_occ"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.set_kmesh_nband_and_occ">[docs]</a>    <span class="k">def</span> <span class="nf">set_kmesh_nband_and_occ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">nsppol</span><span class="p">,</span> <span class="n">occ1k_spin</span><span class="p">,</span> <span class="n">nspinor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">occopt</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to set occupancies when occopt == 2</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Divisions of the k-mesh.</span>
<span class="sd">            shiftk: Shifts in reduced coordinates.</span>
<span class="sd">            nsppol: Spin polarization (Abinit input variable).</span>
<span class="sd">            occ1k_spin: List of `nppols` strings with the occupations for a single kpoint and</span>
<span class="sd">                the spin_up, spin_down channels if nsppol is 2.</span>
<span class="sd">            nspinor:</span>
<span class="sd">            kptopt:</span>
<span class="sd">            occopt:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nsppol_nspinor</span><span class="p">(</span><span class="n">nsppol</span><span class="p">,</span> <span class="n">nspinor</span><span class="p">)</span>

        <span class="c1"># Call Abinit to get the list of irreducible k-points.</span>
        <span class="c1">#from abipy.core.kpoints import IrredZone</span>
        <span class="c1">#ibz = IrredZone.from_ngkpt(self.structure, ngkpt, shiftk, kptopt=kptopt, spin_mode=spin_mode)</span>
        <span class="c1">#nkpt = len(ibz)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_kmesh</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nspinor</span><span class="o">=</span><span class="n">nspinor</span><span class="p">,</span> <span class="n">nsppol</span><span class="o">=</span><span class="n">nsppol</span><span class="p">,</span> <span class="n">occopt</span><span class="o">=</span><span class="n">occopt</span><span class="p">))</span>
        <span class="n">ibz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">()</span>
        <span class="n">nkpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibz</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

        <span class="n">occ1k_spin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">occ1k_spin</span><span class="p">,</span> <span class="p">(</span><span class="n">nsppol</span><span class="p">,))</span>
        <span class="c1">#print(&quot;occ1k_spin&quot;, occ1k_spin)</span>
        <span class="n">occ_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.abio.abivars</span> <span class="kn">import</span> <span class="n">expand_star_syntax</span>

        <span class="n">nband_spin</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsppol</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">occ1k_spin</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span>
            <span class="n">nband_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expand_star_syntax</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="c1">#print(&quot;nband_k&quot;, nband_k)</span>
            <span class="n">nband_spin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nband_k</span><span class="p">)</span>
            <span class="n">occ_str</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">nkpt</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1">#print(&quot;nkpt:&quot;, nkpt, &quot;\nnband_spin:&quot;, nband_spin, &quot;\nocc_str:&quot;, occ_str)</span>
        <span class="k">if</span> <span class="n">nsppol</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">nband_spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nband_spin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Different number of bands for the two spin channels: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nband_spin</span><span class="p">))</span>

        <span class="n">nband</span> <span class="o">=</span> <span class="s2">&quot;*</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nband_spin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nband</span><span class="o">=</span><span class="n">nband</span><span class="p">,</span> <span class="n">occ</span><span class="o">=</span><span class="n">occ_str</span><span class="p">))</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;nkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nkpt</span> <span class="c1"># Return nkpt as well as it may be useful for generating workflows.</span>

        <span class="k">return</span> <span class="n">d</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of |Pseudo| objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this is a PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this is a norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons computed from the pseudos and the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">num_valence_electrons</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of valence electrons for each atom in the structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">valence_electrons_per_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.linspace"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate `num` input files by changing the value of variable `varname` over the interval [`start`, `stop`].</span>
<span class="sd">        The endpoint of the interval can optionally be excluded.</span>

<span class="sd">        Example:</span>

<span class="sd">            input_list = gs_template.linspace(&quot;ecut&quot;, start=10, stop=60)</span>

<span class="sd">        Args:</span>
<span class="sd">            start: The starting value of the sequence.</span>
<span class="sd">            stop: The end value of the sequence, unless `endpoint` is set to False.</span>
<span class="sd">                In this case, the sequence consists of all but the last of ``ndtset + 1``</span>
<span class="sd">                evenly spaced samples, so that `stop` is excluded.  Note that the step</span>
<span class="sd">                size changes when `endpoint` is False.</span>
<span class="sd">            num (int): Number of samples to generate. Default is 50.</span>
<span class="sd">            endpoint (bool): optional. If True, `stop` is the last sample. Otherwise, it is not included.</span>
<span class="sd">                Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.arange"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.arange">[docs]</a>    <span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate list of input files by changing the value of variable `varname` over the interval [`start`, `stop`].</span>
<span class="sd">        Values are generated within the half-open interval ``[start, stop)``</span>
<span class="sd">        (in other words, the interval including `start` but excluding `stop`).</span>

<span class="sd">        When using a non-integer step, such as 0.1, the results will often not</span>
<span class="sd">        be consistent. It is better to use ``linspace`` for these cases.</span>

<span class="sd">        Example:</span>

<span class="sd">            input_list = gs_template.linspace(&quot;ecut&quot;, start=10, stop=60, step=10)</span>

<span class="sd">        Args:</span>
<span class="sd">            start:  Start of interval. The interval includes this value. The default start value is 0.</span>
<span class="sd">            stop: End of interval.  The interval does not include this value, except</span>
<span class="sd">                in some cases where `step` is not an integer and floating point</span>
<span class="sd">            step: Spacing between values.  For any output `out`, this is the distance</span>
<span class="sd">                between two adjacent values, ``out[i+1] - out[i]``.  The default</span>
<span class="sd">                step size is 1.  If `step` is specified, `start` must also be given.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.product"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.product">[docs]</a>    <span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">items</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cartesian product of input iterables. Equivalent to nested for-loops.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            inp.product(&quot;ngkpt&quot;, &quot;tsmear&quot;, [[2, 2, 2], [4, 4, 4]], [0.1, 0.2, 0.3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Split items into varnames and values</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_string</span><span class="p">(</span><span class="n">item</span><span class="p">):</span> <span class="k">break</span>

        <span class="n">varnames</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">items</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varnames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;The number of variables must equal the number of lists</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;varnames: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">values </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">varnames</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span>

        <span class="c1"># TODO: group varnames and varvalues!</span>
        <span class="c1">#varnames = [t[0] for t in items]</span>
        <span class="c1">#values = [t[1] for t in items]</span>

        <span class="n">varnames</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">varnames</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))]</span>
        <span class="n">varnames</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">varnames</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="n">inps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">names</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">varnames</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)})</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">enforce_znucl_and_typat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>
            <span class="n">inps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">inps</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_vars">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new input with the given variables.</span>

<span class="sd">        Example:</span>

<span class="sd">            new = input.new_with_vars(ecut=20, tsmear=0.04)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_structure"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_structure">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">,</span> <span class="n">scdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new |AbinitInput| with a different structure.</span>
<span class="sd">        See notes below for the constraints that must be fulfilled by the new structure</span>

<span class="sd">        Args:</span>
<span class="sd">            new_structure: Parameters defining the crystalline structure. Accepts |Structure| object</span>
<span class="sd">                file with structure (CIF, netcdf file, ...) or dictionary with ABINIT geo variables.</span>
<span class="sd">            scdims: 3 integer giving with the number of cells in the supercell along the three reduced directions.</span>
<span class="sd">                Must be used when `new_structure` represents a supercell of the initial structure defined</span>
<span class="sd">                in the input file.</span>
<span class="sd">            verbose: Verbosity level.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            If ``scdims`` is None (i.e. no supercell), the two structures must have the same value of</span>
<span class="sd">            `natom` and `typat`, they can only differ at the level of the lattice and of the atomic positions.</span>
<span class="sd">            When structure represents a supercell, `scdims` must be coherent with the `new_structure` passed</span>
<span class="sd">            as argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check structure</span>
        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assume same value of natom and typat</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structures must have same value of natom&quot;</span><span class="p">)</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">site1</span><span class="p">,</span> <span class="n">site2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">:</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">] </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">site1</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="n">site2</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structures must have same order of atomic types:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">scdims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scdims</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting 3 int in scdims but got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scdims</span><span class="p">))</span>

            <span class="n">numcells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">scdims</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numcells</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Number of atoms in the input structure should be </span><span class="si">%d</span><span class="s2"> * </span><span class="si">%d</span><span class="s2"> but found </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">numcells</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_structure</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

            <span class="n">expected_symbols</span> <span class="o">=</span> <span class="n">numcells</span> <span class="o">*</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">]</span>
            <span class="n">supcell_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">new_structure</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">expected_symbols</span><span class="p">,</span> <span class="n">supcell_symbols</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Wrong supercell. The routine assumes the atoms in the other cells have the</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;same ordering as the atoms in the original cell.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;expected_symbols: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">supercell_symbols: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expected_symbols</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">supcell_symbols</span><span class="p">))</span>
                       <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># TODO Check angles and lengths</span>

        <span class="c1"># Build new input</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">AbinitInput</span><span class="p">(</span><span class="n">new_structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abi_args</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
                          <span class="n">decorators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decorators</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scdims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is the tricky part because variables whose shape depends on natom</span>
            <span class="c1"># must be changed in order to be consistent with the supercell.</span>
            <span class="c1"># Here we use the database of abinit variables to find the variables whose shape depends on `natom`.</span>
            <span class="c1"># The method raises ValueError if an array that depends on `natom` is found and no handler is implemented.</span>
            <span class="c1"># It&#39;s better to raise an exception here than having a error when Abinit parses the input file!</span>

            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="c1">#if var.depends_on_dimension(&quot;ntypat&quot;):</span>
                <span class="c1">#    errors.append(&quot;Found variable %s with ntypat in dimensions %s&quot; % (name, str(var.dimensions)))</span>

                <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">depends_on_dimension</span><span class="p">(</span><span class="s2">&quot;natom&quot;</span><span class="p">):</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Found variable </span><span class="si">%s</span><span class="s2"> with natom in dimensions </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)))</span>
                    <span class="c1">#new[name] = _repeat_array(name, new[name], len(self.structure), numcells)</span>

            <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span> <span class="o">+</span>
                          <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The present version of new_with_structure is not able to handle this case.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

            <span class="c1"># Rescale nband and k-point sampling</span>
            <span class="n">iscale</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)))</span>
            <span class="k">if</span> <span class="s2">&quot;nband&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">iscale</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;self[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">],</span> <span class="s2">&quot;new[&#39;nband&#39;]&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;ngkpt&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">scdims</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;new ngkpt:&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">])</span>

            <span class="c1"># TODO</span>
            <span class="k">elif</span> <span class="s2">&quot;kptrlatt&quot;</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;kptrlatt in new_with_structure&quot;</span><span class="p">)</span>
                <span class="c1">#new[&quot;kptrlatt&quot;] = (np.rint(np.array(new[&quot;kptrlatt&quot;]) / iscale)).astype(int)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Single k-point</span>
                <span class="k">pass</span>

            <span class="c1"># Add chkprim if not yet done.</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars_ifnotin</span><span class="p">(</span><span class="n">chkprim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AbinitInput.new_with_decorators"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.new_with_decorators">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_decorators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decorators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function receives a list of :class:`AbinitInputDecorator` objects or just a single object,</span>
<span class="sd">        applies the decorators to the input and returns a new |AbinitInput| object. self is not changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decorators</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span> <span class="n">decorators</span> <span class="o">=</span> <span class="p">[</span><span class="n">decorators</span><span class="p">]</span>

        <span class="c1"># Deepcopy only at the first step to improve performance.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decorators</span><span class="p">):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="n">dec</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">deepcopy</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">inp</span></div>

<div class="viewcode-block" id="AbinitInput.pop_tolerances"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_tolerances">[docs]</a>    <span class="k">def</span> <span class="nf">pop_tolerances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the tolerance variables present in the input.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_TOLVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_irdvars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_irdvars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_irdvars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the `ird*` variables present in the input.</span>
<span class="sd">        Return dictionary with the variables that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="n">_IRDVARS</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1">#def pop_relax_vars(self):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Remove all the relax variables present in self.</span>
    <span class="c1">#    Return dictionary with the variables that have been removed.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    return self.pop_vars([&quot;ionmov&quot;, &quot;optcell&quot;, &quot;ntime&quot;, &quot;dilatmx&quot;])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scf_tolvar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tolerance variable and value relative to the SCF convergence.</span>
<span class="sd">        If more than one is present, an error is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tolvar</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_TOLVARS_SCF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tolvar</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;More than one tolerance set.&#39;</span><span class="p">)</span>
                <span class="n">tolvar</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">tolvar</span><span class="p">,</span> <span class="n">value</span>

<div class="viewcode-block" id="AbinitInput.make_ebands_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ebands_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_ebands_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">,</span> <span class="n">nscf_nband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nb_extra</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an input file for NSCF band structure calculation from a GS SCF input.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: if &gt; 0, it&#39;s the number of divisions for the smallest segment of the path (Abinit variable).</span>
<span class="sd">                if &lt; 0, it&#39;s interpreted as the pymatgen `line_density` parameter in which the number of points</span>
<span class="sd">                in the segment is proportional to its length. Typical value: -20.</span>
<span class="sd">                This option is the recommended one if the k-path contains two high symmetry k-points that are very close</span>
<span class="sd">                as ndivsm &gt; 0 may produce a very large number of wavevectors.</span>
<span class="sd">            tolwfr: Tolerance on residuals for NSCF calculation.</span>
<span class="sd">            nscf_nband: Number of bands for NSCF calculation. If None, use nband + nb_extra</span>
<span class="sd">            nb_extra: Extra bandd to to be added to input nband if nscf_nband is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nscf_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">nscf_input</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">,</span> <span class="s2">&quot;shiftk&quot;</span><span class="p">])</span>
        <span class="n">nscf_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>

        <span class="c1"># Define k-path.</span>
        <span class="k">if</span> <span class="n">ndivsm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nscf_ksampling</span> <span class="o">=</span> <span class="n">aobj</span><span class="o">.</span><span class="n">KSampling</span><span class="o">.</span><span class="n">path_from_structure</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
            <span class="n">nscf_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nscf_ksampling</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kpts</span> <span class="o">=</span> <span class="n">kpoints_from_line_density</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">))</span>
            <span class="n">nscf_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">),</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nscf_nband</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span>
            <span class="n">has_star</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">duck</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="c1"># Handle the case in which nband is specified with the `*91` syntax (occopt 2)</span>
                <span class="k">if</span> <span class="n">nb</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
                    <span class="n">has_star</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">nb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>

            <span class="n">nscf_nband</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">+</span> <span class="n">nb_extra</span>
            <span class="k">if</span> <span class="n">has_star</span><span class="p">:</span> <span class="n">nscf_nband</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;*</span><span class="si">{</span><span class="n">nscf_nband</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">nscf_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">nband</span><span class="o">=</span><span class="n">nscf_nband</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nscf_input</span></div>

<div class="viewcode-block" id="AbinitInput.make_edos_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_edos_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_edos_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tolwfr</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">,</span> <span class="n">nscf_nband</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate an input file for electron DOS calculation from a GS-SCF input.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh.</span>
<span class="sd">            shiftk: List of k-mesh shifts.</span>
<span class="sd">            tolwfr: Tolerance on residuals for NSCF calculation</span>
<span class="sd">            nscf_nband: Number of bands for NSCF calculation. +10 if None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dos_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">dos_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
        <span class="n">nscf_nband</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;nband&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">nscf_nband</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nscf_nband</span>
        <span class="n">dos_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">nband</span><span class="o">=</span><span class="n">nscf_nband</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">)</span>
        <span class="n">dos_input</span><span class="o">.</span><span class="n">set_kmesh</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dos_input</span></div>

<div class="viewcode-block" id="AbinitInput.make_nscf_kptopt0_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_nscf_kptopt0_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_nscf_kptopt0_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an input for NSCF calculation from a GS-SCF one.</span>
<span class="sd">        Uses explicit list of k-points and kptopt 0.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpts: List of k-points in reduced coordinates.</span>
<span class="sd">            tolwfr: Tolerance on residuals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nscf_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">nscf_input</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">,</span> <span class="s2">&quot;shiftk&quot;</span><span class="p">])</span>
        <span class="n">nscf_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
        <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">nscf_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">),</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nscf_input</span></div>

<div class="viewcode-block" id="AbinitInput.make_dfpt_effmass_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dfpt_effmass_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dfpt_effmass_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">effmass_bands_f90</span><span class="p">,</span> <span class="n">ngfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="mf">1e-20</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a |MultiDataset| object with 2 inputs for the calculation of effective masses with DFPT</span>
<span class="sd">        The first input in a standard NSCF run, the second input computes the effective masses.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpts: List of k-points in reduced coordinates where effective masses are wanted.</span>
<span class="sd">            efmas_bands_f90: (nkpt, 2) array with band range for effmas computation.</span>
<span class="sd">                WARNING: Assumes Fortran convention with indices starting from 1.</span>
<span class="sd">            ngfft: FFT divisions (3 integers). Used to enforce the same FFT mesh in the NSCF run as the one used for GS.</span>
<span class="sd">            tolwfr: Tolerance on residuals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">multi</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">,</span> <span class="s2">&quot;shiftk&quot;</span><span class="p">,</span> <span class="s2">&quot;iscf&quot;</span><span class="p">])</span>
        <span class="n">multi</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>

        <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpts</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">nkpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
        <span class="c1"># NSCF calculation (requires DEN)</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="n">nkpt</span><span class="p">,</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">,</span> <span class="n">prtwf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ngfft</span><span class="o">=</span><span class="n">ngfft</span><span class="p">)</span>

        <span class="c1"># Response function calculation: d/dk (requires DEN and GS WFK)</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">rfelfd</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>      <span class="c1"># Activate d/dk perturbation (required for effective mass calc.)</span>
            <span class="n">efmas</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>       <span class="c1"># Activate calculation of effective mass tensors</span>
            <span class="n">prtefmas</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>    <span class="c1"># Print netcdf file (should be default)</span>
            <span class="n">prtwf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">),</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">,</span>
            <span class="c1"># The range of bands for which the effective mass tensors will be computed, for each k-point.</span>
            <span class="n">efmas_bands</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">effmass_bands_f90</span><span class="p">,</span> <span class="p">(</span><span class="n">nkpt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
            <span class="c1"># And we request the scalar effective mass along directions in cartesian coordinates</span>
            <span class="n">efmas_calc_dirs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">efmas_n_dirs</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
            <span class="n">efmas_dirs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="n">ngfft</span><span class="o">=</span><span class="n">ngfft</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Input variables for Frohlich model calculation (need DDB, WFK and EFMAS file)</span>
        <span class="c1"># See https://docs.abinit.org/tests/v8/Input/t57.in</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">optdriver</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
            <span class="n">eph_frohlichm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">eph_task</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
            <span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nkpt</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">),</span> <span class="n">kpt</span><span class="o">=</span><span class="n">kpts</span><span class="p">,</span>
            <span class="n">ddb_ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">prtphdos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_ph_inputs_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ph_inputs_qpoint">[docs]</a>    <span class="k">def</span> <span class="nf">make_ph_inputs_qpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prtwf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepgkk</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds and returns a |MultiDataset| list of input files for the calculation of phonons</span>
<span class="sd">        at the given q-point `qpt`. This method should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: q-point in reduced coordinates.</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolvrs&quot;: 1.0e-10}.</span>
<span class="sd">            prtwf: 1WFs are only needed for restarting 2nd order DFPT or non-linear response.</span>
<span class="sd">                Since these files are huge, we use prtwf -1 so that the 1WF file is produced</span>
<span class="sd">                only if the calculation is not converged so that AbiPy can restart it.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        .. WARNING::</span>

<span class="sd">            The routine assumes the q-point is such that k + q belongs to the initial GS mesh</span>
<span class="sd">            so that the DFPT run can be started from the WFK file directly without having</span>
<span class="sd">            to generate intermediate WFQ files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">prepgkk</span><span class="o">=</span><span class="n">prepgkk</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="c1"># Remove iscf if any (required if we pass an input for NSCF calculation)</span>
        <span class="n">ph_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>
        <span class="n">ph_inputs</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">(</span><span class="s2">&quot;iscf&quot;</span><span class="p">)</span>

        <span class="c1"># Set kptopt depending on the q-points i.e use time-reversal if Gamma</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Note: this will work for phonons, but not for the other types of perturbations.</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">ph_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">ph_inputs</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                           <span class="c1"># Will consider phonon-type perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                             <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="n">pert</span><span class="o">.</span><span class="n">qpt</span><span class="p">,</span>                       <span class="c1"># q-wavevector.</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1">#if &quot;prtwf&quot; not in ph_input: ph_input[&quot;prtwf&quot;] = prtwf</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ph_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ph_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_ddk_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_ddk_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_ddk_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">only_vk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return inputs for performing DDK calculations.</span>
<span class="sd">        This functions should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolwfr&quot;: 1.0e-22}.</span>
<span class="sd">            kptopt: 2 to take into account time-reversal symmetry. Note that kptopt 1 is not available.</span>
<span class="sd">            only_vk: If only matrix elements of the velocity operator are needed.</span>
<span class="sd">                First-order wavefunctions won&#39;t be converged --&gt; not usable for other DFPT calculations.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            List of |AbinitInput| objects for DFPT runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="s2">&quot;tolvrs&quot;</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;tolvrs should not be used in a DDK calculation&quot;</span><span class="p">)</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1">#perts = self.abiget_irred_phperts(qpt=qpt)</span>
        <span class="c1"># TODO Add symmetries when implemented.</span>
        <span class="n">ddk_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">ddk_inputs</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in</span>
        <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">ddk_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ddk_rfdirs</span><span class="p">,</span> <span class="n">ddk_inputs</span><span class="p">):</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the d/dk perturbation</span>
                                      <span class="c1"># only the derivative of ground-state wavefunctions with respect to k</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>          <span class="c1"># Direction of the per ddk.</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>        <span class="c1"># 2 to take into account time-reversal symmetry.</span>
                <span class="n">iscf</span><span class="o">=-</span><span class="mi">3</span><span class="p">,</span>              <span class="c1"># The d/dk perturbation must be treated in a non-self-consistent way</span>
            <span class="p">)</span>

            <span class="n">ddk_input</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">ddk_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">only_vk</span><span class="p">:</span>
            <span class="n">ddk_inputs</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nstep</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nline</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ddk_inputs</span></div>

<div class="viewcode-block" id="AbinitInput.make_dde_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dde_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dde_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_symmetries</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |MultiDataset| inputs for the calculation of electric field perturbations.</span>
<span class="sd">        This functions should be called with an input the represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolvrs&quot;: 1.0e-22}.</span>
<span class="sd">            use_symmetries: boolean that computes the irreducible components of the perturbation.</span>
<span class="sd">                Default to True. Should be set to False for nonlinear coefficients calculation.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-22</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">use_symmetries</span><span class="p">:</span>
            <span class="c1"># Call Abinit to get the list of irred perts.</span>
            <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_ddeperts</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

            <span class="c1"># Build list of datasets (one input per irreducible perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
            <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the dde perturbation.</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute all the directions of the perturbation</span>
            <span class="n">dde_rfdirs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

            <span class="c1"># Build list of datasets (one input per perturbation)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">))</span>

            <span class="c1"># See tutorespfn/Input/tnlo_2.in dataset 4</span>
            <span class="k">for</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dde_rfdirs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>  <span class="c1"># Direction of the per ddk.</span>
                    <span class="n">prepanl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>    <span class="c1"># Prepare Non-linear RF calculations.</span>
                <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>       <span class="c1"># Activate the calculation of the electric field perturbation</span>
                            <span class="c1"># Assuming the data on derivative of ground-state wavefunction with respect</span>
                            <span class="c1"># to k (DDK) is available on disk and will be read with getddk/irddk</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>         <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
            <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>       <span class="c1"># Take into account time-reversal symmetry.</span>
        <span class="p">)</span>

        <span class="n">multi</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
        <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_dte_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_dte_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_dte_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_permutations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ixc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |MultiDataset| inputs for DTE calculation.</span>
<span class="sd">        This functions should be called with an input that represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            phonon_pert: is True also the phonon perturbations will be considered. Default False.</span>
<span class="sd">            skip_permutations: Since the current version of abinit always performs all the permutations</span>
<span class="sd">                of the perturbations, even if only one is asked, if True avoids the creation of inputs that</span>
<span class="sd">                will produce duplicated outputs.</span>
<span class="sd">            ixc: Value of ixc variable. Used to overwrite the default value read from pseudos.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_dteperts</span><span class="p">(</span><span class="n">phonon_pert</span><span class="o">=</span><span class="n">phonon_pert</span><span class="p">,</span> <span class="n">ixc</span><span class="o">=</span><span class="n">ixc</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">skip_permutations</span><span class="p">:</span>
            <span class="n">perts_to_skip</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">reduced_perts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pert</span> <span class="ow">in</span> <span class="n">perts</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1dir</span><span class="p">),</span> <span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2dir</span><span class="p">),</span> <span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3dir</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">perts_to_skip</span><span class="p">:</span>
                    <span class="n">reduced_perts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pert</span><span class="p">)</span>
                    <span class="n">perts_to_skip</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

            <span class="n">perts</span> <span class="o">=</span> <span class="n">reduced_perts</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ixc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multi</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ixc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ixc</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/tnlo_2.in</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir1</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i1dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir2</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir2</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i2dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rfdir3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir3</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">i3dir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># atpol if needed. Since there can be only one spatial perturbation</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span><span class="p">)</span>
            <span class="n">atpol</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span> <span class="o">==</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span> <span class="o">==</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span> <span class="o">==</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="n">rfdir1</span><span class="p">,</span>  <span class="c1"># Direction of the dte perturbation.</span>
                <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="n">rfdir2</span><span class="p">,</span>
                <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="n">rfdir3</span><span class="p">,</span>
                <span class="n">d3e_pert1_phon</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i1pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert2_phon</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i2pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert3_phon</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">i3pert</span> <span class="o">&lt;=</span> <span class="n">na</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="n">d3e_pert1_atpol</span><span class="o">=</span><span class="n">atpol</span><span class="p">,</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>         <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>  <span class="c1"># q-wavevector.</span>
                <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>    <span class="c1"># non-linear response functions, using the 2n+1 theorem.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>       <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_bec_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_bec_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_bec_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |MultiDataset| inputs for the calculation of Born effective charges.</span>
<span class="sd">        This functions should be called with an input that represents a GS run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-10</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>

        <span class="c1"># Call Abinit to get the list of irred perts.</span>
        <span class="c1"># TODO: Check that one can use the same list of irred perts as in phonons</span>
        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_phperts</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="c1"># See tutorespfn/Input/trf1_5.in dataset 3</span>
        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the electric field perturbation</span>
                <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Take into account time-reversal symmetry.</span>
            <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_strain_perts_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_strain_perts_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_strain_perts_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return |MultiDataset| inputs for strain perturbation calculation.</span>
<span class="sd">        This functions should be called with an input that represents a GS run.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: dict {varname: value} with the tolerance to be used in the DFPT run.</span>
<span class="sd">                Defaults to {&quot;tolvrs&quot;: 1.0e-12}.</span>
<span class="sd">            phonon_pert: isf True also the phonon perturbations are considered. Default False.</span>
<span class="sd">            kptopt: 2 to take into account time-reversal symmetry.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tolvrs&quot;</span><span class="p">:</span> <span class="mf">1.0e-12</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_TOLVARS</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Invalid tolerance: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)))</span>

        <span class="n">perts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abiget_irred_strainperts</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">phonon_pert</span><span class="o">=</span><span class="n">phonon_pert</span><span class="p">)</span>
        <span class="c1">#print(&quot;Stress perts:&quot;, perts)</span>

        <span class="c1"># Build list of datasets (one input per perturbation)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">replicate_input</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">perts</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pert</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">perts</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">rfdir</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">rfdir</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">idir</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">):</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the atomic dispacement perturbations</span>
                             <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">,</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span><span class="p">],</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>        <span class="c1"># No symmetries</span>
                             <span class="c1">#iscf=7,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>

            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (uniaxial)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>        <span class="c1"># No symmetries</span>
                             <span class="c1">#iscf=7,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>

            <span class="k">elif</span> <span class="n">pert</span><span class="o">.</span><span class="n">ipert</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>             <span class="c1"># Activate the calculation of the strain perturbations (shear)</span>
                             <span class="n">rfdir</span><span class="o">=</span><span class="n">rfdir</span><span class="p">,</span>
                             <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>               <span class="c1"># One wavevector is to be considered</span>
                             <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># q-wavevector.</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>        <span class="c1"># No symmetries</span>
                             <span class="c1">#iscf=7,</span>
                             <span class="n">paral_kgb</span><span class="o">=</span><span class="mi">0</span>
                             <span class="p">)</span>

            <span class="n">inp</span><span class="o">.</span><span class="n">pop_tolerances</span><span class="p">()</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_wfk_kerange_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_wfk_kerange_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">make_wfk_kerange_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_kerange</span><span class="p">,</span> <span class="n">sigma_ngkpt</span><span class="p">,</span> <span class="n">einterp</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a |MultiDataset| with two inputs for performing a WFK calculation with the kerange trick.</span>
<span class="sd">        This method should be called with the input associated to the NSCF run that produces</span>
<span class="sd">        the WFK file used for the interpolation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sigma_kerange: The energy window for the WFK generation.</span>
<span class="sd">            sigma_ngkpt: The fine grid of kpt inside the sigma_kerange interval.</span>
<span class="sd">            einterp: The interpolation used. By default it is a star-function interpolation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a MultiDataset from the nscf input</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="p">])</span>

        <span class="c1"># Activate the options needed to calculates the kpts within the sigma interval (Kerange.nc file)</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">wfk_task</span><span class="o">=</span><span class="s1">&#39;&quot;wfk_kpts_erange&quot;&#39;</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">sigma_ngkpt</span><span class="o">=</span><span class="n">sigma_ngkpt</span><span class="p">,</span> <span class="n">sigma_nshiftk</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sigma_shiftk</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="n">einterp</span><span class="o">=</span><span class="n">einterp</span><span class="p">,</span> <span class="n">sigma_erange</span><span class="o">=</span><span class="n">sigma_kerange</span><span class="p">,</span> <span class="n">prtwf</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;iscf&quot;</span><span class="p">,</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">,</span><span class="s2">&quot;prtden&quot;</span><span class="p">])</span>

        <span class="c1"># Modify the second nscf input to get a task that adds the kpt from Kerange.nc to the input file</span>
        <span class="c1"># used to compute the WFK file.</span>
        <span class="n">multi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">sigma_ngkpt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="AbinitInput.make_eph_transport_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.make_eph_transport_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_eph_transport_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddb_ngqpt</span><span class="p">,</span> <span class="n">sigma_erange</span><span class="p">,</span> <span class="n">tmesh</span><span class="p">,</span> <span class="n">eph_ngqpt_fine</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">mixprec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boxcutmin</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">ibte_prep</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ibte_niter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">ibte_abs_tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an |AbinitInput| to perform phonon-limited transport calculations.</span>
<span class="sd">        This method is usually called with the input associated to the NSCF run that produces</span>
<span class="sd">        the WFK file used to start the EPH run so that we can directly inherit the k-mesh</span>

<span class="sd">        Args:</span>
<span class="sd">            ddb_ngqpt: the coarse qpt grid used to compute the DDB and DVDB files in the phonon_work.</span>
<span class="sd">            eph_ngqpt_fine: the fine qpt grid used for the Fourier interpolation.</span>
<span class="sd">            sigma_erange: Energy window for k-states (see Abinit variable)</span>
<span class="sd">            tmesh: The mesh of temperatures (in Kelvin)</span>
<span class="sd">            boxcutmin: For the last task only, 1.1 is often used to decrease memory and is faster over the Abinit default of 2.</span>
<span class="sd">            mixprec: For the last task only, 1 is often used to make the EPH calculation faster. Note that Abinit default is 0.</span>
<span class="sd">            ibte_prep: Set it to 1 to activate the iterative Boltzmann equation. Default is RTA.</span>
<span class="sd">            ibte_niter: Number of iterations to solve the Boltzmann equation.</span>
<span class="sd">            ibte_abs_tol: Stopping criterion for the IBTE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eph_ngqpt_fine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">eph_ngqpt_fine</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">eph_ngqpt_fine</span>
        <span class="n">nbdbuf</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nbdbuf&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nbdbuf&quot;</span><span class="p">)</span>
        <span class="n">nband</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nband&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">nbdbuf</span> <span class="c1"># If nbdbuf is used in the NSCF computation,</span>
                                           <span class="c1"># it cannot be used in the EPH driver and should</span>
                                           <span class="c1"># be removed</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span>
            <span class="n">optdriver</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>                    <span class="c1"># Enter EPH driver.</span>
            <span class="n">eph_task</span><span class="o">=-</span><span class="mi">4</span><span class="p">,</span>                    <span class="c1"># Compute imag part of sigma_eph.</span>
            <span class="n">ddb_ngqpt</span><span class="o">=</span><span class="n">ddb_ngqpt</span><span class="p">,</span>            <span class="c1"># Ab-initio coarse q-mesh used to produce the DDB/DVDB files.</span>
            <span class="n">eph_ngqpt_fine</span><span class="o">=</span><span class="n">eph_ngqpt_fine</span><span class="p">,</span>  <span class="c1"># Interpolate DFPT potentials on this denser q-mesh.</span>
            <span class="n">sigma_erange</span><span class="o">=</span><span class="n">sigma_erange</span><span class="p">,</span>
            <span class="n">tmesh</span><span class="o">=</span><span class="n">tmesh</span><span class="p">,</span>
            <span class="n">mixprec</span><span class="o">=</span><span class="n">mixprec</span><span class="p">,</span>
            <span class="n">boxcutmin</span><span class="o">=</span><span class="n">boxcutmin</span><span class="p">,</span>
            <span class="n">ibte_prep</span><span class="o">=</span><span class="n">ibte_prep</span><span class="p">,</span>
            <span class="n">ibte_niter</span><span class="o">=</span><span class="n">ibte_niter</span><span class="p">,</span>
            <span class="n">ibte_abs_tol</span><span class="o">=</span><span class="n">ibte_abs_tol</span><span class="p">,</span>
            <span class="n">nband</span><span class="o">=</span><span class="n">nband</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">pop_vars</span><span class="p">([</span><span class="s2">&quot;iscf&quot;</span><span class="p">,</span><span class="s2">&quot;prtwf&quot;</span><span class="p">,</span><span class="s2">&quot;tolwfr&quot;</span><span class="p">,</span><span class="s2">&quot;prtden&quot;</span><span class="p">,</span><span class="s2">&quot;nbdbuf&quot;</span><span class="p">,</span><span class="s2">&quot;kptopt&quot;</span><span class="p">])</span>
        <span class="c1">#new.add_phbbands_vars()</span>
        <span class="k">return</span> <span class="n">new</span></div>

    <span class="c1">#def make_eph_zpr_input(self, ddb_ngqpt, tmesh, eph_ngqpt_fine=None,,</span>
    <span class="c1">#                       mixprec=1, boxcutmin=1.1):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Return an |AbinitInput| to perform phonon-limited transport calculations.</span>
    <span class="c1">#    This method is usually called with with the input associated to the NSCF run that produces</span>
    <span class="c1">#    the WFK file used to start the EPH run so that we can directly inherit the k-mesh</span>

    <span class="c1">#    Args:</span>
    <span class="c1">#        ddb_ngqpt: the coarse qpt grid used to compute the DDB and DVDB files in the phonon_work.</span>
    <span class="c1">#        eph_ngqpt_fine: the fine qpt grid used for the Fourier interpolation.</span>
    <span class="c1">#        sigma_erange: Energy window for k-states (see Abinit variable)</span>
    <span class="c1">#        tmesh: The mesh of temperatures (in Kelvin)</span>
    <span class="c1">#        boxcutmin: For the last task only, 1.1 is often used to decrease memory and is faster over the Abinit default of 2.</span>
    <span class="c1">#        mixprec: For the last task only, 1 is often used to make the EPH calculation faster. Note that Abinit default is 0.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    eph_ngqpt_fine = self.get(&quot;ngkpt&quot;) if eph_ngqpt_fine is None else eph_ngqpt_fine</span>
    <span class="c1">#    new = self.new_with_vars(</span>
    <span class="c1">#        optdriver=7,                    # Enter EPH driver.</span>
    <span class="c1">#        eph_task=+4,                    # Compute real and imag part of sigma_eph.</span>
    <span class="c1">#        ddb_ngqpt=ddb_ngqpt,            # Ab-initio coarse q-mesh used to produce the DDB/DVDB files.</span>
    <span class="c1">#        eph_ngqpt_fine=eph_ngqpt_fine,  # Interpolate DFPT potentials on this denser q-mesh.</span>
    <span class="c1">#        tmesh=tmesh,</span>
    <span class="c1">#        mixprec=mixprec,</span>
    <span class="c1">#        boxcutmin=boxcutmin,</span>
    <span class="c1">#    )</span>
    <span class="c1">#    #new.add_phbbands_vars()</span>
    <span class="c1">#    return ne</span>

    <span class="c1">#def make_eph_isotc_input(self, ddb_ngqpt, eph_fsewin, eph_ngqpt_fine=None,,</span>
    <span class="c1">#                          mixprec=1, boxcutmin=1.1):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Return an |AbinitInput| to perform phonon-limited transport calculations.</span>
    <span class="c1">#    This method is usually called with with the input associated to the NSCF run that produces</span>
    <span class="c1">#    the WFK file used to start the EPH run so that we can directly inherit the k-mesh</span>

    <span class="c1">#    Args:</span>
    <span class="c1">#        ddb_ngqpt: the coarse qpt grid used to compute the DDB and DVDB files in the phonon_work.</span>
    <span class="c1">#        eph_fsewin:</span>
    <span class="c1">#        eph_ngqpt_fine: the fine qpt grid used for the Fourier interpolation.</span>
    <span class="c1">#        boxcutmin: For the last task only, 1.1 is often used to decrease memory and is faster over the Abinit default of 2.</span>
    <span class="c1">#        mixprec: For the last task only, 1 is often used to make the EPH calculation faster. Note that Abinit default is 0.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    eph_ngqpt_fine = self.get(&quot;ngkpt&quot;) if eph_ngqpt_fine is None else eph_ngqpt_fine</span>
    <span class="c1">#    new = self.new_with_vars(</span>
    <span class="c1">#        optdriver=7,                    # Enter EPH driver.</span>
    <span class="c1">#        eph_task=-4,                    # Compute imag part of Phi phonon self-energy due to to electrons.</span>
    <span class="c1">#        ddb_ngqpt=ddb_ngqpt,            # Ab-initio coarse q-mesh used to produce the DDB/DVDB files.</span>
    <span class="c1">#        eph_ngqpt_fine=eph_ngqpt_fine,  # Interpolate DFPT potentials on this denser q-mesh.</span>
    <span class="c1">#        eph_fsewin=eph_fsewin,</span>
    <span class="c1">#        mixprec=mixprec,</span>
    <span class="c1">#        boxcutmin=boxcutmin,</span>
    <span class="c1">#    )</span>
    <span class="c1">#    #new.add_phbbands_vars()</span>
    <span class="c1">#    return new</span>

<div class="viewcode-block" id="AbinitInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run ABINIT in dry-run mode to validate the input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the temporary task. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file: log file of the Abinit run, use log_file.read() to access the content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access the content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;--dry-run&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="n">retcode</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_spacegroup"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_spacegroup">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_spacegroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolsym</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retdict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function invokes Abinit to get the space group (as detected by Abinit, not by spglib)</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolsym: Abinit tolsym input variable. None corresponds to the default value.</span>
<span class="sd">            retdict: True to return dictionary with space group information instead of Structure.</span>
<span class="sd">            workdir: Working directory of the temporary task used to compute the IBZ. None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            verbose: Verbosity level.</span>

<span class="sd">        Return:</span>
<span class="sd">            |Structure| object with AbinitSpaceGroup obtained from the main output file if retdict is False</span>
<span class="sd">            else dict with e.g.</span>
<span class="sd">            {&#39;bravais&#39;: &#39;Bravais cF (face-center cubic)&#39;, &#39;spg_number&#39;: 227, &#39;spg_symbol&#39;: &#39;Fd-3m&#39;}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tolsym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;tolsym&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tolsym</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Build a Task to run Abinit in --dry-run mode.</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;--dry-run&quot;</span><span class="p">])</span>

        <span class="c1"># Parse the output file and return structure extracted from run.abo</span>
        <span class="kn">from</span> <span class="nn">abipy.abio.outputs</span> <span class="kn">import</span> <span class="n">AbinitOutputFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">AbinitOutputFile</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">retdict</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">initial_structure</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dims_dataset</span><span class="p">,</span> <span class="n">spginfo_dataset</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">get_dims_spginfo_dataset</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">spginfo_dataset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_ibz"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_ibz">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function computes the list of points in the IBZ with the corresponding weights.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: List of shifts (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            verbose: verbosity level.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `namedtuple` with attributes:</span>
<span class="sd">                points: |numpy-array| with points in the IBZ in reduced coordinates.</span>
<span class="sd">                weights: |numpy-array| with weights of the points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="c1"># The magic value that makes ABINIT print the IB~ and then stop.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;prtkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing ibz with input:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Read the list of k-points from the netcdf file.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">NetcdfReader</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;kpts.nc&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">ibz</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;ibz&quot;</span><span class="p">,</span> <span class="s2">&quot;points weights&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ibz</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">),</span>
                           <span class="n">weights</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_weights&quot;</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_handle_task_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">prev_exc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when we have executed a temporary task but we encounter</span>
<span class="sd">        an exception when trying to extract data from the output results produced by Abinit</span>
<span class="sd">        It tries to extract information about the error and finally raises self.Error.</span>

<span class="sd">        .. example::</span>

<span class="sd">            try:</span>
<span class="sd">                do_something_with_the_output_files_produced_by_the_task</span>

<span class="sd">            except Exception as exc:</span>
<span class="sd">                self._handle_task_exception(task, exc)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if there are errors in the log file.</span>
        <span class="n">report</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="p">))</span>

        <span class="c1"># Weird condition. Possible explanations:</span>
        <span class="c1"># 1) Abinit cannot be executed or runtime errors due e.g to libraries not in LD_LIBRARY_PATH</span>
        <span class="c1"># 2) IO buffering (Abinit called MPI_ABORT but files are not flushed before aborting.</span>
        <span class="c1"># Try to return as much information as possible to faciliate debugging.</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Problem in temp Task executed in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>
                  <span class="s2">&quot;Previous exception </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">prev_exc</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Last 50 line from </span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>
            <span class="n">log_lines</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">50</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_lines</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">50</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">log_lines</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="n">emsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">debug</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">emsg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_abiget_irred_perts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            perts_vars: list of variables to be added to get the appropriate perturbation</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>
<span class="sd">            Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Avoid modifications in self.</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="n">qpt</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qpt&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">qpt</span>
        <span class="k">if</span> <span class="n">qpt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;qpt is not in the input and therefore it must be passed explicitly&quot;</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ngkpt</span>
        <span class="k">if</span> <span class="n">shiftk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shiftk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftk</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">nshiftk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;shiftk&#39;</span><span class="p">]))</span>

        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>       <span class="c1"># One wavevector is to be considered</span>
            <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span>      <span class="c1"># q-wavevector.</span>
            <span class="n">paral_rf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># Magic value to get the list of irreducible perturbations for this q-point.</span>
            <span class="o">**</span><span class="n">perts_vars</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;kptopt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kptopt</span>
        <span class="c1">#print(&quot;Computing irred_perts with input:\n&quot;, str(inp))</span>

        <span class="c1"># Build a Task to run Abinit in a shell subprocess</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Parse the file to get the perturbations.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">yaml_read_irred_perts</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Sometimes the previous call raises: Cannot find next YAML document in /tmp/tmpskvdr_bo/run.log</span>
            <span class="c1"># perhaps because the log file is still being written (?) so let&#39;s wait a bit.</span>
            <span class="c1"># On some machines, we found that the log file is truncated when MPI_ABORT is called and mpirun is used</span>
            <span class="c1"># even to run simple tasks with 1 procs.</span>
            <span class="c1"># In this case, one should try to use `shell_runner: &quot;&quot;` in manager.yaml to avoid using mpirun.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">yaml_read_irred_perts</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitInput.abiget_irred_phperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_phperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_phperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepgkk</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: qpoint of the phonon in reduced coordinates. Used to shift the k-mesh</span>
<span class="sd">                if qpt is not passed, self must already contain &quot;qpt&quot; otherwise an exception is raised.</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            prepgkk: 1 to activate computation of all 3*natom perts (debugging option).</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">                [{&#39;idir&#39;: 1, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]},</span>
<span class="sd">                 {&#39;idir&#39;: 2, &#39;ipert&#39;: 1, &#39;qpt&#39;: [0.25, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>                         <span class="c1"># Will consider phonon-type perturbation</span>
                            <span class="n">rfatpol</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)],</span> <span class="c1"># Set of atoms to displace.</span>
                            <span class="n">rfdir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>                  <span class="c1"># Along this set of reduced coordinate axis.</span>
                            <span class="n">prepgkk</span><span class="o">=</span><span class="n">prepgkk</span><span class="p">,</span>
                            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">phperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_ddeperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_ddeperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_ddeperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT computations.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddeperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfphon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># No phonon-type perturbation</span>
                             <span class="n">rfelfd</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>  <span class="c1"># Electric field</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">ddeperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_dteperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_dteperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_dteperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ixc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            phonon_pert: if True also the phonon perturbations will be considered. Default False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dteperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d3e_pert1_phon</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">phonon_pert</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># phonon-type perturbation</span>
                             <span class="n">d3e_pert2_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert3_phon</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">d3e_pert1_atpol</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)]</span> <span class="k">if</span> <span class="n">phonon_pert</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">d3e_pert1_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>           <span class="c1"># Electric field perturbation</span>
                             <span class="n">d3e_pert2_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert3_elfd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">d3e_pert1_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert2_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">d3e_pert3_dir</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                             <span class="n">optdriver</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>                <span class="c1"># non-linear response functions , using the 2n+1 theorem</span>
                             <span class="n">kptopt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>                   <span class="c1"># kpt time reversal symmetry</span>
                             <span class="p">)</span>

        <span class="k">if</span> <span class="n">ixc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">dteperts_vars</span><span class="p">[</span><span class="s2">&quot;ixc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ixc</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">dteperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_irred_strainperts"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_irred_strainperts">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_irred_strainperts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">phonon_pert</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function, computes the list of irreducible perturbations for strain perturbations in DFPT.</span>
<span class="sd">        It should be called with an input file that contains all the mandatory variables required by ABINIT.</span>

<span class="sd">        Args:</span>
<span class="sd">            ngkpt: Number of divisions for the k-mesh (default None i.e. use ngkpt from self)</span>
<span class="sd">            shiftk: Shiftks (default None i.e. use shiftk from self)</span>
<span class="sd">            kptopt: Option for k-point generation. If None, the value in self is used.</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            phonon_pert: if True the phonon perturbation at gamma will be included.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of dictionaries with the Abinit variables defining the irreducible perturbation</span>

<span class="sd">        Example:</span>

<span class="sd">            [{&#39;idir&#39;: 1, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]},</span>
<span class="sd">             {&#39;idir&#39;: 2, &#39;ipert&#39;: 4, &#39;qpt&#39;: [0.0, 0.0, 0.0]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strainperts_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rfstrs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>                        <span class="c1"># Do the strain perturbations</span>
                                <span class="n">rfdir</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>                   <span class="c1"># All directions</span>
                                <span class="c1"># nqpt=1,                        # One wavevector is to be considered</span>
                                <span class="c1"># qpt=(0, 0, 0),                 # q-wavevector.</span>
                                <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>                   <span class="c1"># Take into account time-reversal symmetry.</span>
                                <span class="n">iscf</span><span class="o">=</span><span class="mi">7</span>                           <span class="c1"># Just so that it works with PAW ... #TODO: check this</span>
                             <span class="p">)</span>

        <span class="k">if</span> <span class="n">phonon_pert</span><span class="p">:</span>
            <span class="n">strainperts_vars</span><span class="p">[</span><span class="s1">&#39;rfphon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                        <span class="c1"># No phonon-type perturbation</span>
            <span class="n">strainperts_vars</span><span class="p">[</span><span class="s1">&#39;rfatpol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">))</span> <span class="c1"># Perturbation of all atoms</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abiget_irred_perts</span><span class="p">(</span><span class="n">strainperts_vars</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span>
                                        <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span>
                                        <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.pop_par_vars"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.pop_par_vars">[docs]</a>    <span class="k">def</span> <span class="nf">pop_par_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the variables associated to parallelism from the input file.</span>
<span class="sd">        Useful in case of a restart when we need to remove the parallel variables before rerunning autoparal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parvars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;npkpt&#39;</span><span class="p">,</span> <span class="s1">&#39;npfft&#39;</span><span class="p">,</span> <span class="s1">&#39;npband&#39;</span><span class="p">,</span> <span class="s1">&#39;npspinor&#39;</span><span class="p">,</span> <span class="s1">&#39;npimage&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">:</span>
            <span class="n">parvars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;gwpara&#39;</span><span class="p">)</span>
        <span class="n">popped</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">parvars</span><span class="p">:</span>
            <span class="n">popped</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">popped</span></div>

<div class="viewcode-block" id="AbinitInput.abiget_autoparal_pconfs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.abiget_autoparal_pconfs">[docs]</a>    <span class="k">def</span> <span class="nf">abiget_autoparal_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">,</span> <span class="n">autoparal</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the possible configurations up to ``max_ncpus``.</span>
<span class="sd">        Return list of parallel configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>

        <span class="c1"># Bypass Abinit check as we always want to return results.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;chksymbreak&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Disable memory check.</span>
        <span class="n">inp</span><span class="p">[</span><span class="s2">&quot;mem_test&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c1"># Return code is always != 0</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running in:&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1">##############################################################</span>
        <span class="c1"># Parse the autoparal configurations from the main output file</span>
        <span class="c1">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pconfs</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle_task_exception</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitInput.run_in_shell"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AbinitInput.run_in_shell">[docs]</a>    <span class="k">def</span> <span class="nf">run_in_shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to quickly execute abinit in a shell.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>
<span class="sd">            verbose: verbosity level.</span>

<span class="sd">        Returns:</span>
<span class="sd">            an |AbinitTask| of the executed calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AbinitTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running in:&quot;</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span></div></div>


<div class="viewcode-block" id="MultiDataset"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset">[docs]</a><span class="k">class</span> <span class="nc">MultiDataset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is essentially a list of |AbinitInput| objects.</span>
<span class="sd">    It provides an easy-to-use interface to apply global changes to the</span>
<span class="sd">    the inputs stored in the objects.</span>

<span class="sd">    Let&#39;s assume for example that multi contains two ``AbinitInput`` objects and we</span>
<span class="sd">    want to set `ecut` to 1 in both dictionaries. The direct approach would be:</span>

<span class="sd">        for inp in multi:</span>
<span class="sd">            inp.set_vars(ecut=1)</span>

<span class="sd">    or alternatively:</span>

<span class="sd">        for i in range(multi.ndtset):</span>
<span class="sd">            multi[i].set_vars(ecut=1)</span>

<span class="sd">    MultiDataset provides its own implementaion of __getattr__ so that one can simply use:</span>

<span class="sd">        multi.set_vars(ecut=1)</span>

<span class="sd">        multi.get(&quot;ecut&quot;) returns a list of values. It is equivalent to:</span>

<span class="sd">            [inp[&quot;ecut&quot;] for inp in multi]</span>

<span class="sd">        Note that if &quot;ecut&quot; is not present in one of the input of multi, the corresponding entry is set to None.</span>
<span class="sd">        A default value can be specified with:</span>

<span class="sd">            multi.get(&quot;paral_kgb&quot;, 0)</span>

<span class="sd">    .. warning::</span>

<span class="sd">        MultiDataset does not support calculations done with different sets of pseudopotentials.</span>
<span class="sd">        The inputs can have different crystalline structures (as long as the atom types are equal)</span>
<span class="sd">        but each input in MultiDataset must have the same set of pseudopotentials.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">AbinitInputError</span>

<div class="viewcode-block" id="MultiDataset.from_inputs"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.from_inputs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_inputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build object from a list of |AbinitInput| objects.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>

        <span class="c1"># Build MultiDataset from input structures and pseudos and add inputs.</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="p">[</span><span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">],</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>

        <span class="c1"># Add variables, decorators, tags and propagate enforce_znucl and enforce_typat (if any).</span>
        <span class="k">for</span> <span class="n">inp</span><span class="p">,</span> <span class="n">new_inp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">multi</span><span class="p">):</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">inp</span><span class="p">)</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">decorators</span>
            <span class="n">new_inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">:</span>
                <span class="n">new_inp</span><span class="o">.</span><span class="n">enforce_znucl_and_typat</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

<div class="viewcode-block" id="MultiDataset.replicate_input"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.replicate_input">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">replicate_input</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">ndtset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a multidataset with ndtset from the |AbinitInput| input.&quot;&quot;&quot;</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="n">ndtset</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">tags</span><span class="p">)</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">enforce_znucl_and_typat</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="nb">input</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">multi</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">,</span> <span class="n">pseudo_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">ndtset</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: file with the structure, |Structure| object or dictionary with ABINIT geo variable</span>
<span class="sd">                Accepts also list of objects that can be converted to Structure object.</span>
<span class="sd">                In this case, however, ndtset must be equal to the length of the list.</span>
<span class="sd">            pseudos: String or list of string with the name of the pseudopotential files.</span>
<span class="sd">            pseudo_dir: Name of the directory where the pseudopotential files are located.</span>
<span class="sd">            ndtset: Number of datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Setup of the pseudopotential files.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pseudos</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">PseudoTable</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">pseudos</span>

        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Pseudo</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudos</span><span class="p">):</span>
            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># String(s)</span>
            <span class="n">pseudo_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">)</span>
            <span class="n">pseudo_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pseudo_dir</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">pseudos</span><span class="p">)]</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pseudo_paths</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find the following pseudopotential files:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">missing</span><span class="p">))</span>

            <span class="n">pseudos</span> <span class="o">=</span> <span class="n">PseudoTable</span><span class="p">(</span><span class="n">pseudo_paths</span><span class="p">)</span>

        <span class="c1"># Build the list of AbinitInput objects.</span>
        <span class="k">if</span> <span class="n">ndtset</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2"> cannot be &lt;=0&quot;</span> <span class="o">%</span> <span class="n">ndtset</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndtset</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndtset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AbinitInput</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">pseudos</span><span class="o">=</span><span class="n">pseudos</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">]</span>

        <span class="c1"># Check pseudos</span>
        <span class="c1">#for i in range(self.ndtset):</span>
        <span class="c1">#    if any(p1 != p2 for p1, p2 in zip(self[0].pseudos, self[i].pseudos)):</span>
        <span class="c1">#        raise selfError(&quot;Pseudos must be consistent when from_inputs is invoked.&quot;)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndtset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of inputs in MultiDataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pseudopotential objects.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of inputs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">_inputs</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_inputs&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot find attribute </span><span class="si">%s</span><span class="s2">. Tried in </span><span class="si">%s</span><span class="s2"> and then in AbinitInput object&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
        <span class="n">isattr</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">on_all</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="c1">#print(&quot;name&quot;, name, &quot;, type:&quot;, type(a), &quot;callable: &quot;,callable(a))</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">results</span>

        <span class="k">if</span> <span class="n">isattr</span><span class="p">:</span> <span class="n">on_all</span> <span class="o">=</span> <span class="n">on_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">on_all</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;self + other&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Operation not supported&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">([</span><span class="n">other</span><span class="p">])</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDataset</span><span class="p">):</span>
            <span class="n">new_mds</span> <span class="o">=</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_mds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Operation not supported&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MultiDataset.append"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a |AbinitInput| to the list.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">abinit_input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.extend"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abinit_inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extends self with a list of |AbinitInput| objects.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">AbinitInput</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">abinit_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="n">p2</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pseudos</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pseudos must be consistent when from_inputs is invoked.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">abinit_inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.addnew_from"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.addnew_from">[docs]</a>    <span class="k">def</span> <span class="nf">addnew_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtindex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new entry in the multidataset by copying the input with index ``dtindex``.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">dtindex</span><span class="p">]</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">())</span></div>

<div class="viewcode-block" id="MultiDataset.split_datasets"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.split_datasets">[docs]</a>    <span class="k">def</span> <span class="nf">split_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return list of |AbinitInput| objects..&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span></div>

<div class="viewcode-block" id="MultiDataset.deepcopy"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the MultiDataset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_same_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if all inputs in the MultiDataset are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="n">inp</span><span class="o">.</span><span class="n">structure</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="MultiDataset.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation i.e. the ABINIT input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            mode: Either ``text`` or ``html`` if HTML output with links is wanted.</span>
<span class="sd">            with_pseudos: False if JSON section with pseudo data should not be added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_abinit_variables</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Multi dataset mode.</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ndtset </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">has_same_variable</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="n">vref</span><span class="p">,</span> <span class="n">other_inp</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;True if variable kref is present in other_inp with the same value.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">kref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other_inp</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
                <span class="n">otherv</span> <span class="o">=</span> <span class="n">other_inp</span><span class="p">[</span><span class="n">kref</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">vref</span><span class="p">,</span> <span class="n">otherv</span><span class="p">)</span>

            <span class="c1"># Don&#39;t repeat variable that are common to the different datasets.</span>
            <span class="c1"># Put them in the `Global Variables` section and exclude these variables in inp.to_string</span>
            <span class="n">global_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k0</span><span class="p">,</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">isame</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span><span class="p">):</span>
                    <span class="n">isame</span> <span class="o">=</span> <span class="n">has_same_variable</span><span class="p">(</span><span class="n">k0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">isame</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">isame</span><span class="p">:</span>
                    <span class="n">global_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k0</span><span class="p">)</span>
            <span class="c1">#print(&quot;global_vars vars&quot;, global_vars)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="mi">92</span>
            <span class="k">if</span> <span class="n">global_vars</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#### Global Variables.&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">global_vars</span><span class="p">:</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="n">var_database</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">])))</span>

            <span class="n">has_same_structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_same_structures</span>
            <span class="k">if</span> <span class="n">has_same_structures</span><span class="p">:</span>
                <span class="c1"># Write structure here and disable structure output in input.to_string</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;####&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;STRUCTURE&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span><span class="p">)</span>
                <span class="n">kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">enforce_znucl</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enforce_znucl</span><span class="p">,</span> <span class="n">enforce_typat</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">enforce_typat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">to_abivars</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">vname</span> <span class="o">=</span> <span class="n">key</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="n">var_database</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;##### DATASET </span><span class="si">%d</span><span class="s2"> #####&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">is_last</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndtset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="n">is_last</span> <span class="ow">and</span> <span class="n">with_pseudos</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                                  <span class="n">with_structure</span><span class="o">=</span><span class="ow">not</span> <span class="n">has_same_structures</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">global_vars</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">*</span> <span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># single datasets ==&gt; don&#39;t append the dataset index to the variables.</span>
            <span class="c1"># this trick is needed because Abinit complains if ndtset is not specified</span>
            <span class="c1"># and we have variables that end with the dataset index e.g. acell1</span>
            <span class="c1"># We don&#39;t want to specify ndtset here since abinit will start to add DS# to</span>
            <span class="c1"># the input and output files thus complicating the algorithms we have to use to locate the files.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">with_pseudos</span><span class="o">=</span><span class="n">with_pseudos</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter_ notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MultiDataset.get_vars_dataframe"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.get_vars_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">get_vars_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">varnames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return pandas DataFrame with the value of the variables specified in `varnames`.</span>

<span class="sd">        .. example:</span>

<span class="sd">            df = multi.get_vars_dataframe(&quot;ecut&quot;, &quot;ngkpt&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([{</span><span class="n">v</span><span class="p">:</span> <span class="n">inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">}],</span>
                              <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dataset </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">varnames</span><span class="p">)</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.filter_by_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_tags">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_tags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the input according to the tags</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            exclude_tags: A single tag or list/tuple/set of tags that should be excluded</span>

<span class="sd">        Returns:</span>
<span class="sd">            A |MultiDataset| containing the inputs containing all the requested tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_tags</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">and</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_tags</span> <span class="o">=</span> <span class="p">{</span><span class="n">exclude_tags</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">tags</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">exclude_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_tags</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tags</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.add_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.add_tags">[docs]</a>    <span class="k">def</span> <span class="nf">add_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add tags to the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices to which the tags will be added. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.remove_tags"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.remove_tags">[docs]</a>    <span class="k">def</span> <span class="nf">remove_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dtindeces</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove tags from the selected inputs</span>

<span class="sd">        Args:</span>
<span class="sd">            tags: A single tag or list/tuple/set of tags</span>
<span class="sd">            dtindeces: a list of indices from which the tags will be removed. None=all the inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dtindeces</span> <span class="k">if</span> <span class="n">dtindeces</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">remove_tags</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiDataset.filter_by_runlevel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.filter_by_runlevel">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_runlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">runlevel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new |MultiDataset| object in which only the inputs with the given runlevel are selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">runlevel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">runlevel</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">runlevel</span> <span class="o">=</span> <span class="p">{</span><span class="n">runlevel</span><span class="p">}</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">runlevel</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">runlevel</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">MultiDataset</span><span class="o">.</span><span class="n">from_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="n">inputs</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MultiDataset.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.MultiDataset.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="o">=</span><span class="s2">&quot;run.abi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write ``ndset`` input files to disk. The name of the file is constructed from the dataset index e.g. runDS0.abi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;DS</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="o">+</span> <span class="n">ext</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AnaddbInputError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInputError">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for exceptions raised by `AnaddbInput`&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="AnaddbInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput">[docs]</a><span class="k">class</span> <span class="nc">AnaddbInput</span><span class="p">(</span><span class="n">AbiAbstractInput</span><span class="p">,</span> <span class="n">Has_Structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the anaddb variables.</span>


<span class="sd">    .. rubric:: Inheritance Diagram</span>
<span class="sd">    .. inheritance-diagram:: AnaddbInput</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">AnaddbInputError</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">            spell_check: False to disable spell checking for input variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_spell_check</span><span class="p">(</span><span class="n">spell_check</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>

        <span class="n">anaddb_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">anaddb_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_args</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">anaddb_args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">anaddb_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">anaddb_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_kwargs</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">anaddb_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_varname</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">anaddb_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">anaddb_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

<div class="viewcode-block" id="AnaddbInput.set_spell_check"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_spell_check">[docs]</a>    <span class="k">def</span> <span class="nf">set_spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">false_or_true</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Activate/Deactivate spell-checking&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">false_or_true</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spell_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if spell checking is activated.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spell_check</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1"># This is to maintain compatibility with pickle</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spell_check</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_anaddb_var</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Cannot find variable `</span><span class="si">%s</span><span class="s2">` in the internal database. If you think this is not a typo, use:</span>

<span class="s2">    input.set_spell_check(False)</span>

<span class="s2">to disable spell checking. Perhaps the internal database is not in synch</span>
<span class="s2">with the Abinit version you are using. Please contact the AbiPy developers.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

<div class="viewcode-block" id="AnaddbInput.modes_at_qpoint"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes_at_qpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">modes_at_qpoint</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">qpoint</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ifcflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the calculation of the phonon frequencies at a given q-point.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            qpoint: Reduced coordinates of the q-point where phonon frequencies and modes are wanted</span>
<span class="sd">            asr, chneut, dipdp, ifcflag: Anaddb input variable. See official documentation.</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included if qpoint==Gamma</span>
<span class="sd">            directions: list of 3D directions along which the LO-TO splitting will be calculated. If None the three</span>
<span class="sd">                cartesian direction will be used</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">            spell_check: False to disable spell checking for input variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need a numpy array.</span>
        <span class="n">qpoint</span> <span class="o">=</span> <span class="n">qpoint</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qpoint</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong q-point </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qpoint</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">modes_at_qpoints</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span> <span class="n">qpoints</span><span class="o">=</span><span class="p">[</span><span class="n">qpoint</span><span class="p">],</span> <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
                                    <span class="n">ifcflag</span><span class="o">=</span><span class="n">ifcflag</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="n">lo_to_splitting</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="n">directions</span><span class="p">,</span>
                                    <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="n">spell_check</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnaddbInput.modes_at_qpoints"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes_at_qpoints">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">modes_at_qpoints</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ifcflag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngqpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">spell_check</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the calculation of the phonon frequencies at a given q-point.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            qpoints: List of reduced coordinates of the q-point where phonon frequencies and modes are wanted</span>
<span class="sd">            asr, chneut, dipdp, ifcflag: Anaddb input variable. See official documentation.</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included if qpoint==Gamma</span>
<span class="sd">            directions: list of 3D directions along which the LO-TO splitting will be calculated. If None the three</span>
<span class="sd">                cartesian direction will be used</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh. Required if ifcflag=1.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">            spell_check: False to disable spell checking for input variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ifcflag</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ngqpt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If ifcflag is activated ngqpt should be defined.&quot;</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADDB input for phonon frequencies for a list of q-points generated by AbiPy.&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="n">spell_check</span><span class="p">)</span>

        <span class="c1"># We need a numpy array.</span>
        <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qpoint</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">qpoint</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">qpoint</span> <span class="k">for</span> <span class="n">qpoint</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">])</span>
        <span class="n">n_qpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qpoints</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="n">ifcflag</span><span class="p">,</span>        <span class="c1"># Interatomic force constant flag</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>                <span class="c1"># Acoustic Sum Rule</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>          <span class="c1"># Charge neutrality requirement for effective charges.</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>          <span class="c1"># Dipole-dipole interaction treatment</span>
            <span class="c1"># This part is fixed</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="n">n_qpoints</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qpoints</span><span class="p">,</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n_qpoints</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ngqpt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">ngqpt</span><span class="o">=</span><span class="n">ngqpt</span><span class="p">,</span>
                <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
                <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="c1"># append 0 to specify that these are directions,</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">directions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">))]</span>
            <span class="c1"># add variables.</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.piezo_elastic"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.piezo_elastic">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">piezo_elastic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">relaxed_ion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stress_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the calculation of piezoelectric and elastic tensor calculations.</span>

<span class="sd">        Args:</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="s2">&quot;ANADDB input for piezoelectric and elastic tensor calculation&quot;</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">dfpt</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">relaxed_ion</span><span class="o">=</span><span class="n">relaxed_ion</span><span class="p">,</span> <span class="n">piezo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dde</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strain</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dte</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">stress_correction</span><span class="o">=</span><span class="n">stress_correction</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
                       <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.phbands_and_dos"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.phbands_and_dos">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">phbands_and_dos</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">,</span> <span class="n">qppa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                        <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dos_method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span> <span class="n">lo_to_splitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">with_ifc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the computation of phonon bands and phonon DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            qppa: Defines the homogeneous q-mesh used for the DOS in units of q-points per reciproval atom.</span>
<span class="sd">                Overrides nqsmall.</span>
<span class="sd">            line_density: Defines the a density of k-points per reciprocal atom to plot the phonon dispersion.</span>
<span class="sd">                Overrides ndivsm.</span>
<span class="sd">            ndivsm: Used to generate a normalized path for the phonon bands.</span>
<span class="sd">                If gives the number of divisions for the smallest segment of the path.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            dos_method: Possible choices: &quot;tetra&quot;, &quot;gaussian&quot; or &quot;gaussian:0.001 eV&quot;.</span>
<span class="sd">                In the later case, the value 0.001 eV is used as gaussian broadening</span>
<span class="sd">            lo_to_splitting: if True calculation of the LO-TO splitting will be included</span>
<span class="sd">            with_ifc: if True calculation of the interatomic force constants will be included.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">            spell_check: False to disable spell checking for input variables.</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dossmear</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">dos_method</span> <span class="o">==</span> <span class="s2">&quot;tetra&quot;</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="s2">&quot;gaussian&quot;</span> <span class="ow">in</span> <span class="n">dos_method</span><span class="p">:</span>
            <span class="n">prtdos</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dos_method</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">eunit</span> <span class="o">=</span> <span class="n">dos_method</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">dossmear</span> <span class="o">=</span> <span class="n">Energy</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">eunit</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Ha&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Wrong value for dos_method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">dos_method</span><span class="p">))</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADDB input for phonon bands and DOS generated by AbiPy&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">comment</span> <span class="k">else</span> <span class="n">comment</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">,</span> <span class="n">spell_check</span><span class="o">=</span><span class="n">spell_check</span><span class="p">)</span>

        <span class="c1"># Parameters for the DOS</span>
        <span class="k">if</span> <span class="n">qppa</span><span class="p">:</span>
            <span class="n">ng2qpt</span> <span class="o">=</span> <span class="n">aobj</span><span class="o">.</span><span class="n">KSampling</span><span class="o">.</span><span class="n">automatic_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">kppa</span><span class="o">=</span><span class="n">qppa</span><span class="p">)</span><span class="o">.</span><span class="n">kpts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Set new variables</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ng2qpt</span><span class="o">=</span><span class="n">ng2qpt</span><span class="p">,</span> <span class="n">prtdos</span><span class="o">=</span><span class="n">prtdos</span><span class="p">,</span> <span class="n">dossmear</span><span class="o">=</span><span class="n">dossmear</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_autoqmesh</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">prtdos</span><span class="o">=</span><span class="n">prtdos</span><span class="p">,</span> <span class="n">dossmear</span><span class="o">=</span><span class="n">dossmear</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nqsmall</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new</span><span class="p">[</span><span class="s2">&quot;prtdos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Parameters for the Bandstructure.</span>
        <span class="k">if</span> <span class="n">line_density</span><span class="p">:</span>
            <span class="n">qph1l</span> <span class="o">=</span> <span class="n">kpoints_from_line_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">line_density</span><span class="p">)</span>
            <span class="c1"># Set new variables</span>
            <span class="n">new</span><span class="p">[</span><span class="s1">&#39;qph1l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qph1l</span><span class="p">]</span>
            <span class="n">new</span><span class="p">[</span><span class="s1">&#39;nph1l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qph1l</span><span class="p">)</span>
            <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_qpath</span><span class="p">(</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span>
            <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="s1">&#39;qpath&#39;</span><span class="p">]</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">lo_to_splitting</span><span class="p">:</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">rl</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
                    <span class="c1"># anaddb expects cartesian coordinates for the qph2l list</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rl</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rl</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                        <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">directions</span><span class="p">:</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                    <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">with_ifc</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                <span class="n">ifcout</span><span class="o">=</span><span class="mi">10000000</span><span class="p">,</span>
                <span class="n">natifc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span>
                <span class="n">atifc</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">ifcana</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">prt_ifc</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.modes"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.modes">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">modes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">enunit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the computation of phonon modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            Structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADDB input for modes generated by AbiPy&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">enunit</span><span class="o">=</span><span class="n">enunit</span><span class="p">,</span>
            <span class="n">eivec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">dieflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">nph1l</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">qph1l</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
            <span class="n">nph2l</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">qph2l</span><span class="o">=</span><span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.ifc"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.ifc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">ifc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">ifcout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an |AnaddbInput| for the computation of interatomic force constants.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            ifcout: Number of neighbouring atoms for which the ifc&#39;s will be output. If None all the atoms in the big box.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            asr, chneut, dipdip: Anaddb input variable. See official documentation.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;ANADDB input for IFC generated by AbiPy.&quot;</span><span class="p">,</span>
                  <span class="n">anaddb_args</span><span class="o">=</span><span class="n">anaddb_args</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="n">anaddb_kwargs</span><span class="p">)</span>

        <span class="n">q1shft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q1shft</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1">#TODO add in anaddb an option to get all the atoms if ifcout&lt;0</span>
        <span class="c1"># Huge number abinit will limit to the big box</span>
        <span class="n">ifcout</span> <span class="o">=</span> <span class="n">ifcout</span> <span class="ow">or</span> <span class="mi">10000000</span>

        <span class="n">new</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
            <span class="n">ifcflag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">ngqpt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ngqpt</span><span class="p">),</span>
            <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span>
            <span class="n">nqshft</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">q1shft</span><span class="p">),</span>
            <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span>
            <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
            <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span>
            <span class="n">ifcout</span><span class="o">=</span><span class="n">ifcout</span><span class="p">,</span>
            <span class="n">natifc</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span>
            <span class="n">atifc</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">ifcana</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">prt_ifc</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="AnaddbInput.dfpt"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.dfpt">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">dfpt</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relaxed_ion</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">piezo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dde</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">strain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dte</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">raman</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stress_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nqsmall</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">qppa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">q1shft</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dipdip</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ramansr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">alphon</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dos_method</span><span class="o">=</span><span class="s2">&quot;tetra&quot;</span><span class="p">,</span>
             <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">anaddb_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds an |AnaddbInput| to post-process a generic DFPT calculation.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object.</span>
<span class="sd">            ngqpt: Monkhorst-Pack divisions for the phonon Q-mesh (coarse one)</span>
<span class="sd">            stress_correction: True to activate computation of  stress correction in elastic tensor.</span>
<span class="sd">                Requires DDB with stress entries.</span>
<span class="sd">            relaxed_ion: True to activate computation of relaxed-ion elastic and piezoelectric tensors.</span>
<span class="sd">                (assume the DDB has atomic perturbations at Gamma)</span>
<span class="sd">            piezo: if True the piezoelectric tensor are calculated (requires piezoelectric perturbations)</span>
<span class="sd">            dde: if True dielectric tensors will be calculated. If phonon band</span>
<span class="sd">                structure is calculated will also enable the calculation of the lo_to splitting</span>
<span class="sd">                (requires the DDE perturbations)</span>
<span class="sd">            strain: if True the elastic tensors will be calculated (requires the strain perturbations)</span>
<span class="sd">            dte: if True properties related to the nonlinear tensors will be calculated</span>
<span class="sd">                (requires third orders perturbations)</span>
<span class="sd">            raman: if True the Raman tensor will be calculated (sets dte to True).</span>
<span class="sd">            nqsmall: Used to generate the (dense) mesh for the DOS.</span>
<span class="sd">                It defines the number of q-points used to sample the smallest lattice vector.</span>
<span class="sd">            qppa: Defines the homogeneous q-mesh used for the DOS in units of q-points per reciproval atom.</span>
<span class="sd">                Overrides nqsmall.</span>
<span class="sd">            line_density: Defines the a density of k-points per reciprocal atom to plot the phonon dispersion.</span>
<span class="sd">                Overrides ndivsm.</span>
<span class="sd">            ndivsm: Used to generate a normalized path for the phonon bands.</span>
<span class="sd">                If gives the number of divisions for the smallest segment of the path.</span>
<span class="sd">            q1shft: Shifts used for the coarse Q-mesh</span>
<span class="sd">            qptbounds: Boundaries of the path. If None, the path is generated from an internal database</span>
<span class="sd">                depending on the input structure.</span>
<span class="sd">            asr, chneut, dipdp, ramansr, alphon: Anaddb input variable. See official documentation.</span>
<span class="sd">            dos_method: Possible choices: &quot;tetra&quot;, &quot;gaussian&quot; or &quot;gaussian:0.001 eV&quot;.</span>
<span class="sd">                In the later case, the value 0.001 eV is used as gaussian broadening</span>
<span class="sd">            directions: list of 3D directions along which the non analytical contribution will be calculated.</span>
<span class="sd">                If None the three cartesian direction will be used. Used only when dte=True.</span>
<span class="sd">            anaddb_args: List of tuples (key, value) with Anaddb input variables (default: empty)</span>
<span class="sd">            anaddb_kwargs: Dictionary with Anaddb input variables (default: empty)</span>
<span class="sd">            comment: Optional string with a comment that will be placed at the beginning of the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># use the phonon BS and DOS input as starting point is required, otherwise</span>
        <span class="k">if</span> <span class="n">ngqpt</span><span class="p">:</span>
            <span class="n">anaddb_input</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">phbands_and_dos</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="n">structure</span><span class="p">,</span> <span class="n">ngqpt</span><span class="o">=</span><span class="n">ngqpt</span><span class="p">,</span> <span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">nqsmall</span><span class="o">=</span><span class="n">nqsmall</span><span class="p">,</span>
                                               <span class="n">qppa</span><span class="o">=</span><span class="n">qppa</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="n">line_density</span><span class="p">,</span> <span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">,</span>
                                               <span class="n">dipdip</span><span class="o">=</span><span class="n">dipdip</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">,</span> <span class="n">dos_method</span><span class="o">=</span><span class="n">dos_method</span><span class="p">,</span>
                                               <span class="n">lo_to_splitting</span><span class="o">=</span><span class="n">dde</span><span class="p">,</span> <span class="n">q1shft</span><span class="o">=</span><span class="n">q1shft</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">anaddb_input</span> <span class="o">=</span> <span class="n">AnaddbInput</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">)</span>
            <span class="n">anaddb_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">asr</span><span class="o">=</span><span class="n">asr</span><span class="p">,</span> <span class="n">chneut</span><span class="o">=</span><span class="n">chneut</span><span class="p">)</span>

        <span class="n">dieflag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">dde</span><span class="p">:</span>
            <span class="n">dieflag</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="p">(</span><span class="n">relaxed_ion</span> <span class="ow">and</span> <span class="n">strain</span><span class="p">)</span> <span class="k">else</span> <span class="mi">2</span>

        <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">strain</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">relaxed_ion</span><span class="p">:</span>
                <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">stress_correction</span><span class="p">:</span>
                <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elaflag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">piezoflag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">piezo</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">relaxed_ion</span><span class="p">:</span>
                <span class="n">piezoflag</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">dde</span> <span class="ow">and</span> <span class="n">strain</span><span class="p">:</span>
                <span class="n">piezoflag</span> <span class="o">=</span> <span class="mi">7</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">piezoflag</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="n">anaddb_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">dieflag</span><span class="o">=</span><span class="n">dieflag</span><span class="p">,</span> <span class="n">elaflag</span><span class="o">=</span><span class="n">elaflag</span><span class="p">,</span> <span class="n">piezoflag</span><span class="o">=</span><span class="n">piezoflag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dieflag</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="s1">&#39;nph2l&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">anaddb_input</span><span class="p">:</span>
            <span class="n">anaddb_input</span><span class="p">[</span><span class="s1">&#39;nph2l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">elaflag</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">anaddb_input</span><span class="p">[</span><span class="s2">&quot;instrflag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">raman</span><span class="p">:</span>
            <span class="n">dte</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">dte</span><span class="p">:</span>
            <span class="n">prtmbm</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">raman</span><span class="p">:</span>
                <span class="n">nlflag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">ramansr</span> <span class="o">=</span> <span class="n">ramansr</span>
                <span class="n">alphon</span> <span class="o">=</span> <span class="n">alphon</span>
                <span class="n">prtmbm</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">directions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">directions</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="c1"># append 0 to specify that these are directions,</span>
                    <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">directions</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">))]</span>

                <span class="n">anaddb_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span>
                    <span class="n">nph2l</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span>
                    <span class="n">qph2l</span><span class="o">=</span><span class="n">directions</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nlflag</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="n">ramansr</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">alphon</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">anaddb_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nlflag</span><span class="o">=</span><span class="n">nlflag</span><span class="p">,</span>
                                  <span class="n">ramansr</span><span class="o">=</span><span class="n">ramansr</span><span class="p">,</span>
                                  <span class="n">alphon</span><span class="o">=</span><span class="n">alphon</span><span class="p">,</span>
                                  <span class="n">prtmbm</span><span class="o">=</span><span class="n">prtmbm</span><span class="p">)</span>

        <span class="n">anaddb_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">anaddb_args</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_args</span>
        <span class="n">anaddb_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">anaddb_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anaddb_kwargs</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">anaddb_args</span><span class="p">)[:]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">anaddb_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
        <span class="n">anaddb_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">anaddb_input</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|Structure| object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

<div class="viewcode-block" id="AnaddbInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            sortmode: &quot;a&quot; for alphabetical order, None if no sorting is wanted</span>
<span class="sd">            mode: Either `text` or `html` if HTML output with links is wanted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;# &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">#&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sortmode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># no sorting.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sortmode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="c1"># alphabetical order.</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported value for sortmode </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sortmode</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="n">var_database</span> <span class="o">=</span> <span class="n">get_anaddb_variables</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span>
            <span class="c1">#root = &quot;https://docs.abinit.org/variables/anaddb/&quot;</span>
            <span class="c1">#if mode == &quot;html&quot;: vname = root + &quot;#%s&quot; % vname</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span> <span class="n">vname</span> <span class="o">=</span> <span class="n">var_database</span><span class="p">[</span><span class="n">vname</span><span class="p">]</span><span class="o">.</span><span class="n">html_link</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">vname</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">InputVariable</span><span class="p">(</span><span class="n">vname</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;text&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Integration with jupyter_ notebooks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="AnaddbInput.set_qpath"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_qpath">[docs]</a>    <span class="k">def</span> <span class="nf">set_qpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">qptbounds</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variables for the computation of the phonon band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            ndivsm: Number of divisions for the smallest segment.</span>
<span class="sd">            qptbounds: q-points defining the path in k-space.</span>
<span class="sd">                If None, we use the default high-symmetry k-path defined in the pymatgen database.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">qptbounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">qptbounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_kptbounds</span><span class="p">()</span>
        <span class="n">qptbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ndivsm</span><span class="o">=</span><span class="n">ndivsm</span><span class="p">,</span> <span class="n">nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qptbounds</span><span class="p">),</span> <span class="n">qpath</span><span class="o">=</span><span class="n">qptbounds</span><span class="p">)</span></div>

<div class="viewcode-block" id="AnaddbInput.set_autoqmesh"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.set_autoqmesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_autoqmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nqsmall</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the variable nqpt for the sampling of the BZ.</span>

<span class="sd">        Args:</span>
<span class="sd">            nqsmall: Number of divisions used to sample the smallest lattice vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ng2qpt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">calc_ngkpt</span><span class="p">(</span><span class="n">nqsmall</span><span class="p">))</span></div>

<div class="viewcode-block" id="AnaddbInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.AnaddbInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run ANADDB in dry-run mode to validate the input file.</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">AnaddbTask</span><span class="o">.</span><span class="n">temp_shell_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ddb_node</span><span class="o">=</span><span class="s2">&quot;fake_DDB&quot;</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="c1"># TODO: Anaddb does not support --dry-run</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="n">task</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OpticVar"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticVar">[docs]</a><span class="k">class</span> <span class="nc">OpticVar</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;OpticVar&quot;</span><span class="p">,</span> <span class="s2">&quot;name default group help&quot;</span><span class="p">)):</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sval</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sval</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">help</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">url</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The url associated to the variable.&quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;https://docs.abinit.org/variables/optic/&quot;</span>
        <span class="k">return</span> <span class="n">root</span> <span class="o">+</span> <span class="s2">&quot;#</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<div class="viewcode-block" id="OpticVar.html_link"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticVar.html_link">[docs]</a>    <span class="k">def</span> <span class="nf">html_link</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the URL of the web page.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;a href=&quot;</span><span class="si">%s</span><span class="s1">&quot; target=&quot;_blank&quot;&gt;</span><span class="si">%s</span><span class="s1">&lt;/a&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="OpticError"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticError">[docs]</a><span class="k">class</span> <span class="nc">OpticError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error class raised by OpticInput.&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpticInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput">[docs]</a><span class="k">class</span> <span class="nc">OpticInput</span><span class="p">(</span><span class="n">AbiAbstractInput</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input file for optic executable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">OpticError</span>

    <span class="c1"># variable name --&gt; default value.</span>
    <span class="n">_VARIABLES</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_x&quot;, default=None, help=&quot;Name of the first d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_y&quot;, default=None, help=&quot;Name of the second d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;ddkfile_z&quot;, default=None, help=&quot;Name of the third d/dk response wavefunction file&quot;),</span>
        <span class="c1">#OpticVar(name=&quot;wfkfile&quot;,   default=None, help=&quot;Name of the ground-state wavefunction file&quot;),</span>

        <span class="c1"># PARAMETERS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;broadening&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Value of the smearing factor, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;domega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.010</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Frequency step (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;maxomega&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Maximum frequency (Ha)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;scissor&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.000</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Scissor shift if needed, in Hartree&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tolerance on closeness of singularities (in Hartree)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;autoparal&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Autoparal option&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;max_ncpus&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Max number of CPUs considered in autoparal mode&quot;</span><span class="p">),</span>

        <span class="c1"># COMPUTATIONS section:</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of linear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;lin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear coefficients to be computed (x=1, y=2, z=3)&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of linear electro-optic tensor to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;linel_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Linear electro-optic coefficients to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;num_nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Number of components of nonlinear optic tensor v2 to be computed&quot;</span><span class="p">),</span>
        <span class="n">OpticVar</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;nonlin2_comp&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">,</span>
                 <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Non-linear coefficients v2 to be computed&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">_GROUPS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PARAMETERS&#39;</span><span class="p">,</span><span class="s1">&#39;COMPUTATIONS&#39;</span><span class="p">]</span>

    <span class="c1"># Variable names supported</span>
    <span class="n">_VARNAMES</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">]</span>

    <span class="c1"># Mapping name --&gt; var object.</span>
    <span class="n">_NAME2VAR</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_VARIABLES</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Initalize with default values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">)</span>

        <span class="c1"># Update the variables with the values passed by the user</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;varname </span><span class="si">%s</span><span class="s2"> not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">)))</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars</span>

    <span class="k">def</span> <span class="nf">_check_varname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a valid optic variable.</span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;If you are sure the name is correct, please change the _VARIABLES list in:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="vm">__file__</span><span class="p">))</span>

<div class="viewcode-block" id="OpticInput.get_default"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.get_default">[docs]</a>    <span class="k">def</span> <span class="nf">get_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the default value of variable `key`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARIABLES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span> <span class="k">return</span> <span class="n">var</span><span class="o">.</span><span class="n">default</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot find </span><span class="si">%s</span><span class="s2"> in _VARIABLES&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="OpticInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">grp</span><span class="p">,</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">grp</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;@module&quot;</span><span class="p">,</span> <span class="s2">&quot;@class&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">section</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># TODO</span>
    <span class="c1">#@pmg_serialize</span>
<div class="viewcode-block" id="OpticInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GROUPS</span><span class="p">:</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">group</span>
            <span class="n">my_dict</span><span class="p">[</span><span class="n">grp</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">my_dict</span></div>

<div class="viewcode-block" id="OpticInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">append</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VARNAMES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_default</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Variable </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

            <span class="c1"># One line per variable --&gt; valperline set to None</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">InputVariable</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">valperline</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">app</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="s2">&quot;! &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NAME2VAR</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">help</span><span class="p">])</span>

        <span class="c1"># Align</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    <span class="c1">#def _repr_html_(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Integration with jupyter notebooks.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.to_string(mode=&quot;html&quot;)</span>

<div class="viewcode-block" id="OpticInput.only_independent_chi_components"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.only_independent_chi_components">[docs]</a>    <span class="k">def</span> <span class="nf">only_independent_chi_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">assume_symmetric_tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use the crystal system returned by spglib to find the independent components</span>
<span class="sd">        of the linear susceptibility tensor and set the appropriate variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: Crystalline structure</span>
<span class="sd">            assume_symmetric_tensor: True if tensor can be assumed symmetric.</span>
<span class="sd">                Note that the tensor is symmetric only for a lossless and non-optically active material.</span>
<span class="sd">            symprec, angle_tolerance: Parameters passed to spglib.</span>

<span class="sd">        Return:</span>
<span class="sd">            Set internal variables and return list of components to compute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="kn">import</span> <span class="n">SpacegroupAnalyzer</span>
        <span class="n">spgan</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">spgan</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span>

        <span class="c1"># Table 1.5.1 of https://booksite.elsevier.com/samplechapters/9780123694706/Sample_Chapters/02~Chapter_1.pdf.</span>
        <span class="c1"># Note that the tensor is symmetric only for a lossless and non-optically active material.</span>
        <span class="n">components_for_system</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz xy yx xz zx yz zy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz xz zx&quot;</span><span class="p">,</span>
            <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx yy zz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span> <span class="s2">&quot;xx zz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="s2">&quot;xx&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">assume_symmetric_tensor</span><span class="p">:</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;triclinic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xx yy zz xy xz yz&quot;</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;monoclinic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;xx yy zz xz&quot;</span>

        <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;trigonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;tetragonal&quot;</span><span class="p">]</span>
        <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;hexagonal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="s2">&quot;tetragonal&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">components_for_system</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">components_for_system</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">ind_comps</span> <span class="o">=</span> <span class="n">components_for_system</span><span class="p">[</span><span class="n">system</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;num_lin_comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_comps</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;lin_comp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">ind_comps</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ind_comps</span></div>

<div class="viewcode-block" id="OpticInput.abivalidate"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.OpticInput.abivalidate">[docs]</a>    <span class="k">def</span> <span class="nf">abivalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run OPTIC in dry-run mode to validate the input file.</span>
<span class="sd">        Note: This method is a stub, it always return retcode 0</span>

<span class="sd">        Args:</span>
<span class="sd">            workdir: Working directory of the fake task used to compute the ibz. Use None for temporary dir.</span>
<span class="sd">            manager: |TaskManager| of the task. If None, the manager is initialized from the config file.</span>

<span class="sd">        Return:</span>
<span class="sd">            `namedtuple` with the following attributes:</span>

<span class="sd">                retcode: Return code. 0 if OK.</span>
<span class="sd">                output_file: output file of the run.</span>
<span class="sd">                log_file:  log file of the Abinit run, use log_file.read() to access its content.</span>
<span class="sd">                stderr_file: stderr file of the Abinit run. use stderr_file.read() to access its content.</span>
<span class="sd">                task: Task object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Optic does not support --dry-run</span>
        <span class="c1">#task = OpticTask.temp_shell_task(inp=self, workdir=workdir, manager=manager)</span>
        <span class="c1">#retcode = task.start_and_wait(autoparal=False, exec_args=[&quot;--dry-run&quot;])</span>
        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">retcode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">stderr_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Cut3DInput"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput">[docs]</a><span class="k">class</span> <span class="nc">Cut3DInput</span><span class="p">(</span><span class="n">MSONable</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the options to run a single cut3d analysis.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Converters with nspden &gt; 1 won&#39;t work since cut3d asks for the ispden index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">infile_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            options: a list of strings that defines the options to be passed to cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="o">=</span> <span class="n">infile_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span> <span class="o">=</span> <span class="n">output_filepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">options</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Cut3DInput.to_string"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a string with the input.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.write"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Writes the input to a file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Infile path and options should be provided&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">out_option</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic function used to generate the input for convertions using cut3d</span>

<span class="sd">        Args:</span>
<span class="sd">            infile_path: absolute or relative path to the input file produced by abinit (e.g. DEN, WFK, ...). Can be</span>
<span class="sd">                None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            out_option: a number corresponding to the required converting option in cut3d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">out_option</span><span class="p">)]</span>  <span class="c1"># Option to convert a _DEN file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="Cut3DInput.den_to_3d_formatted"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_formatted">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_3d_formatted</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D formatted format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit.</span>
<span class="sd">                Can be None to be defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_3d_indexed"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_3d_indexed">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_3d_indexed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a 3D indexed format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_molekel"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_molekel">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_molekel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Molekel format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_tecplot"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_tecplot">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_tecplot</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a Tecplot format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_xsf"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_xsf">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_xsf</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to an xsf format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">            shift: a list of three integers defining the shift along the x, y, z axis.</span>
<span class="sd">                None if no shift is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;9&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert a _DEN file to an .xsf file</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">)</span>  <span class="c1"># Name of the output .xsf file</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">shift</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>  <span class="c1"># No more analysis</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.den_to_cube"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.den_to_cube">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">den_to_cube</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the conversion to a cube format.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            output_filepath: path to the file that should be produced by cut3D, if required. At this stage it would be</span>
<span class="sd">                safer to use just the file name, as using an absolute or relative path may fail depending on</span>
<span class="sd">                the compiler.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">output_filepath</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.hirshfeld"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hirshfeld</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            all_el_dens_paths: a list of paths to the all-electron density files corresponding to the elements defined</span>
<span class="sd">                in the abinit input. See https://www.abinit.org/downloads/all_core_electron for files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">]</span>  <span class="c1"># Option to convert _DEN file to a .cube file</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_el_dens_paths</span><span class="p">:</span>
            <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.hirshfeld_from_fhi_path"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.hirshfeld_from_fhi_path">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">hirshfeld_from_fhi_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">density_filepath</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">fhi_all_el_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a cut3d input for the calculation of the Hirshfeld charges from the density. Automatically</span>
<span class="sd">        selects the all-electron density files from a folder containing the fhi all-electron density files:</span>
<span class="sd">        https://www.abinit.org/downloads/all_core_electron</span>

<span class="sd">        This will work only if the input has been generated with AbinitInput and the Structure object is the same</span>
<span class="sd">        provided to AbinitInput because the order of the pseudos depends on znucl.</span>

<span class="sd">        Args:</span>
<span class="sd">            density_filepath: absolute or relative path to the input density produced by abinit. Can be None to be</span>
<span class="sd">                defined at a later time.</span>
<span class="sd">            structure: the structure used for the ground state calculation. Used to determine the elements</span>
<span class="sd">            fhi_all_el_path: path to the folder containing the fhi all-electron density files</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_el_dens_paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># This relies on AbinitInput using Structure.species_by_znucl to define znucl when writing the input file.</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">species_by_znucl</span><span class="p">:</span>
            <span class="n">all_el_dens_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fhi_all_el_path</span><span class="p">,</span> <span class="s2">&quot;0.</span><span class="si">{:02}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">.8.density.AE&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">hirshfeld</span><span class="p">(</span><span class="n">density_filepath</span><span class="p">,</span> <span class="n">all_el_dens_paths</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.as_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">infile_path</span><span class="p">,</span> <span class="n">output_filepath</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cut3DInput.from_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.Cut3DInput.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        JSON interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">infile_path</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;infile_path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">output_filepath</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;output_filepath&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                   <span class="n">options</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;options&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="product_dict"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.product_dict">[docs]</a><span class="k">def</span> <span class="nf">product_dict</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function receives a dictionary d where each key defines a list of items or a simple scalar.</span>
<span class="sd">    It constructs the Cartesian product of the values (equivalent to nested for-loops),</span>
<span class="sd">    and returns a list of dictionaries with the values that would be used inside the loop.</span>

<span class="sd">    &gt;&gt;&gt; d = OrderedDict([(&quot;foo&quot;, [2, 4]), (&quot;bar&quot;, 1)])</span>
<span class="sd">    &gt;&gt;&gt; product_dict(d) == [OrderedDict([(&#39;foo&#39;, 2), (&#39;bar&#39;, 1)]), OrderedDict([(&#39;foo&#39;, 4), (&#39;bar&#39;, 1)])]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; d = OrderedDict([(&quot;bar&quot;, [1,2]), (&#39;foo&#39;, [3,4])])</span>
<span class="sd">    &gt;&gt;&gt; product_dict(d) == [{&#39;bar&#39;: 1, &#39;foo&#39;: 3},</span>
<span class="sd">    ... {&#39;bar&#39;: 1, &#39;foo&#39;: 4},</span>
<span class="sd">    ... {&#39;bar&#39;: 2, &#39;foo&#39;: 3},</span>
<span class="sd">    ... {&#39;bar&#39;: 2, &#39;foo&#39;: 4}]</span>
<span class="sd">    True</span>

<span class="sd">    .. warning:</span>

<span class="sd">        Dictionaries are not ordered, therefore one cannot assume that</span>
<span class="sd">        the order of the keys in the output equals the one used to loop.</span>
<span class="sd">        If the order is important, one should pass a :class:`OrderedDict` in input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="c1"># Each item in vals must be iterable.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span> <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="c1"># Build list of dictionaries. Use ordered dicts so that</span>
    <span class="c1"># we preserve the order when d is an OrderedDict.</span>
    <span class="n">vars_prod</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">prod_values</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">):</span>
        <span class="n">dprod</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">prod_values</span><span class="p">))</span>
        <span class="n">vars_prod</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dprod</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vars_prod</span></div>


<div class="viewcode-block" id="kpoints_from_line_density"><a class="viewcode-back" href="../../../api/abio_api.html#abipy.abio.inputs.kpoints_from_line_density">[docs]</a><span class="k">def</span> <span class="nf">kpoints_from_line_density</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">line_density</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute an high-symmetry k-path using pymatgen conventions and line_density</span>

<span class="sd">    Args:</span>
<span class="sd">        line_density: Number of points in each segment is computed as: int(ceil(distance * line_density))</span>
<span class="sd">            where distance is the lenght of the segment.</span>
<span class="sd">            This option is the recommended one if the k-path contains two consecutive high symmetry k-points</span>
<span class="sd">            that are very close as ndivsm &gt; 0 may produce a very large number of wavevectors.</span>
<span class="sd">        symprec: Symmetry precision passed to spglib.</span>

<span class="sd">    Return: (nkpt,3) numpy array with k-points in reduced coords.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">line_density</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid line_density: </span><span class="si">{</span><span class="n">line_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">hs</span> <span class="o">=</span> <span class="n">HighSymmKpath</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
    <span class="n">qpts</span><span class="p">,</span> <span class="n">labels_list</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">(</span><span class="n">line_density</span><span class="o">=</span><span class="n">line_density</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># remove repeated q-points since those do interfere with _set_split_vals in the phonon plotter</span>
    <span class="n">qph1l</span> <span class="o">=</span> <span class="p">[</span><span class="n">qpts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="n">qpts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="n">qph1l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">qph1l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qpt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qph1l</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, M. Giantomassi and the AbiPy group.
      <span class="lastupdated">
        Last updated on May 29, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>