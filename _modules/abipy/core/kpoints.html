

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>abipy.core.kpoints &mdash; abipy 0.9.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/my_style.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
    <script type="text/javascript" src="https://cdn.plot.ly/plotly-latest.min.js"></script> 
    
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/thebelab-helper.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> abipy
          

          
          </a>

          
            
            
              <div class="version">
                0.9.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Getting AbiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zzbiblio.html">Bibliography</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphical_interface.html">Graphical interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">AbiPy Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../postprocessing_howto.html">Post-processing How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/taskmanager.html">TaskManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/manager_examples.html">Manager Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flow_gallery/index.html">Flow Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flows_howto.html">Flows How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coding_guide.html">Coding guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">Documenting AbiPy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">abipy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>abipy.core.kpoints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for abipy.core.kpoints</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;This module defines objects describing the sampling of the Brillouin Zone.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="kn">import</span> <span class="n">MontyEncoder</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="kn">import</span> <span class="n">AttrDict</span><span class="p">,</span> <span class="n">dict2namedtuple</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="kn">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="kn">import</span> <span class="n">marquee</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.lattice</span> <span class="kn">import</span> <span class="n">Lattice</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.serialization</span> <span class="kn">import</span> <span class="n">pmg_serialize</span><span class="p">,</span> <span class="n">SlotPickleMixin</span>
<span class="kn">from</span> <span class="nn">abipy.iotools</span> <span class="kn">import</span> <span class="n">ETSF_Reader</span>
<span class="kn">from</span> <span class="nn">abipy.tools.derivatives</span> <span class="kn">import</span> <span class="n">finite_diff</span>
<span class="kn">from</span> <span class="nn">abipy.tools.numtools</span> <span class="kn">import</span> <span class="n">add_periodic_replicas</span><span class="p">,</span> <span class="n">is_diagonal</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;issamek&quot;</span><span class="p">,</span>
    <span class="s2">&quot;wrap_to_ws&quot;</span><span class="p">,</span>
    <span class="s2">&quot;wrap_to_bz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;as_kpoints&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Kpoint&quot;</span><span class="p">,</span>
    <span class="s2">&quot;KpointList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;KpointStar&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Kpath&quot;</span><span class="p">,</span>
    <span class="s2">&quot;IrredZone&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rc_list&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kmesh_from_mpdivs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ktables&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_points_along_path&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># Tolerance used to compare k-points.</span>
<span class="n">_ATOL_KDIFF</span> <span class="o">=</span> <span class="mf">1e-8</span>

<span class="c1"># Tolerances passed to spglib.</span>
<span class="n">_SPGLIB_SYMPREC</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="n">_SPGLIB_ANGLE_TOLERANCE</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>


<span class="k">def</span> <span class="nf">set_atol_kdiff</span><span class="p">(</span><span class="n">new_atol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the value of the tolerance ``_ATOL_KDIFF`` used to compare k-points.</span>
<span class="sd">    Return old value</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This function should be called at the beginning of the script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">old_atol</span> <span class="o">=</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">_ATOL_KDIFF</span> <span class="o">=</span> <span class="n">new_atol</span>
    <span class="k">return</span> <span class="n">old_atol</span>


<span class="k">def</span> <span class="nf">set_spglib_tols</span><span class="p">(</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the value of the tolerances ``symprec`` and ``angle_tolerance``</span>
<span class="sd">    used to call spglib_. Return old values</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This function should be called at the beginning of the script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span>
    <span class="n">old_symprec</span><span class="p">,</span> <span class="n">old_angle_tolerance</span> <span class="o">=</span> <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span>
    <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span> <span class="o">=</span> <span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span>
    <span class="k">return</span> <span class="n">old_symprec</span><span class="p">,</span> <span class="n">old_angle_tolerance</span>


<span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if all x is integer within the absolute tolerance atol.</span>
<span class="sd">    Use _ATOL_KDIFF is atol is None.</span>

<span class="sd">    &gt;&gt;&gt; assert is_integer([1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; assert is_integer(1.01, atol=0.011)</span>
<span class="sd">    &gt;&gt;&gt; assert not is_integer([1.01, 2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">int_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>


<div class="viewcode-block" id="issamek"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.issamek">[docs]</a><span class="k">def</span> <span class="nf">issamek</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if k1 and k2 are equal modulo a lattice vector.</span>
<span class="sd">    Use _ATOL_KDIFF is atol is None.</span>

<span class="sd">    &gt;&gt;&gt; assert issamek([1, 1, 1], [0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; assert issamek([1.1, 1, 1], [0, 0, 0], atol=0.1)</span>
<span class="sd">    &gt;&gt;&gt; assert not issamek(0.00003, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span>
    <span class="c1">#if k1.shape != k2.shape:</span>

    <span class="k">return</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">k1</span> <span class="o">-</span> <span class="n">k2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap_to_ws"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.wrap_to_ws">[docs]</a><span class="k">def</span> <span class="nf">wrap_to_ws</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms x in its corresponding reduced number in the interval ]-1/2,1/2].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">w</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap_to_bz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.wrap_to_bz">[docs]</a><span class="k">def</span> <span class="nf">wrap_to_bz</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms x in its corresponding reduced number in the interval [0,1[.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="rc_list"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.rc_list">[docs]</a><span class="k">def</span> <span class="nf">rc_list</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;bz&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a |numpy-array| with the linear mesh used to sample one dimension of the reciprocal space.</span>
<span class="sd">    Note that the coordinates are always ordered so that rc[i+1] &gt; rc[i].</span>
<span class="sd">    so that we can easily plot quantities defined on the 3D multidimensional mesh.</span>

<span class="sd">    Args:</span>
<span class="sd">        mp: Number of Monkhorst-Pack divisions along this direction.</span>
<span class="sd">        sh: Shift</span>
<span class="sd">        pbc: if pbc is True, periodic boundary conditions are enforced.</span>
<span class="sd">        order: Possible values [&quot;bz&quot;, &quot;unit_cell&quot;].</span>
<span class="sd">            if &quot;bz&quot;, the coordinates are forced to be in [-1/2, 1/2)</span>
<span class="sd">            if &quot;unit_cell&quot;, the coordinates are forced to be in [0, 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;unit_cell&quot;</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">mp</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pbc</span> <span class="k">else</span> <span class="n">mp</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">sh</span><span class="p">)</span> <span class="o">/</span> <span class="n">mp</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;bz&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mp</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">sh</span><span class="p">)</span> <span class="o">/</span> <span class="n">mp</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert xm1 in rc so that we still have a ordered list.</span>
                <span class="n">xm1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mf">1.0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">xm1</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

                <span class="n">rc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">xm1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong order </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span></div>


<div class="viewcode-block" id="kmesh_from_mpdivs"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.kmesh_from_mpdivs">[docs]</a><span class="k">def</span> <span class="nf">kmesh_from_mpdivs</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;bz&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a |numpy-array| with the reduced coordinates of the</span>
<span class="sd">    k-points from the MP divisions and the shifts.</span>

<span class="sd">    Args:</span>
<span class="sd">        mpdivs: The three MP divisions.</span>
<span class="sd">        shifts: Array-like object with the MP shift.</span>
<span class="sd">        pbc: If True, periodic images of the k-points will be included i.e. closed mesh.</span>
<span class="sd">        order: &quot;unit_cell&quot; if the kpoint coordinates must be in [0,1)</span>
<span class="sd">               &quot;bz&quot; if the kpoint coordinates must be in [-1/2, +1/2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Build k-point grid.</span>
    <span class="n">kbz</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ish</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shifts</span><span class="p">):</span>
        <span class="n">rc0</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">rc1</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">rc2</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kxyz</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">rc0</span><span class="p">,</span> <span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">):</span>
            <span class="n">kbz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kxyz</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kbz</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">map_grid2ibz</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ibz</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correspondence between a *grid* of k-points in the *unit cell*</span>
<span class="sd">    associated to the ``ngkpt`` mesh and the corresponding points in the IBZ.</span>
<span class="sd">    Requires structure with Abinit symmetries.</span>
<span class="sd">    This routine is mainly used to symmetrize eigenvalues in the unit cell</span>
<span class="sd">    e.g. to write BXSF files for electronic isosurfaces.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure: Structure with (Abinit) symmetry operations.</span>
<span class="sd">        ibz: [*, 3] array with reduced coordinates in the in the IBZ.</span>
<span class="sd">        ngkpt: Mesh divisions.</span>
<span class="sd">        has_timrev: True if time-reversal can be used.</span>
<span class="sd">        pbc: True if the mesh should contain the periodic images (closed mesh).</span>

<span class="sd">    Returns:</span>
<span class="sd">        bz2ibz: 1d array with BZ --&gt; IBZ mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ngkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Extract (FM) symmetry operations in reciprocal space.</span>
    <span class="n">abispg</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">abi_spacegroup</span>
    <span class="k">if</span> <span class="n">abispg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structure does not contain Abinit spacegroup info!&quot;</span><span class="p">)</span>

    <span class="c1"># Extract rotations in reciprocal space (FM part).</span>
    <span class="n">symrec_fm</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">rot_g</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">abispg</span><span class="o">.</span><span class="n">fm_symmops</span><span class="p">]</span>

    <span class="c1"># Compute TS k_ibz.</span>
    <span class="n">bzgrid2ibz</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ik_ibz</span><span class="p">,</span> <span class="n">kibz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ibz</span><span class="p">):</span>
        <span class="n">gp_ibz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">kibz</span> <span class="o">*</span> <span class="n">ngkpt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rot</span> <span class="ow">in</span> <span class="n">symrec_fm</span><span class="p">:</span>
            <span class="n">rot_gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">gp_ibz</span><span class="p">)</span>
            <span class="n">gp_bz</span> <span class="o">=</span> <span class="n">rot_gp</span> <span class="o">%</span> <span class="n">ngkpt</span>
            <span class="n">bzgrid2ibz</span><span class="p">[</span><span class="n">gp_bz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ik_ibz</span>
            <span class="k">if</span> <span class="n">has_timrev</span><span class="p">:</span>
                <span class="n">gp_bz</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">rot_gp</span><span class="p">)</span> <span class="o">%</span> <span class="n">ngkpt</span>
                <span class="n">bzgrid2ibz</span><span class="p">[</span><span class="n">gp_bz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ik_ibz</span>

    <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
        <span class="c1"># Add periodic replicas.</span>
        <span class="n">bzgrid2ibz</span> <span class="o">=</span> <span class="n">add_periodic_replicas</span><span class="p">(</span><span class="n">bzgrid2ibz</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bzgrid2ibz</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#for ik_bz, ik_ibz in enumerate(self.bzgrid2ibz): print(ik_bz, &quot;&gt;&gt;&gt;&quot;, ik_ibz)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2"> invalid entries in bzgrid2ibz array&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">bzgrid2ibz</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">bzgrid2ibz</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;This can happen if there an inconsistency between the input IBZ and ngkpt&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;ngkpt: </span><span class="si">%s</span><span class="s2">, has_timrev: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">),</span> <span class="n">has_timrev</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">bz2ibz</span> <span class="o">=</span> <span class="n">bzgrid2ibz</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">bz2ibz</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for ik_bz, kbz in enumerate(bz):</span>
<span class="sd">        found = False</span>
<span class="sd">        for ik_ibz, kibz in enumerate(ibz):</span>
<span class="sd">            if found: break</span>
<span class="sd">            for symmop in structure.spacegroup:</span>
<span class="sd">                krot = symmop.rotate_k(kibz)</span>
<span class="sd">                if issamek(krot, kbz):</span>
<span class="sd">                    bz2ibz[ik_bz] = ik_ibz</span>
<span class="sd">                    found = True</span>
<span class="sd">                    break</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">has_timrev_from_kptopt</span><span class="p">(</span><span class="n">kptopt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if time-reversal symmetry can be used to generate k-points in the IBZ.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># note: We assume TR if negative value i.e. band structure k-sampling.</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">kptopt</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">kptopt2str</span><span class="p">(</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return human-readable string with meaning of kptopt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kptopt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Band structure run. Use kptbounds, and ndivk (ndivsm)&quot;</span>
             <span class="s2">&quot;The absolute value of kptopt gives the number of segments of the band structure.&quot;</span> <span class="o">+</span>
             <span class="s2">&quot;Weights are usually irrelevant with this option&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Manual mode&quot;</span><span class="p">,</span>
                <span class="s2">&quot;User-provided nkpt, kpt, kptnrm and wtk&quot;</span><span class="p">),</span>
            <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Use space group symmetries and TR symmetry&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Usual mode for GS calculations (ngkpt or kptrlatt, nshiftk and shiftk)&quot;</span><span class="p">),</span>
            <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Only TR symmetry&quot;</span><span class="p">,</span>
                <span class="s2">&quot;This is to be used for DFPT at Gamma (ngkpt or kptrlatt, nshiftk and shiftk)&quot;</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Do not take into account any symmetry&quot;</span><span class="p">,</span>
                <span class="s2">&quot;This is to be used for DFPT at non-zero q (ngkpt or kptrlatt, nshiftk and shiftk).&quot;</span><span class="p">),</span>
            <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Spatial symmetries, NO TR symmetry&quot;</span><span class="p">,</span>
                <span class="s2">&quot;This has to be used for PAW calculations with SOC (pawspnorb/=0) &quot;</span> <span class="o">+</span>
                <span class="s2">&quot;from ngkpt or kptrlatt, nshiftk and shiftk.&quot;</span><span class="p">),</span>
        <span class="p">}[</span><span class="n">kptopt</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">map_kpoints</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">,</span> <span class="n">other_lattice</span><span class="p">,</span> <span class="n">ref_lattice</span><span class="p">,</span> <span class="n">ref_kpoints</span><span class="p">,</span> <span class="n">ref_symrecs</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build mapping between a list of k-points in reduced coordinates (``other_kpoints``)</span>
<span class="sd">    in the reciprocal lattice ``other_lattice`` and a list of reference k-points given</span>
<span class="sd">    in the reciprocal lattice `ref_lattice` with symmetry operations ``ref_symrecs``.</span>

<span class="sd">    Args:</span>
<span class="sd">        other_kpoints:</span>
<span class="sd">        other_lattice: matrix whose rows are the reciprocal lattice vectors in cartesian coordinates.</span>
<span class="sd">        ref_lattice: same meaning as other_lattice.</span>
<span class="sd">        ref_kpoints:</span>
<span class="sd">        ref_symrecs: [nsym,3,3] arrays with symmetry operations in the `ref_lattice` reciprocal space.</span>
<span class="sd">        has_timrev: True if time-reversal can be used.</span>

<span class="sd">    Returns</span>
<span class="sd">        (o2r_map, nmissing)</span>

<span class="sd">        nmissing:</span>
<span class="sd">            Number of k-points in ref_kpoints that cannot be mapped onto ref_kpoints.</span>

<span class="sd">        o2r_map[i] gives the mapping  between the i-th k-point in other_kpoints and</span>
<span class="sd">            ref_kpoints. Set to None if the i-th k-point does not have any image in ref.</span>
<span class="sd">            Each entry is a named tuple with the following attributes:</span>

<span class="sd">                ik_ref:</span>
<span class="sd">                tsign:</span>
<span class="sd">                isym</span>
<span class="sd">                g0</span>

<span class="sd">            kpt_other = TS kpt_ref + G0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_gprimd_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">other_gprimd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">other_kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">ref_kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_kpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">o2r_map</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="n">tsigns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_timrev</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="n">kmap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;kmap&quot;</span><span class="p">,</span> <span class="s2">&quot;ik_ref, tsign, isym, g0&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ik_oth</span><span class="p">,</span> <span class="n">okpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">):</span>
        <span class="c1"># Get other k-point in reduced coordinates in the reference lattice.</span>
        <span class="n">okpt_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">ref_gprimd_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">other_gprimd</span><span class="p">,</span> <span class="n">okpt</span><span class="p">))</span>

        <span class="c1"># k_other = TS k_ref + G0</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ik_ref</span><span class="p">,</span> <span class="n">kref</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_kpoints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">for</span> <span class="n">tsign</span> <span class="ow">in</span> <span class="n">tsigns</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">isym</span><span class="p">,</span> <span class="n">symrec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_symrecs</span><span class="p">):</span>
                    <span class="n">krot</span> <span class="o">=</span> <span class="n">tsign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">symrec</span><span class="p">,</span> <span class="n">kref</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">okpt_red</span><span class="p">,</span> <span class="n">krot</span><span class="p">):</span>
                        <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">okpt_red</span> <span class="o">-</span> <span class="n">krot</span><span class="p">)</span>
                        <span class="n">o2r_map</span><span class="p">[</span><span class="n">ik_oth</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">ik_ref</span><span class="p">,</span> <span class="n">tsign</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="n">g0</span><span class="p">)</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">o2r_map</span><span class="p">,</span> <span class="n">o2r_map</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<span class="c1">#def find_irred_kpoints_kmesh(structure, kfrac_coords):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    Remove k-points that are connected to each other by one of the</span>
<span class="c1">#    symmetry operations of the space group. Assume k-points</span>
<span class="c1">#    belonging to a homogeneous mesh.</span>
<span class="c1">#</span>
<span class="c1">#    Args:</span>
<span class="c1">#        structure: Structure object.</span>
<span class="c1">#        kfrac_coords: Reduced coordinates of the k-points.</span>
<span class="c1">#</span>
<span class="c1">#    Return:</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    # Wrap in [0,1[ interval.</span>
<span class="c1">#    uc_kcoords = np.reshape(kfrac_coords, (-1, 3)) % 1</span>
<span class="c1">#    numk = len(uc_kcoords)</span>
<span class="c1">#    nx, ny, nz = np.int(np.floor(1 / uc_kcoords.min(axis=0)))</span>
<span class="c1">#</span>
<span class="c1">#    # Compute rank and invrank</span>
<span class="c1">#    rank = np.array(numk, dtype=np.int)</span>
<span class="c1">#    invrank = {}</span>
<span class="c1">#    for ik, kk in enumerate(uc_kcoords):</span>
<span class="c1">#        rk = iz + iy * nz + ix * ny * nz</span>
<span class="c1">#        rank[ik] = rk</span>
<span class="c1">#        invrank[rank] = ik</span>
<span class="c1">#</span>
<span class="c1">#    irred_map = collections.deque()</span>
<span class="c1">#    irred_map.append(0)</span>
<span class="c1">#    kpts2irred = collections.deque()</span>
<span class="c1">#    kpts2irred.append((0, 0, +1))</span>
<span class="c1">#</span>
<span class="c1">#    for ik, kk in enumerate(uc_kcoords[1:]):</span>
<span class="c1">#        ik += 1</span>
<span class="c1">#        found = False</span>
<span class="c1">#        for ik_irr in irred_map:</span>
<span class="c1">#            kirr = kfrac_coords[ik_irr]</span>
<span class="c1">#            for isym, symmop in enumerate(structure.abi_spacegroup):</span>
<span class="c1">#                krot = symmop.rotate_k(kirr)</span>
<span class="c1">#                new_frac_coords = krot.frac_coords % 1</span>
<span class="c1">#                if issamek(krot, kk):</span>
<span class="c1">#                    #kpts2irred[ik] = ik_irr</span>
<span class="c1">#                    #kpts2irred[ik] = isym</span>
<span class="c1">#                    found = True</span>
<span class="c1">#                    break</span>
<span class="c1">#</span>
<span class="c1">#    #return irred_map</span>


<span class="k">def</span> <span class="nf">find_irred_kpoints_generic</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">kfrac_coords</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove the k-points that are connected to each other by one of the</span>
<span class="sd">    symmetry operations of the space group. No assumption is done</span>
<span class="sd">    on the initial k-point sampling, this means that one can call this</span>
<span class="sd">    function to treat points on a path in reciprocal space.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure: |Structure| object.</span>
<span class="sd">        kfrac_coords: Reduced coordinates of the k-points.</span>

<span class="sd">    Return:</span>
<span class="sd">        irred_map: Index of the i-th irreducible k-point in the input kfrac_coords array.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        In the worst case, the algorithm scales as nkpt ** 2 * nsym.</span>
<span class="sd">        hence this routine should be used only if ``kfrac_coords`` represents</span>
<span class="sd">        e.g. a path in the Brillouin zone or an arbitrary set of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing redundant k-points. This is gonna take a while... &quot;</span><span class="p">)</span>

    <span class="c1"># Wrap points in [0,1[ interval.</span>
    <span class="n">uc_kcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kfrac_coords</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">%</span> <span class="mi">1</span>

    <span class="n">irred_map</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="n">irred_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">kpts2irred</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="n">kpts2irred</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uc_kcoords</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">ik</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ik_irr</span> <span class="ow">in</span> <span class="n">irred_map</span><span class="p">:</span>
            <span class="n">kirr</span> <span class="o">=</span> <span class="n">kfrac_coords</span><span class="p">[</span><span class="n">ik_irr</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">isym</span><span class="p">,</span> <span class="n">symmop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">abi_spacegroup</span><span class="p">):</span>
                <span class="n">krot</span> <span class="o">=</span> <span class="n">symmop</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="n">kirr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">krot</span><span class="p">,</span> <span class="n">kk</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1">#kpts2irred[ik] = (ik_irr, isym, symmops.time_sign)</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">irred_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Completed in&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;[s]&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Entered with &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uc_kcoords</span><span class="p">),</span> <span class="s2">&quot;k-points&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">irred_map</span><span class="p">),</span> <span class="s2">&quot;irred k-points&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">irred_map</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">irred_map</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">kpath_from_bounds_and_ndivsm</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">ndivsm</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a normalized path given the extrema and the number of divisions for the smallest segment</span>

<span class="sd">    Args:</span>
<span class="sd">        bounds: (N, 3) array with the boundaries of the path in reduced coordinates.</span>
<span class="sd">        ndivsm: Number of divisions used for the smallest segment.</span>

<span class="sd">    Return:</span>
<span class="sd">        Array (M, 3) with fractional coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">nbounds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nbounds</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least two points to define the k-path!&quot;</span><span class="p">)</span>

    <span class="n">lens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)))</span>

    <span class="c1"># Avoid division by zero if any bounds[i+1] == bounds[i]</span>
    <span class="n">minlen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">minlen</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found two equivalent consecutive points in bounds!&quot;</span><span class="p">)</span>

    <span class="n">minlen</span> <span class="o">=</span> <span class="n">minlen</span> <span class="o">/</span> <span class="n">ndivsm</span>
    <span class="n">ndivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">lens</span> <span class="o">/</span> <span class="n">minlen</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndivs</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">ndivs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">KpointsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for KpointList exceptions.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="as_kpoints"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.as_kpoints">[docs]</a><span class="k">def</span> <span class="nf">as_kpoints</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert obj into a list of k-points.</span>

<span class="sd">    Args:</span>
<span class="sd">        obj: :class:`Kpoint` or list of Kpoint objects or array-like object.</span>
<span class="sd">        lattice: Reciprocal lattice.</span>
<span class="sd">        weights: k-point weights. Ignored if obj is already a `Kpoint` instance or a list of `Kpoint` items.</span>
<span class="sd">        name: string with the name of the k-point. Ignored if obj is already a `Kpoint`</span>
<span class="sd">              instance or a list of `Kpoint` items.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># K-point?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>

    <span class="c1"># Iterable with K-points?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Kpoint</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="c1"># Assume array-like</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">names</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">names</span><span class="p">)]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndim &gt; 2 is not supported&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kpoint"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint">[docs]</a><span class="k">class</span> <span class="nc">Kpoint</span><span class="p">(</span><span class="n">SlotPickleMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class defining one k-point. This object is immutable and can be used as key in dictionaries</span>

<span class="sd">    Note that we usually construct the object by passing pymatgen.reciprocal_lattice</span>
<span class="sd">    that is the standard reciprocal lattice used for solid state physics</span>
<span class="sd">    with a factor of 2 * pi i.e. a_i . b_j = 2pi delta_ij.</span>
<span class="sd">    Abinit, on the contrary, uses the crystallographic reciprocal lattice i.e. no 2pi factor.</span>
<span class="sd">    so pay attention when converting Abinit routines to AbiPy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_frac_coords&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lattice&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_weight&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_hash&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="Kpoint.from_name_and_structure"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.from_name_and_structure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_name_and_structure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build Kpoint object from string with name and structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_kcoords_from_names</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            frac_coords: Reduced coordinates of the k-point.</span>
<span class="sd">            lattice: |Lattice| object describing the reciprocal lattice.</span>
<span class="sd">            weights: k-point weight (optional, set to zero if not given).</span>
<span class="sd">            name: string with the name of the k-point (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting vector with 3 items, got `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span> <span class="o">=</span> <span class="n">lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_weight</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">#def __array__(self, **kwargs):</span>
    <span class="c1">#    &quot;&quot;&quot;np.array(self)&quot;&quot;&quot;</span>
    <span class="c1">#    print(kwargs)</span>
    <span class="c1">#    dtype = kwargs.pop(&quot;dtype&quot;, None)</span>
    <span class="c1">#    if dtype is None:</span>
    <span class="c1">#        return self._frac_coords</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        return np.array(self._frac_coords, dtype=dtype)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kpoint objects can be used as keys in dictionaries.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The hash is computed from the fractional coordinates (floats).</span>
<span class="sd">            Hence one should avoid using hashes for implementing search algorithms</span>
<span class="sd">            in which new Kpoints are, for example generated by means of</span>
<span class="sd">            symmetry operations. This means that a dict of Kpoint objects</span>
<span class="sd">            is safe to use only when we are sure than we are going to access</span>
<span class="sd">            its entries with the *same* keys used to generate the dict!.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|Lattice| object describing the Reciprocal lattice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weight of the k-point. 0.0 if the weight is not defined.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span>

<div class="viewcode-block" id="Kpoint.set_weight"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.set_weight">[docs]</a>    <span class="k">def</span> <span class="nf">set_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the weight of the k-point.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="n">weight</span></div>

<div class="viewcode-block" id="Kpoint.cart_coords"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.cart_coords">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">cart_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian coordinates of the k-point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the k-point. None if not available.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

<div class="viewcode-block" id="Kpoint.set_name"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the k-point.&quot;&quot;&quot;</span>
        <span class="c1"># Fix typo in Latex syntax (if any).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">):</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span></div>

<div class="viewcode-block" id="Kpoint.on_border"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.on_border">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">on_border</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the k-point is on the border of the BZ (lattice translations are taken into account).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kreds</span> <span class="o">=</span> <span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kreds</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">_ATOL_KDIFF</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">s</span>

<div class="viewcode-block" id="Kpoint.tos"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.tos">[docs]</a>    <span class="k">def</span> <span class="nf">tos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="s2">&quot;fract&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return string with fractional or cartesian coords depending</span>
<span class="sd">        on mode `m` in (&quot;fract&quot;, &quot;cart&quot;, &quot;fracart&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;fract&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;cart&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="o">==</span> <span class="s2">&quot;fracart&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tos</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="s2">&quot;fract&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tos</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="s2">&quot;cart&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid mode: `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Kpoint.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, weight: </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="k">return</span> <span class="n">s</span></div>

    <span class="c1"># Kpoint algebra.</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">):</span>
            <span class="c1"># Comparison between two Kpoint objects</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Kpoint vs iterable (e.g. list)</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

<div class="viewcode-block" id="Kpoint.as_kpoint"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.as_kpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_kpoint</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into a :class:`Kpoint` instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: :class:`Kpoint` instance or array-like with the reduced coordinates.</span>
<span class="sd">            lattice: |Lattice| object defining the reciprocal lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.gamma"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.gamma">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the Gamma point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$\Gamma$&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.copy"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.is_gamma"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.is_gamma">[docs]</a>    <span class="k">def</span> <span class="nf">is_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_umklapp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this the gamma point.</span>

<span class="sd">        Args:</span>
<span class="sd">            allow_umklapp: True if umklapp G-vectors are allowed.</span>
<span class="sd">            atol: Absolute tolerance for k-point comparison (used only if umklapp).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_umklapp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.norm"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.norm">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Norm of the kpoint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">))</span></div>

<div class="viewcode-block" id="Kpoint.versor"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.versor">[docs]</a>    <span class="k">def</span> <span class="nf">versor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the versor i.e. math:`||k|| = 1`&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.wrap_to_ws"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.wrap_to_ws">[docs]</a>    <span class="k">def</span> <span class="nf">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new |Kpoint| in the Wigner-Seitz zone.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.wrap_to_bz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.wrap_to_bz">[docs]</a>    <span class="k">def</span> <span class="nf">wrap_to_bz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new |Kpoint| in the first unit cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">wrap_to_bz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.compute_star"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.compute_star">[docs]</a>    <span class="k">def</span> <span class="nf">compute_star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmops</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the star of the kpoint (tuple of |Kpoint| objects).&quot;&quot;&quot;</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">]</span>

        <span class="c1"># TODO: This part becomes a bottleneck for large nk!</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symmops</span><span class="p">:</span>
            <span class="n">sk_coords</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="n">wrap_tows</span><span class="p">)</span>

            <span class="c1"># Add it only if it&#39;s not already in the list.</span>
            <span class="k">for</span> <span class="n">prev_coords</span> <span class="ow">in</span> <span class="n">frac_coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">sk_coords</span><span class="p">,</span> <span class="n">prev_coords</span><span class="p">):</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KpointStar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="KpointList"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList">[docs]</a><span class="k">class</span> <span class="nc">KpointList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining a sequence of |Kpoint| objects. Essentially consists</span>
<span class="sd">    of base methods implementing the sequence protocol and helper functions.</span>
<span class="sd">    The subclasses |Kpath| and |IrredZone| provide specialized methods to operate</span>
<span class="sd">    on k-points representing a path or list of points in the IBZ, respectively.</span>
<span class="sd">    This object is immutable.</span>

<span class="sd">    .. Note:</span>

<span class="sd">        Algorithms usually need to know what kind of sampling we are using.</span>
<span class="sd">        The test can be easily implemented with:</span>

<span class="sd">        if kpoints.is_path:</span>
<span class="sd">            # code specific to k-paths.</span>

<span class="sd">        elif kpoints.is_ibz:</span>
<span class="sd">            # code specific to IBZ sampling.</span>

<span class="sd">    .. rubric:: Inheritance Diagram</span>
<span class="sd">    .. inheritance-diagram:: KpointList</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">KpointsError</span>

<div class="viewcode-block" id="KpointList.subclass_from_name"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.subclass_from_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">subclass_from_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the class with the given name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="bp">cls</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find subclass associated to name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.from_dict"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Kpoints obey the general json interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reciprocal_lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;reciprocal_lattice&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;frac_coords&quot;</span><span class="p">],</span>
                   <span class="n">weights</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;ksampling&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="KpointList.as_dict"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Kpoints obey the general json interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">reciprocal_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
            <span class="n">ksampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            reciprocal_lattice: |Lattice| object.</span>
<span class="sd">            frac_coords: Array-like object with the reduced coordinates of the k-points.</span>
<span class="sd">            weights: List of k-point weights. If None, weights are initialized with zeros.</span>
<span class="sd">            names: List of k-point names.</span>
<span class="sd">            ksampling: Info on the k-point sampling (used for homogeneous meshes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reciprocal_lattice</span> <span class="o">=</span> <span class="n">reciprocal_lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span> <span class="o">=</span> <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span> <span class="o">=</span> <span class="n">ksampling</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(weights) != len(frac_coords):</span><span class="se">\n</span><span class="s2">weights: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">frac_coords: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">))</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(names) != len(frac_coords):</span><span class="se">\n</span><span class="s2">names: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">frac_coords: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rcs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">rcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|Lattice| object defining the reciprocal lattice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reciprocal_lattice</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="nb">repr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>

<div class="viewcode-block" id="KpointList.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="n">marquee</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">) </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">kpoint</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)])</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

    <span class="c1"># Sequence protocol.</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="fm">__reversed__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge k-points with different reciprocal lattice.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KpointList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span>
                          <span class="n">frac_coords</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">],</span>
                          <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">],</span>
                        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">KpointList</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k1</span> <span class="o">!=</span> <span class="n">k2</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="KpointList.index"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns: the first index of kpoint in self.</span>

<span class="sd">        Raises: `ValueError` if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find point: </span><span class="si">%s</span><span class="s2"> in KpointList:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">kpoint</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span></div>

<div class="viewcode-block" id="KpointList.get_all_kindices"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.get_all_kindices">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_kindices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return numpy array with indexes of all the k-point</span>
<span class="sd">        Accepts: |Kpoint| instance or integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="n">k0</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="n">kinds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">k0</span><span class="p">:</span> <span class="n">kinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.find"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns: first index of kpoint. -1 if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="KpointList.count"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of occurrences of kpoint&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.find_closest"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.find_closest">[docs]</a>    <span class="k">def</span> <span class="nf">find_closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the closest k-point in the list (not necessarily equal).</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: Fractional coordinates or |Kpoint| instance.</span>

<span class="sd">        Return:</span>
<span class="sd">            (ind, kpoint, dist)</span>

<span class="sd">            where ``ind`` is the index in self of the closest k-point.</span>
<span class="sd">            ``kpoint`` is the |Kpoint| instance of index ``ind``.</span>
<span class="sd">            dist is the distance between ``obj`` and ``kpoint``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">lattice</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Kpoint list and Kpoint object have different lattices!&quot;</span><span class="p">)</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">kpt</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">)</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ind</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self represents a path in the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Kpath</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self represents a list of points in the IBZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IrredZone</span><span class="p">)</span>

<div class="viewcode-block" id="KpointList.mpdivs_shifts"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.mpdivs_shifts">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">mpdivs_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Monkhorst-Pack (MP) divisions and shifts.</span>
<span class="sd">        Both quantities are set to None if self is not a MP mesh.</span>
<span class="sd">        Use `is_mpmesh` to check whether self is a MP mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ibz</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Test if kptrlatt is diagonal.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptrlatt</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">shifts</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_mpmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if self represents a Monkhorst-Pack mesh.</span>
<span class="sd">        i.e if the sampling has been specified in terms of divisions</span>
<span class="sd">        along the reciprocal lattice vectors (ngkpt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpdivs_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-point as |numpy-array| of shape (len(self), 3)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span>

<div class="viewcode-block" id="KpointList.get_cart_coords"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.get_cart_coords">[docs]</a>    <span class="k">def</span> <span class="nf">get_cart_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian coordinates of the k-point as |numpy-array| of shape (len(self), 3)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">cart_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with the name of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;|numpy-array| with the weights of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kpoint</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

<div class="viewcode-block" id="KpointList.sum_weights"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.sum_weights">[docs]</a>    <span class="k">def</span> <span class="nf">sum_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the sum of the weights.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.check_weights"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.check_weights">[docs]</a>    <span class="k">def</span> <span class="nf">check_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if weights are normalized to one.</span>
<span class="sd">        Raises: `ValueError` if Weights are not normalized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Weights must be normalized to one.</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wsum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-6</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Kpoint weights should sum up to one while sum_weights is </span><span class="si">%.3f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">wsum</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;The list of kpoints does not represent a homogeneous sampling of the BZ</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.get_highsym_datataframe"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.get_highsym_datataframe">[docs]</a>    <span class="k">def</span> <span class="nf">get_highsym_datataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_cart_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return pandas Dataframe with the names of the high-symmetry k-points</span>
<span class="sd">        and the reduced coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_cart_coords: True to add extra column with the Cartesian coordinates.</span>

<span class="sd">        Return: |pandas-DataFrame|</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">replace</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">r</span><span class="s2">&quot;$\Gamma$&quot;</span><span class="p">:</span> <span class="s2">&quot;Γ&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kpt</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">replace</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">kpt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">kpt</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">frac_coords</span><span class="o">=</span><span class="n">kpt</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_cart_coords</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;cart_coords&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt</span><span class="o">.</span><span class="n">cart_coords</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Idx&quot;</span>

        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="KpointList.remove_duplicated"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.remove_duplicated">[docs]</a>    <span class="k">def</span> <span class="nf">remove_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove duplicated k-points from self. Returns new :class:`KpointList` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frac_coords</span><span class="p">,</span> <span class="n">good_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Add it only if it&#39;s not already in the list.</span>
            <span class="k">for</span> <span class="n">prev_coords</span> <span class="ow">in</span> <span class="n">frac_coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">prev_coords</span><span class="p">):</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                <span class="n">good_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">good_kpoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">good_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span>
                <span class="n">frac_coords</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">good_kpoints</span><span class="p">],</span>
                <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">good_kpoints</span><span class="p">],</span>
                <span class="n">ksampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.to_array"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.to_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a |numpy-array| [nkpy, 3] with the fractional coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="KpointList.to_json"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a JSON_ string representation of the MSONable object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span> <span class="bp">cls</span><span class="o">=</span><span class="n">MontyEncoder</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.plot"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot k-points with matplotlib.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.electronic_structure.plotter</span> <span class="kn">import</span> <span class="n">plot_brillouin_zone</span>
        <span class="n">fold</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_path</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
            <span class="n">frac_coords_lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">plot_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">frac_coords_lines</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                                       <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not sure this works, I got points outside of the BZ in a simple with Si and Gamma-centered 8x8x8.</span>
            <span class="c1"># Don&#39;t know if it&#39;s a bug in matplotlib or plot_brillouin_zone.</span>
            <span class="c1">#print(self.frac_coords)</span>
            <span class="k">return</span> <span class="n">plot_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">kpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                                       <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.plotly"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.plotly">[docs]</a>    <span class="k">def</span> <span class="nf">plotly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot k-points with plotly.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.tools.plotting</span> <span class="kn">import</span> <span class="n">plotly_brillouin_zone</span>
        <span class="n">fold</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_path</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
            <span class="n">frac_coords_lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">plotly_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">frac_coords_lines</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                                         <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">plotly_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">kpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                                         <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointList.get_k2kqg_map"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointList.get_k2kqg_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_k2kqg_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qpt</span><span class="p">,</span> <span class="n">atol_kdiff</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute mapping k_index --&gt; (k + q)_index, g0</span>

<span class="sd">        Args:</span>
<span class="sd">            qpt: q-point in fractional coordinate or :class:`Kpoint` instance.</span>
<span class="sd">            atol_kdiff: Tolerance used to compare k-points.</span>
<span class="sd">                Use _ATOL_KDIFF is atol is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atol_kdiff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">atol_kdiff</span> <span class="o">=</span> <span class="n">_ATOL_KDIFF</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">):</span>
            <span class="n">qfrac_coords</span> <span class="o">=</span> <span class="n">qpt</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qfrac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>

        <span class="n">k2kqg</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qfrac_coords</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-6</span><span class="p">):</span>
            <span class="c1"># Gamma point, DOH!</span>
            <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">k2kqg</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">g0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># N**2 scaling but this algorithm can handle k-paths</span>
            <span class="c1"># Note that in principle one could have multiple k+q in k-points</span>
            <span class="c1"># but only the first match is considered.</span>
            <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">kpq</span> <span class="o">=</span> <span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="n">qfrac_coords</span>
                <span class="k">for</span> <span class="n">ikq</span><span class="p">,</span> <span class="n">ksearch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">kpq</span><span class="p">,</span> <span class="n">ksearch</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol_kdiff</span><span class="p">):</span>
                        <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">kpq</span> <span class="o">-</span> <span class="n">ksearch</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                        <span class="n">k2kqg</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ikq</span><span class="p">,</span> <span class="n">g0</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">k2kqg</span></div></div>


<div class="viewcode-block" id="KpointStar"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.KpointStar">[docs]</a><span class="k">class</span> <span class="nc">KpointStar</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Star of the kpoint. Note that the first k-point is assumed to be the base</span>
<span class="sd">    of the star namely the point that is used to generate the Star.</span>

<span class="sd">    .. inheritance-diagram:: KpointStar</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The point used to generate the star.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the star (inherited from the name of the base point).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_point</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="Kpath"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath">[docs]</a><span class="k">class</span> <span class="nc">Kpath</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object describes a k-path in reciprocal space.</span>
<span class="sd">    It provides methods to compute (line) derivatives along the path.</span>
<span class="sd">    The k-points do not have weights so Kpath should not be used to compute integral in the BZ.</span>

<span class="sd">    .. inheritance-diagram:: Kpath</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Kpath.from_names"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.from_names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">knames</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate normalized K-path from list of k-point labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object.</span>
<span class="sd">            knames: List of strings with the k-point labels.</span>
<span class="sd">            line_density: Number of points used to sample the smallest segment of the path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kfrac_coords</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_kcoords_from_names</span><span class="p">(</span><span class="n">knames</span><span class="p">)</span>
        <span class="n">vertices_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">kfrac_coords</span><span class="p">,</span> <span class="n">knames</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_vertices_and_names</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">vertices_names</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="n">line_density</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpath.from_vertices_and_names"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.from_vertices_and_names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_vertices_and_names</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">vertices_names</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate normalized k-path from a list of vertices and the corresponding labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object.</span>
<span class="sd">            vertices_names:  List of tuple, each tuple is of the form (kfrac_coords, kname) where</span>
<span class="sd">                kfrac_coords are the reduced coordinates of the k-point and kname is a string with the name of</span>
<span class="sd">                the k-point. Each point represents a vertex of the k-path.</span>
<span class="sd">            line_density: Number of points used to sample the smallest segment of the path.</span>
<span class="sd">                If 0, use list of k-points given in vertices_names</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">line_density</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">vn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">]</span>
            <span class="n">knames</span> <span class="o">=</span> <span class="p">[</span><span class="n">vn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="o">=</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">knames</span><span class="p">)</span>

        <span class="n">gmet</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">metric_tensor</span>
        <span class="n">vnames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">vn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">dl_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k0</span>
            <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">gmet</span><span class="p">,</span> <span class="n">dk</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">dl_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>

        <span class="n">dl_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dl_vals</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="n">fact</span> <span class="o">=</span> <span class="n">dl_min</span> <span class="o">/</span> <span class="n">line_density</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="n">knames</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">dl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dl_vals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dl</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">numk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">dl</span> <span class="o">/</span> <span class="n">fact</span><span class="p">))</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k0</span>
            <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnames</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numk</span><span class="p">):</span>
                <span class="n">next_k</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">+</span> <span class="n">dk</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">/</span> <span class="n">numk</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="o">=</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">knames</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Kpath.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            verbose: Verbosity level. Default: 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="n">marquee</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;K-path contains </span><span class="si">%s</span><span class="s2"> lines. Number of k-points in each line: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">),</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;line </span><span class="si">%d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="n">vids</span> <span class="o">=</span> <span class="p">{</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">}</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Idx&quot;</span><span class="p">,</span> <span class="s2">&quot;Frac_coords&quot;</span><span class="p">,</span> <span class="s2">&quot;Name&quot;</span><span class="p">,</span> <span class="s2">&quot;ds&quot;</span><span class="p">,</span> <span class="s2">&quot;Vert&quot;</span><span class="p">,]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vids</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="s2">&quot;</span><span class="si">%.7f</span><span class="s2">, </span><span class="si">%.7f</span><span class="s2">, </span><span class="si">%.7f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vids</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="p">])</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">tabulate</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s2">&quot;firstrow&quot;</span><span class="p">)])</span></div>

<div class="viewcode-block" id="Kpath.ds"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.ds">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">ds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        |numpy-array| of len(self)-1 elements giving the distance between two</span>
<span class="sd">        consecutive k-points, i.e. ds[i] = ||k[i+1] - k[i]|| for i=0,1,...,n-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kpoint</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span>
        <span class="k">return</span> <span class="n">ds</span></div>

<div class="viewcode-block" id="Kpath.versors"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.versors">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">versors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tuple of len(self) - 1 elements with the versors connecting k[i] to k[i+1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">versors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">versors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kpt</span><span class="p">)</span><span class="o">.</span><span class="n">versor</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">versors</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpath.lines"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.lines">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nested list containing the indices of the points belonging to the same line.</span>
<span class="sd">        Used for extracting the eigenvalues while looping over the lines.</span>

<span class="sd">        Example:</span>

<span class="sd">            for line in self.lines:</span>
<span class="sd">                vals_on_line = eigens[spin, line, band]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">versors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">versors</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#if v != prev:</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">prev</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">):</span>
                <span class="c1">#print(&quot;diff&quot;, (prev - v).norm, v.frac_coords - prev.frac_coords)</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpath.frac_bounds"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.frac_bounds">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">frac_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Numpy array of shape [M, 3] with the vertexes of the path in frac coords.&quot;&quot;&quot;</span>
        <span class="n">frac_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
        <span class="n">frac_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frac_bounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Kpath.cart_bounds"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.cart_bounds">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">cart_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Numpy array of shape [M, 3] with the vertexes of the path in frac coords.&quot;&quot;&quot;</span>
        <span class="n">cart_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">cart_coords</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
        <span class="n">cart_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">cart_bounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Kpath.find_points_along_path"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.find_points_along_path">[docs]</a>    <span class="k">def</span> <span class="nf">find_points_along_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cart_coords</span><span class="p">,</span> <span class="n">dist_tol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find points in ``cart_coords`` lying on the path with distance less than `dist_tol`.</span>
<span class="sd">        See find_points_along_path function for API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">find_points_along_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_bounds</span><span class="p">,</span> <span class="n">cart_coords</span><span class="p">,</span> <span class="n">dist_tol</span><span class="o">=</span><span class="n">dist_tol</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpath.finite_diff"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.finite_diff">[docs]</a>    <span class="k">def</span> <span class="nf">finite_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the derivatives of values by finite differences.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: array-like object with shape=(nkpt) containing the values of the path.</span>
<span class="sd">            order: Order of the derivative.</span>
<span class="sd">            acc: Accuracy: 4 corresponds to a central difference with 5 points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ragged numpy array. The i-th entry is a numpy array with the derivatives on the i-th line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Loop over the lines of the path, extract the data on the line and</span>
        <span class="c1"># differentiate f(s) where s is the distance between two consecutive points along the line.</span>
        <span class="n">ders_on_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
            <span class="n">vals_on_line</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">line</span><span class="p">]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For finite difference derivatives, the path must be homogeneous!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="n">der</span> <span class="o">=</span> <span class="n">finite_diff</span><span class="p">(</span><span class="n">vals_on_line</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">acc</span><span class="p">)</span>
            <span class="n">ders_on_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">der</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ders_on_lines</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IrredZone"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone">[docs]</a><span class="k">class</span> <span class="nc">IrredZone</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :class:`IrredZone` is a (immutable) sequence of points in the irreducible wedge of the BZ.</span>
<span class="sd">    Each point has a weight whose sum must equal 1 so that we can integrate quantities in the full Brillouin zone.</span>

<span class="sd">    .. note::</span>

<span class="sd">            Abinit supports different options for the specification of the BZ sampling:</span>

<span class="sd">                 - kptrlatt(3,3) or ngkpt(3) for the definition grid.</span>
<span class="sd">                 - shiftk(3, nshiftk) for the definition of multiple shifts.</span>
<span class="sd">                 - `kptopt` for the treatment of symmetry operations.</span>

<span class="sd">            All these possibilities complicate the internal implementation in particular when</span>
<span class="sd">            we need to recostruct the full BZ and take into account the presence of multiple shifts</span>
<span class="sd">            since kptrlatt may have non-zero off-diagonal components. Client code that needs to know</span>
<span class="sd">            how the mesh was generated can rely on the following checks:</span>

<span class="sd">            if not self.ibz: raise(&quot;Need an IBZ sampling&quot;)</span>

<span class="sd">            mpdivs, shifts = self.mpdivs_shifts</span>
<span class="sd">            if mpdivs is None: raise ValueError(&quot;Cannot handle kptrlatt with non-zero off-diagonal elements&quot;)</span>
<span class="sd">            if len(shifts) &gt; 1: raise ValueError(&quot;Multiple shifts are not supported&quot;)</span>
<span class="sd">            # Code for mesh defined in terms of mpdivs and one shift.</span>

<span class="sd">    .. inheritance-diagram:: IrredZone</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#@classmethod</span>
    <span class="c1">#def from_ngkpt_or_kppa(cls, structure, ngkpt, shiftk, kptopt=1, verbose=0):</span>
    <span class="c1">#    from abipy.tools import duck</span>
    <span class="c1">#    if duck.is_listlike(ngkpt):</span>
    <span class="c1">#        return cls.from_ngkpt(structure, ngkpt, shiftk, kptopt=kptopt, verbose=verbose)</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        return cls.from_kppa(structure, kppa, shiftk, kptopt=kptopt, verbose=verbose)</span>

<div class="viewcode-block" id="IrredZone.from_ngkpt"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone.from_ngkpt">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ngkpt</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin_mode</span><span class="o">=</span><span class="s2">&quot;unpolarized&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an IrredZone object from (ngkpt, shift) by calling Abinit</span>
<span class="sd">        to get the list of irreducible k-points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.abio.factories</span> <span class="kn">import</span> <span class="n">gs_input</span>
        <span class="kn">from</span> <span class="nn">abipy.data.hgh_pseudos</span> <span class="kn">import</span> <span class="n">HGH_TABLE</span>
        <span class="n">gsinp</span> <span class="o">=</span> <span class="n">gs_input</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">HGH_TABLE</span><span class="p">,</span> <span class="n">spin_mode</span><span class="o">=</span><span class="n">spin_mode</span><span class="p">)</span>
        <span class="n">ibz</span> <span class="o">=</span> <span class="n">gsinp</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">ksampling</span> <span class="o">=</span> <span class="n">KSamplingInfo</span><span class="o">.</span><span class="n">from_mpdivs</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">ibz</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">ibz</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                   <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span></div>

<div class="viewcode-block" id="IrredZone.from_kppa"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone.from_kppa">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kppa</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">kppa</span><span class="p">,</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build an IrredZone object from (kppa, shift) by calling Abinit</span>
<span class="sd">        to get the list of irreducible k-points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.abio.factories</span> <span class="kn">import</span> <span class="n">gs_input</span>
        <span class="kn">from</span> <span class="nn">abipy.data.hgh_pseudos</span> <span class="kn">import</span> <span class="n">HGH_TABLE</span>
        <span class="n">gsinp</span> <span class="o">=</span> <span class="n">gs_input</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">HGH_TABLE</span><span class="p">,</span> <span class="n">spin_mode</span><span class="o">=</span><span class="s2">&quot;unpolarized&quot;</span><span class="p">,</span> <span class="n">kppa</span><span class="o">=</span><span class="n">kppa</span><span class="p">)</span>
        <span class="n">ibz</span> <span class="o">=</span> <span class="n">gsinp</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">ksampling</span> <span class="o">=</span> <span class="n">KSamplingInfo</span><span class="o">.</span><span class="n">from_mpdivs</span><span class="p">(</span><span class="n">gsinp</span><span class="p">[</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">],</span> <span class="n">shiftk</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">ibz</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">ibz</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                   <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            reciprocal_lattice: |Lattice| object</span>
<span class="sd">            frac_coords: Array-like object with the reduced coordinates of the points.</span>
<span class="sd">            weights: Array-like with the weights of the k-points.</span>
<span class="sd">            names: List with the name of the k-points.</span>
<span class="sd">            ksampling: Info on the k-point sampling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span>
                         <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>

        <span class="c1"># Weights must be normalized to one.</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wsum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-6</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The list of kpoints does not represent a homogeneous sampling of the BZ</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Kpoint weights should sum up to one while sum_weights is </span><span class="si">%.3f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">wsum</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="c1">#raise ValueError(err_msg)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="IrredZone.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="n">marquee</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mpmesh</span><span class="p">:</span>
            <span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpdivs_shifts</span>
            <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;K-mesh with divisions: </span><span class="si">%s</span><span class="s2">, shifts: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;kptopt: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptopt</span><span class="p">,</span> <span class="n">kptopt2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptopt</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;nkpt: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>

        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Number of points in the IBZ: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;... (More than 10 k-points)&quot;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6d</span><span class="s2">) [</span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">, </span><span class="si">%+.3f</span><span class="s2">],  weight=</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">.</span><span class="n">weight</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div></div>

    <span class="c1">#@property</span>
    <span class="c1">#def len_bz(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Number of points in the full BZ.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.mpdivs.prod() * self.num_shifts</span>

    <span class="c1">#def iter_bz_coords(self):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Generates the fractional coordinates of the points in the BZ.</span>
    <span class="c1">#    .. note:</span>
    <span class="c1">#        points are ordered in blocks, one block for each shift.</span>
    <span class="c1">#        Inside the block, points are ordered following the C convention.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    for shift in self.shifts:</span>
    <span class="c1">#        for i in range(mpdivs[0]):</span>
    <span class="c1">#            x = (i + shift[0]) / mpdivs[0]</span>
    <span class="c1">#            for j in range(mpdivs[1]):</span>
    <span class="c1">#                y = (j + shift[1]) / mpdivs[1]</span>
    <span class="c1">#                for k in range(mpdivs[2]):</span>
    <span class="c1">#                    z = (k + shift[2]) / mpdivs[2]</span>
    <span class="c1">#                    yield np.array((x, y, z))</span>

    <span class="c1">#def plane_cut(self, values_ibz):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Symmetrize values in the IBZ to have them on the full BZ, then</span>
    <span class="c1">#    select a slice along the specified plane E.g. plane = (1,1,0).</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    assert len(values_ibz) == len(self)</span>
    <span class="c1">#    #indices =</span>
    <span class="c1">#    z0 = 0</span>
    <span class="c1">#    plane = np.empty((self.nx, self.ny))</span>
    <span class="c1">#    kx, ky = range(self.nx), range(self.ny)</span>
    <span class="c1">#    for x in kx:</span>
    <span class="c1">#        for y in ky:</span>
    <span class="c1">#            ibz_idx = self.map_xyz2ibz[x, y, z0]</span>
    <span class="c1">#            plane[x, y] = values_ibz[ibz_idx]</span>
    <span class="c1">#    kx, ky = np.meshgrid(kx, ky)</span>
    <span class="c1">#    return kx, ky, plane</span>


<span class="k">class</span> <span class="nc">KSamplingInfo</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store metadata defining the k-point sampling according to the abinit conventions.</span>
<span class="sd">    One should pass through one of the class methods to create the class, avoid calling __init__ directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">KNOWN_KEYS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
        <span class="s2">&quot;mpdivs&quot;</span><span class="p">,</span>          <span class="c1"># Mesh divisions. Defined only if we have a sampling with diagonal kptrlatt else None.</span>
        <span class="s2">&quot;kptrlatt&quot;</span><span class="p">,</span>        <span class="c1"># [3, 3] matrix defined only if we have a sampling else None.</span>
        <span class="s2">&quot;kptrlatt_orig&quot;</span><span class="p">,</span>   <span class="c1"># Original set of shifts. Defined only if we have a sampling else None.</span>
        <span class="s2">&quot;shifts&quot;</span><span class="p">,</span>          <span class="c1"># Actual shifts (Usually one). Defined only if we have a sampling else None.</span>
        <span class="s2">&quot;shifts_orig&quot;</span><span class="p">,</span>     <span class="c1"># Original shifts specified by the user. Defined only if we have a sampling else None.</span>
        <span class="s2">&quot;kptopt&quot;</span><span class="p">,</span>          <span class="c1"># Options for k-point generation. Negative if we have a k-path (nbounds - 1).</span>
    <span class="p">])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_ksampling</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into a :class:`KSamplingInfo` instance.</span>
<span class="sd">        Accepts: :class:`KSamplingInfo` instance, None (if info are not available) or dict-like object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">kptrlatt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shifts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">shifts_orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">kptopt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Assume dict-like object.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to convert `</span><span class="si">%s</span><span class="s2">` into KSamplingInfo object:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mpdivs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Homogeneous sampling specified in terms of ``mpdivs`` (ngkpt in abinit),</span>
<span class="sd">        the set of ``shifts`` and the value of ``kptopt``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="n">kptrlatt_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kptrlatt</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">kptrlatt</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Homogeneous sampling specified in terms of ``kptrlatt``</span>
<span class="sd">        the set of ``shifts`` and the value of ``kptopt``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="n">kptrlatt_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Test if kptrlatt is diagonal.</span>
        <span class="n">mpdivs</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">is_diagonal</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kbounds</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">kbounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Metadata associated to a k-path specified in terms of boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mpdivs</span><span class="p">,</span> <span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Note -1</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KNOWN_KEYS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknow key </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># FIXME: monkhorst_pack_folding is not written in e.g. DEN.nc files</span>
        <span class="c1"># so we get crazy results because of netCDF4._default_fillvals</span>
        <span class="c1"># This part set the value of mpdivs from kptrlatt.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;mpdivs&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;mpdivs&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e+6</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt_orig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We have a sampling</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt_orig</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;mpdivs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;mpdivs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#                    import warnings</span>
<span class="c1">#                    warnings.warn(&quot;&quot;&quot;</span>
<span class="c1">#monkhorst_pack_folding variables has not been written to netcdf file.</span>
<span class="c1">#Received {mpdivs}</span>
<span class="c1">#Setting mpdivs to None, this may create problems in post-processing tools.</span>
<span class="c1">#If needed, use python netcdf to change the value of `monkhorst_pack_folding`&quot;&quot;&quot;.format(mpdivs=self[&quot;mpdivs&quot;]))</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="n">marquee</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mesh</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_diagonal_kptrlatt</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;mpdivs: </span><span class="si">%s</span><span class="s2"> with shifts </span><span class="si">%s</span><span class="s2"> and kptopt: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpdivs</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;kptrlatt: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;shifts: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;kptrlatt_orig: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt_orig</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;shifts_orig: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts_orig</span><span class="p">))</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;kptopt: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span><span class="p">),</span> <span class="n">kptopt2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_path</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Path with kptopt: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Neither mesh or path!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we have a mesh in the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpdivs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we have a path in the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="c1">#@property</span>
    <span class="c1">#def is_homogeneous(self):</span>
    <span class="c1">#    &quot;&quot;&quot;True if we have a homogeneous sampling of the BZ.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.kptopt &gt; 0 and (self.mpdivs is not None or self.kptrlatt is not None)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_diagonal_kptrlatt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if sampling with diagonal kptrlatt.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">is_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">KpointsReaderMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class that provides methods for reading k-point data from a netcdf</span>
<span class="sd">    file written according to the ETSF-IO specifications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">read_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory function: returns an instance of :class:`Kpath` or :class:`IrredZone`</span>
<span class="sd">        depending on the content of the Netcdf file. Main entry point for client code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_structure</span><span class="p">()</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kfrac_coords</span><span class="p">()</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kweights</span><span class="p">()</span>
        <span class="n">ksampling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_ksampling_info</span><span class="p">()</span>

        <span class="c1">#if ksampling.kptopt &lt; 0:</span>
        <span class="k">if</span> <span class="n">ksampling</span><span class="o">.</span><span class="n">kptopt</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># We have a path in the BZ.</span>
            <span class="n">kpath</span> <span class="o">=</span> <span class="n">Kpath</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="n">kpath</span><span class="p">:</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">findname_in_hsym_stars</span><span class="p">(</span><span class="n">kpoint</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">kpath</span>

        <span class="c1"># FIXME</span>
        <span class="c1"># Quick and dirty hack to allow the reading of the k-points from WFK files</span>
        <span class="c1"># where info on the sampling is missing. I will regret it but at present</span>
        <span class="c1"># is the only solution I found (changes in the ETSF-IO part of Abinit are needed)</span>
        <span class="c1">#if ksampling.is_homogeneous or abs(sum(weights) - 1.0) &lt; 1.e-6:</span>
        <span class="c1">#if np.any(ksampling.kptrlatt_orig != 0) or abs(sum(weights) - 1.0) &lt; 1.e-6:</span>

        <span class="c1">#if np.any(ksampling.kptrlatt_orig != 0):</span>
        <span class="c1"># We have a homogeneous sampling of the BZ.</span>
        <span class="k">return</span> <span class="n">IrredZone</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_ksampling_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read information on the k-point sampling. Return :class:`KSamplingInfo` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: in v8.0, the SIGRES files does not have kptopt, kptrlatt_orig and shiftk_orig</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kptrlatt</span><span class="p">()</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kshifts</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">KSamplingInfo</span><span class="p">(</span>
            <span class="n">mpdivs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_kmpdivs</span><span class="p">(),</span>
            <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span>
            <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptrlatt_orig&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">),</span>
            <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span>
            <span class="n">shifts_orig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;shiftk_orig&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">shifts</span><span class="p">),</span>
            <span class="n">kptopt</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptopt&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kfrac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-points&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kweights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weight of the k-points. None if not found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_weights&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kshifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the shifts of the k-mesh in reduced coordinates. None if not found.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;shiftk&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_grid_shift&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kmpdivs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Monkhorst-Pack divisions defining the mesh. None if not found.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;monkhorst_pack_folding&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rootgrp</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_if_masked_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;monkhorst_pack_folding&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kptrlatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kptrlatt</span><span class="p">()</span>
            <span class="n">kmpdivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">kptrlatt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">kmpdivs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">kmpdivs</span>

    <span class="k">def</span> <span class="nf">read_kptrlatt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns ABINIT variable kptrlatt. None if not found.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptrlatt&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_grid_vectors&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">KpointsReader</span><span class="p">(</span><span class="n">ETSF_Reader</span><span class="p">,</span> <span class="n">KpointsReaderMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object reads k-point data from a netcdf file.</span>

<span class="sd">    .. inheritance-diagram:: KpointsReader</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="Ktables"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables">[docs]</a><span class="k">class</span> <span class="nc">Ktables</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call spglib to compute the k-points in the IBZ with the corresponding weights</span>
<span class="sd">    as well as the mapping BZ --&gt; IBZ.</span>

<span class="sd">    Args:</span>
<span class="sd">        mesh:</span>
<span class="sd">        is_shift:</span>

<span class="sd">    Attributes:</span>

<span class="sd">        mesh</span>
<span class="sd">        is_shift</span>
<span class="sd">        ibz:</span>
<span class="sd">        nibz</span>
<span class="sd">        weights:</span>
<span class="sd">        bz:</span>
<span class="sd">        nbz</span>
<span class="sd">        grid:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">is_shift</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            structure</span>
<span class="sd">            mesh</span>
<span class="sd">            is_shift</span>
<span class="sd">            has_timrev</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">spglib</span> <span class="k">as</span> <span class="nn">spg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_shift</span> <span class="o">=</span> <span class="n">is_shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span> <span class="o">=</span> <span class="n">has_timrev</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">)</span>

        <span class="n">mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">spg</span><span class="o">.</span><span class="n">get_ir_reciprocal_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span>
            <span class="n">is_shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_shift</span><span class="p">,</span> <span class="n">is_time_reversal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">_SPGLIB_SYMPREC</span><span class="p">)</span>

        <span class="n">uniq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nibz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_shift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">is_shift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">uniq</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">)</span>

        <span class="c1"># All k-points and mapping to ir-grid points.</span>
        <span class="c1"># FIXME This is slow.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik_bz</span><span class="p">,</span> <span class="n">ir_gp_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">uniq</span> <span class="o">==</span> <span class="n">ir_gp_id</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span><span class="p">[</span><span class="n">ik_bz</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Ktables.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">();</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="n">marquee</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">mark</span><span class="o">=</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>

        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;mesh </span><span class="si">%s</span><span class="s2">, shift </span><span class="si">%s</span><span class="s2">, time-reversal: </span><span class="si">%s</span><span class="s2">, Irred points: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nibz</span><span class="p">))</span>

        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Irreducible k-points with number of points in star:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">], nstar: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbz</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ktables.print_bz2ibz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables.print_bz2ibz">[docs]</a>    <span class="k">def</span> <span class="nf">print_bz2ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print BZ --&gt; IBZ mapping.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BZ points --&gt; IBZ points mapping&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik_bz</span><span class="p">,</span> <span class="n">ik_ibz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6d</span><span class="s2">) [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">], ===&gt; </span><span class="si">%6d</span><span class="s2">) [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">],&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">ik_bz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ik_ibz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">dist_point_from_line</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return distance from point x0 to line x1 - x2. Cartesian coordinates are used.</span>
<span class="sd">    See &lt;http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span>
    <span class="n">denomabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">denom</span><span class="p">))</span>
    <span class="n">numer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">numerabs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">numer</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">numerabs</span> <span class="o">/</span> <span class="n">denomabs</span>


<div class="viewcode-block" id="find_points_along_path"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.find_points_along_path">[docs]</a><span class="k">def</span> <span class="nf">find_points_along_path</span><span class="p">(</span><span class="n">cart_bounds</span><span class="p">,</span> <span class="n">cart_coords</span><span class="p">,</span> <span class="n">dist_tol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find points in ``cart_coords`` lying on the path defined by ``cart_bounds``.</span>
<span class="sd">    Result are ordered according to distance along the path.</span>

<span class="sd">    Args:</span>
<span class="sd">        cart_bounds: [N, 3] array with the boundaries of the path in Cartesian coordinates.</span>
<span class="sd">        cart_coords: [M, 3] array with the points in Cartesian coordinate</span>
<span class="sd">        dist_tol: A point is considered to be on the path if its distance from the line</span>
<span class="sd">            is less than dist_tol.</span>

<span class="sd">    Return: namedtuple with the following attributes:</span>

<span class="sd">        (ikfound, dist_list, path_ticks)</span>

<span class="sd">        ikfound is a numpy array with the indices of the points lying on the path. Empty if no point is found.</span>
<span class="sd">        dist_list: numpy array with the distance of the points along the line.</span>
<span class="sd">        path_ticks: numpy array with the ticks associated to the input k-path.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ikfound</span><span class="p">,</span> <span class="n">dist_list</span><span class="p">,</span> <span class="n">path_ticks</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">dl</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># cumulative length of the path</span>
    <span class="k">for</span> <span class="n">ibound</span><span class="p">,</span> <span class="n">x0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cart_bounds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">cart_bounds</span><span class="p">[</span><span class="n">ibound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span>
        <span class="c1">#B = x1 - x0</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>
        <span class="c1">#print(&quot;x0&quot;, x0, &quot;x1&quot;, x1)</span>
        <span class="n">path_ticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_ticks</span><span class="p">[</span><span class="n">ibound</span><span class="p">]</span> <span class="o">+</span> <span class="n">dk</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cart_coords</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">dist_point_from_line</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="c1">#print(frac_coords[ik], dist)</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">dist_tol</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># k-point is on the cart_bounds</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">k</span>
            <span class="c1">#A = k - x0</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="n">dk</span>
            <span class="c1">#print(&quot;k-x0&quot;, A, &quot;B&quot;, B)</span>
            <span class="c1">#print(frac_coords[ik], x, x &gt; 0 and x &lt; dist_tol + dk)</span>
            <span class="k">if</span> <span class="n">dist_tol</span> <span class="o">+</span> <span class="n">dk</span> <span class="o">&gt;=</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># k-point is within the cart_bounds range</span>
                <span class="c1"># append k-point coordinate along the cart_bounds while avoing duplicate entries.</span>
                <span class="k">if</span> <span class="n">ikfound</span> <span class="ow">and</span> <span class="n">ik</span> <span class="o">==</span> <span class="n">ikfound</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="k">continue</span>
                <span class="n">ikfound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                <span class="n">dist_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dl</span><span class="p">)</span>

        <span class="n">dl</span> <span class="o">=</span> <span class="n">dl</span> <span class="o">+</span> <span class="n">dk</span>

    <span class="c1"># Sort dist_list and ikfound by cumulative length while removing possible duplicated entries.</span>
    <span class="n">dist_list</span><span class="p">,</span> <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_list</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">ikfound</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ikfound</span><span class="p">)[</span><span class="n">isort</span><span class="p">],</span>
                           <span class="n">dist_list</span><span class="o">=</span><span class="n">dist_list</span><span class="p">,</span>
                           <span class="n">path_ticks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path_ticks</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">build_segments</span><span class="p">(</span><span class="n">k0_list</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">red_dirs</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each point in k0_list, build a line passing through the point for each</span>
<span class="sd">    reduced direction in red_dir. Each line consists of `npts` points with step `step` in Ang-1</span>
<span class="sd">    and is centered on the k-point. Return: (nk0_list, len(red_dirs) * npts, 3) array with fractional coordinates.</span>

<span class="sd">    Args:</span>
<span class="sd">        k0_list: List of k-points in reduced coordinates.</span>
<span class="sd">        npts: Number of points in each segment.</span>
<span class="sd">        step: Step in Ang-1</span>
<span class="sd">        red_dirs: List of reduced directions</span>
<span class="sd">        reciprocal_lattice: Reciprocal lattice (from structure.reciprocal_lattice)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k0_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k0_list</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">red_dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">red_dirs</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="n">k0_list</span><span class="p">:</span>
        <span class="n">kpoint</span> <span class="o">=</span> <span class="n">Kpoint</span><span class="o">.</span><span class="n">as_kpoint</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">)</span>
        <span class="c1"># Build segments passing through this kpoint (work in Cartesian coords)</span>
        <span class="k">for</span> <span class="n">rdir</span> <span class="ow">in</span> <span class="n">red_dirs</span><span class="p">:</span>
            <span class="n">bvers</span> <span class="o">=</span> <span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">rdir</span>
            <span class="c1">#bvers = reciprocal_lattice.get_cartesian_coords(rdir)</span>
            <span class="n">bvers</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bvers</span><span class="p">,</span> <span class="n">bvers</span><span class="p">))</span>
            <span class="n">kstart</span> <span class="o">=</span> <span class="n">kpoint</span><span class="o">.</span><span class="n">cart_coords</span> <span class="o">-</span> <span class="n">bvers</span> <span class="o">*</span> <span class="p">(</span><span class="n">npts</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npts</span><span class="p">):</span>
                <span class="n">kpts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kstart</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">*</span> <span class="n">step</span> <span class="o">*</span> <span class="n">bvers</span><span class="p">)</span>

    <span class="c1"># Cart --&gt; Frac</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k0_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">red_dirs</span><span class="p">)</span> <span class="o">*</span> <span class="n">npts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, M. Giantomassi and the AbiPy group.
      <span class="lastupdated">
        Last updated on May 29, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>