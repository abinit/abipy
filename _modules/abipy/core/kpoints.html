

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>abipy.core.kpoints &mdash; abipy 0.1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="abipy 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> abipy
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Feature Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Getting AbiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../whats_new.html">What&#8217;s new in abipy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts.html">Command line tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/plot/index.html">plot Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devel/index.html">The AbiPy Developers&#8217; Guide</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">abipy</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>abipy.core.kpoints</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for abipy.core.kpoints</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;This module defines objects describing the sampling of the Brillouin Zone.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="k">import</span> <span class="n">tabulate</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">MontyEncoder</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="k">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.lattice</span> <span class="k">import</span> <span class="n">Lattice</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="k">import</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.pickle_coders</span> <span class="k">import</span> <span class="n">SlotPickleMixin</span>
<span class="kn">from</span> <span class="nn">abipy.iotools</span> <span class="k">import</span> <span class="n">ETSF_Reader</span>
<span class="kn">from</span> <span class="nn">abipy.tools.derivatives</span> <span class="k">import</span> <span class="n">finite_diff</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;issamek&quot;</span><span class="p">,</span>
    <span class="s2">&quot;wrap_to_ws&quot;</span><span class="p">,</span>
    <span class="s2">&quot;wrap_to_bz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;as_kpoints&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Kpoint&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Kpath&quot;</span><span class="p">,</span>
    <span class="s2">&quot;IrredZone&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rc_list&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kmesh_from_mpdivs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ktables&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># Tolerance used to compare k-points.</span>
<span class="n">_ATOL_KDIFF</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span>

<span class="c1"># Tolerances passed to spglib.</span>
<span class="n">_SPGLIB_SYMPREC</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span>
<span class="n">_SPGLIB_ANGLE_TOLERANCE</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

<span class="k">def</span> <span class="nf">set_atol_kdiff</span><span class="p">(</span><span class="n">new_atol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the value of the tolerance `_ATOL_KDIFF` used to compare k-points.</span>
<span class="sd">    Return old value</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This function should be called at the beginning of the script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">old_atol</span> <span class="o">=</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">_ATOL_KDIFF</span> <span class="o">=</span> <span class="n">new_atol</span>
    <span class="k">return</span> <span class="n">old_atol</span>

<span class="k">def</span> <span class="nf">set_spglib_tols</span><span class="p">(</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change the value of the tolerances `symprec` and `angle_tolerance`</span>
<span class="sd">    used to call spglib. Return old values</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This function should be called at the beginning of the script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span>
    <span class="n">old_symprec</span><span class="p">,</span> <span class="n">old_angle_tolerance</span> <span class="o">=</span> <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span>
    <span class="n">_SPGLIB_SYMPREC</span><span class="p">,</span> <span class="n">_SPGLIB_ANGLE_TOLERANCE</span> <span class="o">=</span> <span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span>
    <span class="k">return</span> <span class="n">old_symprec</span><span class="p">,</span> <span class="n">old_angle_tolerance</span>


<span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if all x is integer within the absolute tolerance atol.</span>
<span class="sd">    Use _ATOL_KDIFF is atol is None.</span>

<span class="sd">    &gt;&gt;&gt; assert is_integer([1., 2.])</span>
<span class="sd">    &gt;&gt;&gt; assert is_integer(1.01, atol=0.011)</span>
<span class="sd">    &gt;&gt;&gt; assert not is_integer([1.01, 2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">atol</span> <span class="o">=</span> <span class="n">_ATOL_KDIFF</span>
    <span class="n">int_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
    <span class="c1">#return (np.abs(int_x[0] - x[0]) &lt; atol and</span>
    <span class="c1">#        np.abs(int_x[1] - x[1]) &lt; atol and</span>
    <span class="c1">#        np.abs(int_x[2] - x[2]) &lt; atol )</span>


<div class="viewcode-block" id="issamek"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.issamek">[docs]</a><span class="k">def</span> <span class="nf">issamek</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if k1 and k2 are equal modulo a lattice vector.</span>
<span class="sd">    Use _ATOL_KDIFF is atol is None.</span>

<span class="sd">    &gt;&gt;&gt; assert issamek([1,1,1], [0,0,0])</span>
<span class="sd">    &gt;&gt;&gt; assert issamek([1.1,1,1], [0,0,0], atol=0.1)</span>
<span class="sd">    &gt;&gt;&gt; assert not issamek(0.00003, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k2</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap_to_ws"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.wrap_to_ws">[docs]</a><span class="k">def</span> <span class="nf">wrap_to_ws</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms x in its corresponding reduced number in the interval ]-1/2,1/2].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap_to_bz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.wrap_to_bz">[docs]</a><span class="k">def</span> <span class="nf">wrap_to_bz</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms x in its corresponding reduced number in the interval [0,1[.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="rc_list"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.rc_list">[docs]</a><span class="k">def</span> <span class="nf">rc_list</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">sh</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;bz&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a `ndarray` with the linear mesh used to sample one dimension of the reciprocal space.</span>
<span class="sd">    Note that the coordinates are always ordered so that rc[i+1] &gt; rc[i].</span>
<span class="sd">    so that we can easily plot quantities defined on the 3D multidimensional mesh.</span>

<span class="sd">    Args:</span>
<span class="sd">        mp:</span>
<span class="sd">            Number of Monkhorst-Pack divisions along this direction.</span>
<span class="sd">        sh:</span>
<span class="sd">            Shift</span>
<span class="sd">        pbc:</span>
<span class="sd">            if pbc is True, periodic boundary conditions are enforced.</span>
<span class="sd">        order:</span>
<span class="sd">            Possible values [&quot;bz&quot;, &quot;unit_cell&quot;].</span>
<span class="sd">            if &quot;bz&quot;, the coordinates are forced to be in [-1/2, 1/2)</span>
<span class="sd">            if &quot;unit_cell&quot;, the coordinates are forced to be in [0, 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;unit_cell&quot;</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">mp</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">pbc</span> <span class="k">else</span> <span class="n">mp</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">sh</span><span class="p">)</span> <span class="o">/</span> <span class="n">mp</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;bz&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mp</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">sh</span><span class="p">)</span> <span class="o">/</span> <span class="n">mp</span>

            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Insert xm1 in rc so that we still have a ordered list.</span>
                <span class="n">xm1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mf">1.0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">xm1</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

                <span class="n">rc</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">xm1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
            <span class="n">rc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong order </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rc</span><span class="p">)</span></div>


<div class="viewcode-block" id="kmesh_from_mpdivs"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.kmesh_from_mpdivs">[docs]</a><span class="k">def</span> <span class="nf">kmesh_from_mpdivs</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;bz&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a `ndarray` with the reduced coordinates of the</span>
<span class="sd">    k-points from the MP divisions and the shifts.</span>

<span class="sd">    Args:</span>
<span class="sd">        mpdivs: The three MP divisions.</span>
<span class="sd">        shifts: Array-like object with the MP shift.</span>
<span class="sd">        pbc: If True, periodic images of the k-points will be included i.e. closed mesh.</span>
<span class="sd">        order: &quot;unit_cell&quot; if the kpoint coordinates must be in [0,1)</span>
<span class="sd">               &quot;bz&quot; if the kpoint coordinates must be in [-1/2, +1/2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Build k-point grid.</span>
    <span class="n">kbz</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ish</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shifts</span><span class="p">):</span>
        <span class="n">rc0</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">rc1</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">rc2</span> <span class="o">=</span> <span class="n">rc_list</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">shift</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">kxyz</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">rc0</span><span class="p">,</span> <span class="n">rc1</span><span class="p">,</span> <span class="n">rc2</span><span class="p">):</span>
            <span class="n">kbz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kxyz</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kbz</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">map_bz2ibz</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">ibz</span><span class="p">,</span> <span class="n">ngkpt</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the correspondence between the list of k-points in the *unit cell*</span>
<span class="sd">    associated to the `ngkpt` mesh and the corresponding points in the IBZ.</span>
<span class="sd">    Requires structure with Abinit symmetries.</span>
<span class="sd">    This routine is mainly used to symmetrize eigenvalues in the unit cell</span>
<span class="sd">    e.g. to write BXSF files for electronic isosurfaces.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure: Structure with (Abinit) symmetry operations.</span>
<span class="sd">        ibz: [*,3] array with reduced coordinates in the in the IBZ.</span>
<span class="sd">        ngkpt: Mesh divisions.</span>
<span class="sd">        has_timrev: True if time-reversal can be used.</span>
<span class="sd">        pbc: True if the mesh should contain the periodic images (closed mesh).</span>

<span class="sd">    Returns:</span>
<span class="sd">        bz2ibz: 1d array with BZ --&gt; IBZ mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ngkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># Extract (FM) symmetry operations in reciprocal space.</span>
    <span class="n">abispg</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">abi_spacegroup</span>
    <span class="k">if</span> <span class="n">abispg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Structure does not contain the Abinit spacegroup!&quot;</span><span class="p">)</span>
    <span class="n">symrec_fm</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afm</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abispg</span><span class="o">.</span><span class="n">symrec</span><span class="p">,</span> <span class="n">abispg</span><span class="o">.</span><span class="n">symafm</span><span class="p">)</span> <span class="k">if</span> <span class="n">afm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Compute TS k_ibz.</span>
    <span class="n">bzgrid2ibz</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ik_ibz</span><span class="p">,</span> <span class="n">kibz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ibz</span><span class="p">):</span>
        <span class="n">gp_ibz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">kibz</span> <span class="o">*</span> <span class="n">ngkpt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rot</span> <span class="ow">in</span> <span class="n">symrec_fm</span><span class="p">:</span>
            <span class="n">rot_gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">gp_ibz</span><span class="p">)</span>
            <span class="n">gp_bz</span> <span class="o">=</span> <span class="n">rot_gp</span> <span class="o">%</span> <span class="n">ngkpt</span>
            <span class="n">bzgrid2ibz</span><span class="p">[</span><span class="n">gp_bz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ik_ibz</span>
            <span class="k">if</span> <span class="n">has_timrev</span><span class="p">:</span>
                <span class="n">gp_bz</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">rot_gp</span><span class="p">)</span> <span class="o">%</span> <span class="n">ngkpt</span>
                <span class="n">bzgrid2ibz</span><span class="p">[</span><span class="n">gp_bz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">gp_bz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ik_ibz</span>

    <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
        <span class="c1"># Add periodical replicas.</span>
        <span class="kn">from</span> <span class="nn">abipy.tools.numtools</span> <span class="k">import</span> <span class="n">add_periodic_replicas</span>
        <span class="n">bzgrid2ibz</span> <span class="o">=</span> <span class="n">add_periodic_replicas</span><span class="p">(</span><span class="n">bzgrid2ibz</span><span class="p">)</span>
    <span class="n">bz2ibz</span> <span class="o">=</span> <span class="n">bzgrid2ibz</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bz2ibz</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1">#for ik_bz, ik_ibz in enumerate(self.bz2ibz): print(ik_bz, &quot;&gt;&gt;&gt;&quot;, ik_ibz)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Found </span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2"> invalid entries in bz2ibz array&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">bz2ibz</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">bz2ibz</span><span class="p">))</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;This can happen if there an inconsistency between the input IBZ and ngkpt&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;ngkpt: </span><span class="si">%s</span><span class="s2">, has_timrev: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">),</span> <span class="n">has_timrev</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">bz2ibz</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for ik_bz, kbz in enumerate(bz):</span>
<span class="sd">        found = False</span>
<span class="sd">        for ik_ibz, kibz in enumerate(ibz):</span>
<span class="sd">            if found: break</span>
<span class="sd">            for symmop in structure.spacegroup:</span>
<span class="sd">                krot = symmop.rotate_k(kibz)</span>
<span class="sd">                if issamek(krot, kbz):</span>
<span class="sd">                    bz2ibz[ik_bz] = ik_ibz</span>
<span class="sd">                    found = True</span>
<span class="sd">                    break</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">has_timrev_from_kptopt</span><span class="p">(</span><span class="n">kptopt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if time-reversal symmetry can be used in the generation of the k-points in the IBZ.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kptopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kptopt</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">kptopt</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">else</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">map_kpoints</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">,</span> <span class="n">other_lattice</span><span class="p">,</span> <span class="n">ref_lattice</span><span class="p">,</span> <span class="n">ref_kpoints</span><span class="p">,</span> <span class="n">ref_symrecs</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build mapping between a list of k-points in reduced coordinates (`other_kpoints`)</span>
<span class="sd">    in the reciprocal lattice `other_lattice` and a list of reference k-points given</span>
<span class="sd">    in the reciprocal lattice `ref_lattice` with symmetry operations `ref_symrecs`.</span>

<span class="sd">    Args:</span>
<span class="sd">        other_kpoints:</span>
<span class="sd">        other_lattice: matrix whose rows are the reciprocal lattice vectors in cartesian coordinates.</span>
<span class="sd">        ref_lattice: same meaning as other_lattice.</span>
<span class="sd">        ref_kpoints:</span>
<span class="sd">        ref_symrecs: [nsym,3,3] arrays with symmetry operations in the `ref_lattice` reciprocal space.</span>
<span class="sd">        has_timrev: True if time-reversal can be used.</span>

<span class="sd">    Returns</span>
<span class="sd">        (o2r_map, nmissing)</span>

<span class="sd">        nmissing:</span>
<span class="sd">            Number of k-points in ref_kpoints that cannot be mapped onto ref_kpoints.</span>

<span class="sd">        o2r_map[i] gives the mapping  between the i-th k-point in other_kpoints and</span>
<span class="sd">            ref_kpoints. Set to None if the i-th k-point does not have any image in ref.</span>
<span class="sd">            Each entry is a named tuple with the following attributes:</span>

<span class="sd">                ik_ref:</span>
<span class="sd">                tsign:</span>
<span class="sd">                isym</span>
<span class="sd">                g0</span>

<span class="sd">            kpt_other = TS kpt_ref + G0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_gprimd_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">other_gprimd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other_lattice</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">other_kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">ref_kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ref_kpoints</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">o2r_map</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="n">tsigns</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_timrev</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="n">kmap</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;kmap&quot;</span><span class="p">,</span> <span class="s2">&quot;ik_ref, tsign, isym, g0&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ik_oth</span><span class="p">,</span> <span class="n">okpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other_kpoints</span><span class="p">):</span>
        <span class="c1"># Get other k-point in reduced coordinates in the referece lattice.</span>
        <span class="n">okpt_red</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">ref_gprimd_inv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">other_gprimd</span><span class="p">,</span> <span class="n">okpt</span><span class="p">))</span>

        <span class="c1"># k_other = TS k_ref + G0</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ik_ref</span><span class="p">,</span> <span class="n">kref</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_kpoints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span> <span class="k">break</span>
            <span class="k">for</span> <span class="n">tsign</span> <span class="ow">in</span> <span class="n">tsign</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">isym</span><span class="p">,</span> <span class="n">symrec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_symrecs</span><span class="p">):</span>
                    <span class="n">krot</span> <span class="o">=</span> <span class="n">tsign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">symrec</span><span class="p">,</span> <span class="n">kref</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">okpt_red</span><span class="p">,</span> <span class="n">krot</span><span class="p">):</span>
                        <span class="n">g0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">okpt_red</span> <span class="o">-</span> <span class="n">krot</span><span class="p">)</span>
                        <span class="n">o2r_map</span><span class="p">[</span><span class="n">ik_oth</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">ik_ref</span><span class="p">,</span> <span class="n">tsign</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="n">g0</span><span class="p">)</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">o2r_map</span><span class="p">,</span> <span class="n">o2r_map</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">KpointsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for KpointList exceptions.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="as_kpoints"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.as_kpoints">[docs]</a><span class="k">def</span> <span class="nf">as_kpoints</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert obj into a list of k-points.</span>

<span class="sd">    Args:</span>
<span class="sd">        obj: :class:`Kpoint` or list of Kpoint objects or array-like object.</span>
<span class="sd">        lattice: Reciprocal lattice.</span>
<span class="sd">        weights: k-point weights. Ignored if obj is already a `Kpoint` instance or a list</span>
<span class="sd">                 of `Kpoint` items.</span>
<span class="sd">        name: string with the name of the k-point. Ignored if obj is already a `Kpoint`</span>
<span class="sd">              instance or a list of `Kpoint` items.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># K-point?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>

    <span class="c1"># Iterable with K-points?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Kpoint</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="c1"># Assume array-like</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">)]</span>

    <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">names</span> <span class="o">=</span> <span class="n">nk</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">names</span><span class="p">)]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndim &gt; 2 is not supported&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Kpoint"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint">[docs]</a><span class="k">class</span> <span class="nc">Kpoint</span><span class="p">(</span><span class="n">SlotPickleMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class defining one k-point.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_frac_coords&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lattice&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_weight&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_hash&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            frac_coords: Reduced coordinates.</span>
<span class="sd">            lattice: :class:`Lattice` object describing the reciprocal lattice.</span>
<span class="sd">            weights: k-point weight (optional, set to zero if not given).</span>
<span class="sd">            name: string with the name of the k-point (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span> <span class="o">=</span> <span class="n">lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_weight</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">#def __array__(self, **kwargs):</span>
    <span class="c1">#    &quot;&quot;&quot;np.array(self)&quot;&quot;&quot;</span>
    <span class="c1">#    print(kwargs)</span>
    <span class="c1">#    dtype = kwargs.pop(&quot;dtype&quot;, None)</span>
    <span class="c1">#    if dtype is None:</span>
    <span class="c1">#        return self._frac_coords</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        return np.array(self._frac_coords, dtype=dtype)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kpoint objects can be used as keys in dictionaries.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The hash is computed from the fractional coordinates (floats).</span>
<span class="sd">            Hence one should avoid using hashes for implementing search algorithms</span>
<span class="sd">            in which new Kpoints are, for example generated by means of</span>
<span class="sd">            symmetry operations. This means that a dict of Kpoint objects</span>
<span class="sd">            is safe to use only when we are sure than we are going to access</span>
<span class="sd">            its entries with the *same* keys used to generate the dict!.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reciprocal lattice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Weight of the k-point. 0.0 if the weight is not defined.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span>

<div class="viewcode-block" id="Kpoint.set_weight"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.set_weight">[docs]</a>    <span class="k">def</span> <span class="nf">set_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the weight of the k-point.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="o">=</span> <span class="n">weight</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cart_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cartesian coordinates of the k-point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the k-point. None if not available.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

<div class="viewcode-block" id="Kpoint.set_name"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.set_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the k-point.&quot;&quot;&quot;</span>
        <span class="c1"># Fix typo in Latex syntax (if any).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">):</span> <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">on_border</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the k-point is on the border of the BZ  (lattice translations are taken into account).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kreds</span> <span class="o">=</span> <span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kreds</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">_ATOL_KDIFF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span>  <span class="s2">&quot;[</span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, name=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, weight=</span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="c1"># Kpoint algebra.</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Comparison between two Kpoint objects</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Kpoint vs iterable (e.g. list)</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Kpoint.as_kpoint"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.as_kpoint">[docs]</a>    <span class="k">def</span> <span class="nf">as_kpoint</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into a Kpoint instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj:</span>
<span class="sd">                :class:`Kpoint` instance or array-like with the reduced coordinates.</span>
<span class="sd">            lattice:</span>
<span class="sd">                :class:`Lattice` object defining the reciprocal lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Kpoint.gamma"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.gamma">[docs]</a>    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for the Gamma point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;$\Gamma$&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.copy"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Norm of the kpoint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">))</span>

<div class="viewcode-block" id="Kpoint.versor"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.versor">[docs]</a>    <span class="k">def</span> <span class="nf">versor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the versor i.e. ||k|| = 1&quot;&quot;&quot;</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.wrap_to_ws"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.wrap_to_ws">[docs]</a>    <span class="k">def</span> <span class="nf">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new `Kpoint` in the Wigner-Seitz zone.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">wrap_to_ws</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.wrapt_to_bz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.wrapt_to_bz">[docs]</a>    <span class="k">def</span> <span class="nf">wrapt_to_bz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new `Kpoint` in the first unit cell.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">wrap_to_bz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpoint.compute_star"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpoint.compute_star">[docs]</a>    <span class="k">def</span> <span class="nf">compute_star</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmops</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the star of the kpoint (tuple of `Kpoint` objects).&quot;&quot;&quot;</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symmops</span><span class="p">:</span>
            <span class="n">sk_coords</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="n">wrap_tows</span><span class="p">)</span>

            <span class="c1"># Add it only if it&#39;s not already in the list.</span>
            <span class="k">for</span> <span class="n">prev_coords</span> <span class="ow">in</span> <span class="n">frac_coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">sk_coords</span><span class="p">,</span> <span class="n">prev_coords</span><span class="p">):</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sk_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KpointStar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">])</span></div></div>


<span class="k">class</span> <span class="nc">KpointList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining a sequence of :class:`Kpoint` objects. Essentially consists</span>
<span class="sd">    of base methods implementing the sequence protocol and helper functions.</span>
<span class="sd">    The subclasses `Kpath` and `IrredZone` provide specialized methods to operate</span>
<span class="sd">    on k-points representing a path or list of points in the IBZ, respectively.</span>

<span class="sd">    .. Note:</span>

<span class="sd">        Algorithms usually need to know what kind of sampling we are using.</span>
<span class="sd">        The test can be easily implemented with:</span>

<span class="sd">        if kpoints.is_path:</span>
<span class="sd">            # code specific to k-paths.</span>

<span class="sd">        elif kpoints.is_ibz:</span>
<span class="sd">            # code specific to IBZ sampling.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">KpointsError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">subclass_from_name</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the class with the given name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="n">c</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find subclass associated to name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Kpoints obey the general json interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reciprocal_lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;reciprocal_lattice&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;frac_coords&quot;</span><span class="p">],</span>
                   <span class="n">weights</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">],</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;ksampling&quot;</span><span class="p">])</span>

    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes Kpoints obey the general json interface used in pymatgen for easier serialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">reciprocal_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="n">frac_coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
            <span class="n">ksampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            reciprocal_lattice: :class:`Lattice` object.</span>
<span class="sd">            frac_coords: Array-like object with the reduced coordinates of the k-points.</span>
<span class="sd">            weights: List of k-point weights. If None, weights are initialized with zeros.</span>
<span class="sd">            names: List of k-point names.</span>
<span class="sd">            ksampling: Info on the k-point sampling (used for homogeneous meshes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reciprocal_lattice</span> <span class="o">=</span> <span class="n">reciprocal_lattice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span> <span class="o">=</span> <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span> <span class="o">=</span> <span class="n">ksampling</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(weights) != len(frac_coords):</span><span class="se">\n</span><span class="s2">weights: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">frac_coords: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">))</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(names) != len(frac_coords):</span><span class="se">\n</span><span class="s2">names: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">frac_coords: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rcs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Kpoint</span><span class="p">(</span><span class="n">rcs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the object from file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">KpointsReader</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_kpoints</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only netcdf files are supported.&quot;</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`Lattice` object defining the reciprocal lattice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reciprocal_lattice</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">) </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">kpoint</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">) </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">kpoint</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="c1"># Sequence protocol.</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>

    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">__reversed__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot merge k-points with different reciprocal lattice.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KpointList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span>
                          <span class="n">frac_coords</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">],</span>
                          <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">],</span>
                        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">KpointList</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k1</span> <span class="o">!=</span> <span class="n">k2</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns: the first index of kpoint in self.</span>

<span class="sd">        Raises: ValueError if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find point: </span><span class="si">%s</span><span class="s2"> in KpointList:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">kpoint</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns: first index of kpoint. -1 if not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of occurrences of kpoint&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the closest k-point in the list (not necessarily equal).</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: Fractional coordinates or :class:`Kpoint` instance.</span>

<span class="sd">        Return:</span>
<span class="sd">            (ind, kpoint, dist)</span>

<span class="sd">            where `ind` is the index in self of the closest k-point.</span>
<span class="sd">            `kpoint` is the :class:`Kpoint` instance of index `ind`.</span>
<span class="sd">            dist is the distance between `obj` and `kpoint`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Kpoint</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">lattice</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Kpoint list and Kpoint object have different lattices!&quot;</span><span class="p">)</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">kpt</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">)</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ind</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self represents a path in the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Kpath</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self represents a list of points in the IBZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">IrredZone</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">mpdivs_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Monkhorst-Pack (MP) divisions and shifts.</span>
<span class="sd">        Both quantities are set to None if self is not a MP mesh.</span>
<span class="sd">        Use `is_mpmesh` to check whether self is a MP mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ibz</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Test if kptrlatt is diagonal.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptrlatt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptrlatt</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">shifts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_mpmesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if self represents a Monkhorst-Pack mesh.</span>
<span class="sd">        i.e if the sampling has been specified in terms of divisions</span>
<span class="sd">        along the reciprocal lattice vectors (ngkpt)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpdivs_shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-point as `ndarray` of shape (len(self), 3)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frac_coords</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with the name of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`ndarray` with the weights of the k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kpoint</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">sum_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the sum of the weights.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_duplicated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove duplicated k-points from self. Returns new KpointList instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frac_coords</span><span class="p">,</span> <span class="n">good_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Add it only if it&#39;s not already in the list.</span>
            <span class="k">for</span> <span class="n">prev_coords</span> <span class="ow">in</span> <span class="n">frac_coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">prev_coords</span><span class="p">):</span> <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                <span class="n">good_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">good_kpoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">good_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span>
                <span class="n">frac_coords</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">good_kpoints</span><span class="p">],</span>
                <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">good_kpoints</span><span class="p">],</span>
                <span class="n">ksampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a `ndarray` [nkpy, 3] with the fractional coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a json string representation of the MSONable object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span> <span class="n">cls</span><span class="o">=</span><span class="n">MontyEncoder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pymatgen.electronic_structure.plotter</span> <span class="k">import</span> <span class="n">plot_brillouin_zone</span>
        <span class="n">fold</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_path</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
            <span class="n">frac_coords_lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">plot_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="n">frac_coords_lines</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                                       <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not sure this works, I got points outside of the BZ in a simple with Si and Gamm-centered 8x8x8.</span>
            <span class="c1"># Don&#39;t know if it&#39;s a bug in matplotlib or plot_brillouin_zone.</span>
            <span class="c1">#print(self.frac_coords)</span>
            <span class="k">return</span> <span class="n">plot_brillouin_zone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">kpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                                       <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">KpointStar</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Star of the kpoint. Note that the first k-point is assumed to be the base</span>
<span class="sd">    of the star namely the point that is used to generate the Star.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The point used to generate the star.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the star (inherited from the name of the base point).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_point</span><span class="o">.</span><span class="n">name</span>


<div class="viewcode-block" id="Kpath"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath">[docs]</a><span class="k">class</span> <span class="nc">Kpath</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object describes a k-path in reciprocal space.</span>
<span class="sd">    It provides methods to compute (line) derivatives along the path.</span>
<span class="sd">    The k-points do not have weights so Kpath should not be used to compute integral in the BZ.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Kpath.from_vertices_and_names"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.from_vertices_and_names">[docs]</a>    <span class="k">def</span> <span class="nf">from_vertices_and_names</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">vertices_names</span><span class="p">,</span> <span class="n">line_density</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate K-path from a list of vertices and the corresponding labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: Structure object.</span>
<span class="sd">            vertices_names:  List of tuple, each tuple is of the form (kfrac_coords, kname) where</span>
<span class="sd">                kfrac_coords are the reduced coordinates of the k-point and kname is a string with the name of</span>
<span class="sd">                the k-point. Each point represents a vertex of the k-path.</span>
<span class="sd">            line_density: Number of points used to sample the smallest segment of the path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gmet</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">metric_tensor</span>
        <span class="n">vnames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">vn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">]</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">vn</span> <span class="ow">in</span> <span class="n">vertices_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="n">dl_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k0</span>
            <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dk</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">gmet</span><span class="p">,</span> <span class="n">dk</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">dl_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>

        <span class="n">dl_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dl_vals</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="n">fact</span> <span class="o">=</span> <span class="n">dl_min</span> <span class="o">/</span> <span class="n">line_density</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="n">knames</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">dl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dl_vals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dl</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">numk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">dl</span> <span class="o">/</span> <span class="n">fact</span><span class="p">))</span>
            <span class="n">k0</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
            <span class="n">dk</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k0</span>
            <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnames</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numk</span><span class="p">):</span>
                <span class="n">next_k</span> <span class="o">=</span> <span class="n">k0</span> <span class="o">+</span> <span class="n">dk</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">/</span> <span class="n">numk</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">knames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vnames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span>
                   <span class="n">frac_coords</span><span class="o">=</span><span class="n">frac_coords</span><span class="p">,</span>
                   <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">names</span><span class="o">=</span><span class="n">knames</span><span class="p">,</span>
                   <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Kpath.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        Args:</span>
<span class="sd">            verbose: Verbosity level. Default: 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;K-path contains </span><span class="si">%s</span><span class="s2"> lines. Number of k-points in each line: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">),</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]))</span>
        <span class="c1">#for i, line in enumerate(self.lines):</span>
        <span class="c1">#    app(&quot;line %d: %s&quot; % (i, line))</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

        <span class="n">vids</span> <span class="o">=</span> <span class="p">{</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">}</span>

        <span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;Idx&quot;</span><span class="p">,</span> <span class="s2">&quot;Frac_coords&quot;</span><span class="p">,</span> <span class="s2">&quot;Name&quot;</span><span class="p">,</span> <span class="s2">&quot;ds&quot;</span><span class="p">,</span> <span class="s2">&quot;Vert&quot;</span><span class="p">,]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vids</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="s2">&quot;</span><span class="si">%.5f</span><span class="s2">, </span><span class="si">%.5f</span><span class="s2">, </span><span class="si">%.5f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vids</span> <span class="k">else</span> <span class="s2">&quot; &quot;</span><span class="p">,</span>
            <span class="p">])</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">header</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">tabulate</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s2">&quot;firstrow&quot;</span><span class="p">)])</span></div>

    <span class="nd">@lazy_property</span>
<div class="viewcode-block" id="Kpath.ds"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.ds">[docs]</a>    <span class="k">def</span> <span class="nf">ds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        numpy array of len(self)-1 elements giving the distance between two</span>
<span class="sd">        consecutive k-points, i.e. ds[i] = ||k[i+1] - k[i]|| for i=0,1,...,n-1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kpoint</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span>
        <span class="k">return</span> <span class="n">ds</span></div>

    <span class="nd">@lazy_property</span>
<div class="viewcode-block" id="Kpath.versors"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.versors">[docs]</a>    <span class="k">def</span> <span class="nf">versors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tuple of len(self)-1 elements with the versors connecting k[i] to k[i+1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">versors</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">versors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kpt</span><span class="p">)</span><span class="o">.</span><span class="n">versor</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">versors</span><span class="p">)</span></div>

    <span class="nd">@lazy_property</span>
<div class="viewcode-block" id="Kpath.lines"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.lines">[docs]</a>    <span class="k">def</span> <span class="nf">lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Nested list containing the indices of the points belonging to the same line.</span>
<span class="sd">        Used for extracting the eigenvalues while looping over the lines.</span>

<span class="sd">        Example:</span>

<span class="sd">            for line in self.lines:</span>
<span class="sd">                vals_on_line = eigens[spin, line, band]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">versors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">versors</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                <span class="c1">#print(&quot;diff&quot;, v.frac_coords - prev.frac_coords)</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">v</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kpath.finite_diff"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Kpath.finite_diff">[docs]</a>    <span class="k">def</span> <span class="nf">finite_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the derivatives of values by finite differences.</span>

<span class="sd">        Args:</span>
<span class="sd">            values: array-like object with shape=(nkpt) containing the values of the path.</span>
<span class="sd">            order: Order of the derivative.</span>
<span class="sd">            acc: Accuracy: 4 corresponds to a central difference with 5 points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ragged numpy array. The i-th entry is a numpy array with the derivatives</span>
<span class="sd">            on the i-th line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Loop over the lines of the path, extract the data on the line and</span>
        <span class="c1"># differentiate f(s) where s is the distance between two consecutive points along the line.</span>
        <span class="n">ders_on_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
            <span class="n">vals_on_line</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">line</span><span class="p">]</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For finite difference derivatives, the path must be homogeneous!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                                 <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>

            <span class="n">der</span> <span class="o">=</span> <span class="n">finite_diff</span><span class="p">(</span><span class="n">vals_on_line</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">acc</span><span class="p">)</span>
            <span class="n">ders_on_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">der</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ders_on_lines</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IrredZone"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone">[docs]</a><span class="k">class</span> <span class="nc">IrredZone</span><span class="p">(</span><span class="n">KpointList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :class:`IrredZone` is a (immutable) sequence of points in the irreducible wedge of the BZ.</span>
<span class="sd">    Each point has a weight whose sum must equal 1 so that we can integrate quantities in the full Brillouin zone.</span>

<span class="sd">    .. note::</span>

<span class="sd">            Abinit supports different options for the specification of the BZ sampling:</span>

<span class="sd">                 - kptrlatt(3,3) or ngkpt(3) for the definition grid.</span>
<span class="sd">                 - shiftk(3, nshiftk) for the definition of multiple shifts.</span>
<span class="sd">                 - `kptopt` for the treatment of symmetry operations.</span>

<span class="sd">            All these possibilities complicate the internal implementation in particular when</span>
<span class="sd">            we need to recostruct the full BZ and take into account the presence of multiple shifts</span>
<span class="sd">            since kptrlatt may have non-zero off-diagonal components. Client code that needs to know</span>
<span class="sd">            how the mesh was generated can rely on the following checks:</span>

<span class="sd">            if not self.ibz: raise(&quot;Need an IBZ sampling&quot;)</span>

<span class="sd">            mpdivs, shifts = self.mpdivs_shifts</span>
<span class="sd">            if mpdivs is None: raise ValueError(&quot;Cannot handle kptrlatt with non-zero off-diagonal elements&quot;)</span>
<span class="sd">            if len(shifts) &gt; 1: raise ValueError(&quot;Multiple shifts are not supported&quot;)</span>
<span class="sd">            # Code for mesh defined in terms of mpdivs and one shift.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            reciprocal_lattice: :class:`Lattice` object</span>
<span class="sd">            frac_coords: Array-like object with the reduced coordinates of the points.</span>
<span class="sd">            weights: Array-like with the weights of the k-points.</span>
<span class="sd">            names: List with the name of the k-points.</span>
<span class="sd">            ksampling: Info on the k-point sampling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IrredZone</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span>
                                        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>

        <span class="c1"># Weights must be normalized to one.</span>
        <span class="n">wsum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_weights</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wsum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.e-6</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The list of kpoints does not represent a homogeneous sampling of the BZ</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="s2">&quot;Kpoint weights should sum up to one while sum_weights is </span><span class="si">%.3f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">wsum</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="c1">#raise ValueError(err_msg)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="IrredZone.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.IrredZone.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_mpmesh</span><span class="p">:</span>
            <span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpdivs_shifts</span>
            <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">, </span><span class="si">%.1f</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;K-mesh with divisions: </span><span class="si">%s</span><span class="s2">, shifts: </span><span class="si">%s</span><span class="s2">, kptopt: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">kptopt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ksampling</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">app</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div></div>

    <span class="c1">#@property</span>
    <span class="c1">#def len_bz(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Number of points in the full BZ.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.mpdivs.prod() * self.num_shifts</span>

    <span class="c1">#def iter_bz_coords(self):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Generates the fractional coordinates of the points in the BZ.</span>
    <span class="c1">#    .. note:</span>
    <span class="c1">#        points are ordered in blocks, one block for each shift.</span>
    <span class="c1">#        Inside the block, points are ordered following the C convention.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    for shift in self.shifts:</span>
    <span class="c1">#        for i in range(mpdivs[0]):</span>
    <span class="c1">#            x = (i + shift[0]) / mpdivs[0]</span>
    <span class="c1">#            for j in range(mpdivs[1]):</span>
    <span class="c1">#                y = (j + shift[1]) / mpdivs[1]</span>
    <span class="c1">#                for k in range(mpdivs[2]):</span>
    <span class="c1">#                    z = (k + shift[2]) / mpdivs[2]</span>
    <span class="c1">#                    yield np.array((x, y, z))</span>

    <span class="c1">#def plane_cut(self, values_ibz):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Symmetrize values in the IBZ to have them on the full BZ, then</span>
    <span class="c1">#    select a slice along the specified plane E.g. plane = (1,1,0).</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    assert len(values_ibz) == len(self)</span>
    <span class="c1">#    #indices =</span>
    <span class="c1">#    z0 = 0</span>
    <span class="c1">#    plane = np.empty((self.nx, self.ny))</span>
    <span class="c1">#    kx, ky = range(self.nx), range(self.ny)</span>
    <span class="c1">#    for x in kx:</span>
    <span class="c1">#        for y in ky:</span>
    <span class="c1">#            ibz_idx = self.map_xyz2ibz[x, y, z0]</span>
    <span class="c1">#            plane[x, y] = values_ibz[ibz_idx]</span>
    <span class="c1">#    kx, ky = np.meshgrid(kx, ky)</span>
    <span class="c1">#    return kx, ky, plane</span>


<span class="k">class</span> <span class="nc">KSamplingInfo</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store metadata defining the k-point sampling according to the abinit conventions.</span>
<span class="sd">    One should pass through one of the class methods to instanciate the class,</span>
<span class="sd">    avoid calling __init__ directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">KNOWN_KEYS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
        <span class="s2">&quot;mpdivs&quot;</span><span class="p">,</span>          <span class="c1"># Mesh divisions. Defined only if we have a sampling with diagonal kptrlatt else None</span>
        <span class="s2">&quot;kptrlatt&quot;</span><span class="p">,</span>        <span class="c1"># [3,3] matrix defined only if we have a sampling else None</span>
        <span class="s2">&quot;kptrlatt_orig&quot;</span><span class="p">,</span>   <span class="c1"># Original set of shifts. Defined only if we have a sampling else None</span>
        <span class="s2">&quot;shifts&quot;</span><span class="p">,</span>          <span class="c1"># Actual shifts (Usually one). Defined only if we have a sampling else None</span>
        <span class="s2">&quot;shifts_orig&quot;</span><span class="p">,</span>     <span class="c1"># Original shifts specified by the user. Defined only if we have a sampling else None</span>
        <span class="s2">&quot;kptopt&quot;</span>           <span class="c1"># Options for k-point generation. Negative if we have a k-path (nbounds - 1)</span>
    <span class="p">])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mpdivs</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Homogeneous sampling specified in terms of `mpdivs` (ngkpt in abinit),</span>
<span class="sd">        the set of `shifts` and the value of `kptopt`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="n">kptrlatt_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mpdivs</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kptrlatt</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">kptrlatt</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">kptopt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Homogeneous sampling specified in terms of `kptrlatt`</span>
<span class="sd">        the set of `shifts` and the value of `kptopt`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="n">kptrlatt_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Test if kptrlatt is diagonal.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kptrlatt</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mpdivs</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">kptrlatt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_kbounds</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">kbounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Metadata associated to a k-path specified in terms of boundaries.&quot;&quot;&quot;</span>
        <span class="n">mpdivs</span><span class="p">,</span> <span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kbounds</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Note -1</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">mpdivs</span><span class="o">=</span><span class="n">mpdivs</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span> <span class="n">shifts_orig</span><span class="o">=</span><span class="n">shifts_orig</span><span class="p">,</span>
                   <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span> <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="n">kptrlatt_orig</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KSamplingInfo</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
           <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KNOWN_KEYS</span><span class="p">:</span>
               <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknow key </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

    <span class="c1">#def __str__(self):</span>
    <span class="c1">#    lines = []</span>
    <span class="c1">#    app = lines.append</span>
    <span class="c1">#    return &quot;\n&quot;.join(lines)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_homogeneous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we have a homogeneous sampling of the BZ.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpdivs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptrlatt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">kptopt</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1">#@property</span>
    <span class="c1">#def sampling_with_diagonal_kptrlatt(self)</span>
    <span class="c1">#    if self.kptrlatt is None: return False</span>
    <span class="c1">#    # Test if kptrlatt is diagonal.</span>
    <span class="c1">#    m = self.kptrlatt.copy()</span>
    <span class="c1">#    np.fill_diagonal(m, 0)</span>
    <span class="c1">#    if np.any(m != 0): return False</span>
    <span class="c1">#    return True</span>

    <span class="c1">#@property</span>
    <span class="c1">#def is_path(self):</span>
    <span class="c1">#    &quot;&quot;&quot;True if we have a path in the BZ.&quot;&quot;&quot;</span>
    <span class="c1">#    return self.kptopt &lt; 0</span>


<span class="k">class</span> <span class="nc">KpointsReaderMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class that provides methods for reading k-point data from a netcdf</span>
<span class="sd">    file written according to the ETSF-IO specifications.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">read_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory function: returns an instance of [Kpath, IrredZone]</span>
<span class="sd">        depending on the content of the Netcdf file. Main entry point for client code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_structure</span><span class="p">()</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kfrac_coords</span><span class="p">()</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kweights</span><span class="p">()</span>
        <span class="n">ksampling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_ksampling_info</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ksampling</span><span class="o">.</span><span class="n">kptopt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We have a path in the BZ.</span>
            <span class="n">kpath</span> <span class="o">=</span> <span class="n">Kpath</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kpoint</span> <span class="ow">in</span> <span class="n">kpath</span><span class="p">:</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">findname_in_hsym_stars</span><span class="p">(</span><span class="n">kpoint</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">kpath</span>

        <span class="c1"># FIXME</span>
        <span class="c1"># Quick and dirty hack to allow the reading of the k-points from WFK files</span>
        <span class="c1"># where info on the sampling is missing. I will regret it but at present</span>
        <span class="c1"># is the only solution I found (changes in the ETSF-IO part of Abinit are needed)</span>
        <span class="c1">#if ksampling.is_homogeneous or abs(sum(weights) - 1.0) &lt; 1.e-6:</span>
        <span class="c1">#if np.any(ksampling.kptrlatt_orig != 0) or abs(sum(weights) - 1.0) &lt; 1.e-6:</span>

        <span class="c1">#if np.any(ksampling.kptrlatt_orig != 0):</span>
        <span class="c1"># We have a homogeneous sampling of the BZ.</span>
        <span class="k">return</span> <span class="n">IrredZone</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">ksampling</span><span class="o">=</span><span class="n">ksampling</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
          <span class="s2">&quot;Only homogeneous samplings or paths are supported!&quot;</span>
          <span class="s2">&quot;ksamping info:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">ksampling</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">read_ksampling_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># FIXME: in v8.0, the SIGRES files does not have kptopt, kptrlatt_orig and shiftk_orig</span>
        <span class="n">kptrlatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kptrlatt</span><span class="p">()</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_kshifts</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">KSamplingInfo</span><span class="p">(</span>
            <span class="n">mpdivs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_kmpdivs</span><span class="p">(),</span>
            <span class="n">kptrlatt</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">,</span>
            <span class="n">kptrlatt_orig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptrlatt_orig&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">kptrlatt</span><span class="p">),</span>
            <span class="n">shifts</span><span class="o">=</span><span class="n">shifts</span><span class="p">,</span>
            <span class="n">shifts_orig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;shiftk_orig&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">shifts</span><span class="p">),</span>
            <span class="n">kptopt</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptopt&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kfrac_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fractional coordinates of the k-points&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kweights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the weight of the k-points. None if not found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_weights&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kshifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the shifts of the k-mesh in reduced coordinates. None if not found.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;shiftk&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_grid_shift&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kmpdivs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the Monkhorst-Pack divisions defining the mesh. None if not found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;monkhorst_pack_folding&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_kptrlatt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns ABINIT variable kptrlatt. None if not found.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptrlatt&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kpoint_grid_vectors&quot;</span><span class="p">)</span>

    <span class="c1">#@returns_None_onfail</span>
    <span class="c1">#def read_kptopt(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Returns the ABINIT variable kptopt. None if not found.&quot;&quot;&quot;</span>
    <span class="c1">#    return int(self.read_value(&quot;kptopt&quot;))</span>


<span class="k">class</span> <span class="nc">KpointsReader</span><span class="p">(</span><span class="n">ETSF_Reader</span><span class="p">,</span> <span class="n">KpointsReaderMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This object reads k-point data from a netcdf file.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Ktables"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables">[docs]</a><span class="k">class</span> <span class="nc">Ktables</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call spglib to compute the k-points in the IBZ with the corresponding weights</span>
<span class="sd">    as well as the mapping BZ --&gt; IBZ.</span>

<span class="sd">    Args:</span>
<span class="sd">        mesh:</span>
<span class="sd">        is_shift:</span>

<span class="sd">    Attributes:</span>

<span class="sd">        mesh</span>
<span class="sd">        is_shift</span>
<span class="sd">        ibz:</span>
<span class="sd">        nibz</span>
<span class="sd">        weights:</span>
<span class="sd">        bz:</span>
<span class="sd">        nbz</span>
<span class="sd">        grid:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">is_shift</span><span class="p">,</span> <span class="n">has_timrev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            structure</span>
<span class="sd">            mesh</span>
<span class="sd">            is_shift</span>
<span class="sd">            has_timrev</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">spglib</span> <span class="k">as</span> <span class="nn">spg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_shift</span> <span class="o">=</span> <span class="n">is_shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span> <span class="o">=</span> <span class="n">has_timrev</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">atomic_numbers</span><span class="p">)</span>

        <span class="n">mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">spg</span><span class="o">.</span><span class="n">get_ir_reciprocal_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span>
            <span class="n">is_shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_shift</span><span class="p">,</span> <span class="n">is_time_reversal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">_SPGLIB_SYMPREC</span><span class="p">)</span>

        <span class="n">uniq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nibz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_shift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">is_shift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">uniq</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bz</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">)</span>

        <span class="c1"># All k-points and mapping to ir-grid points.</span>
        <span class="c1"># FIXME This is slow.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik_bz</span><span class="p">,</span> <span class="n">ir_gp_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">uniq</span> <span class="o">==</span> <span class="n">ir_gp_id</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span><span class="p">[</span><span class="n">ik_bz</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="Ktables.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;mesh </span><span class="si">%s</span><span class="s2">, shift </span><span class="si">%s</span><span class="s2">, time-reversal: </span><span class="si">%s</span><span class="s2">, Irred points: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timrev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nibz</span><span class="p">))</span>

        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Irreducible k-points with number of points in star:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">], nstar: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbz</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ktables.print_bz2ibz"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.kpoints.Ktables.print_bz2ibz">[docs]</a>    <span class="k">def</span> <span class="nf">print_bz2ibz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print BZ --&gt; IBZ mapping.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BZ points --&gt; IBZ points&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik_bz</span><span class="p">,</span> <span class="n">ik_ibz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bz2ibz</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%6d</span><span class="s2">) [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">], ====&gt; </span><span class="si">%6d</span><span class="s2">) [</span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">, </span><span class="si">%9.6f</span><span class="s2">],&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">ik_bz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">ik_ibz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ibz</span><span class="p">[</span><span class="n">ik_ibz</span><span class="p">][</span><span class="mi">2</span><span class="p">]),</span> <span class="n">file</span><span class="o">=</span><span class="n">file</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, The ABINIT group.
      Last updated on Mar 09, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>