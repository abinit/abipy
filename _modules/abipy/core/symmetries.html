<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>abipy.core.symmetries &#8212; abipy 0.8.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/my_style.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          abipy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.8.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../features.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Getting AbiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../zzbiblio.html">Bibliography</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../graphical_interface.html">Graphical interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">AbiPy Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../postprocessing_howto.html">Post-processing How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/taskmanager.html">TaskManager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows/manager_examples.html">Manager Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flow_gallery/index.html">Flow Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../flows_howto.html">Flows How-To</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../coding_guide.html">Coding guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../README.html">Documenting AbiPy</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for abipy.core.symmetries</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;Objects used to deal with symmetry operations in crystals.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">spglib</span>

<span class="kn">from</span> <span class="nn">monty.string</span> <span class="kn">import</span> <span class="n">is_string</span>
<span class="kn">from</span> <span class="nn">monty.itertools</span> <span class="kn">import</span> <span class="n">iuptri</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="kn">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">monty.termcolor</span> <span class="kn">import</span> <span class="n">cprint</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="kn">import</span> <span class="n">dict2namedtuple</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="kn">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.serialization</span> <span class="kn">import</span> <span class="n">SlotPickleMixin</span>
<span class="kn">from</span> <span class="nn">abipy.core.kpoints</span> <span class="kn">import</span> <span class="n">wrap_to_ws</span><span class="p">,</span> <span class="n">issamek</span><span class="p">,</span> <span class="n">has_timrev_from_kptopt</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;LatticeRotation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AbinitSpaceGroup&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span> <span class="nf">wrap_in_ucell</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms x in its corresponding reduced number in the interval [0,1[.&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if all x is integer within the absolute tolerance atol.</span>

<span class="sd">    &gt;&gt;&gt; is_integer([1., 2.])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_integer(1.01, atol=0.011)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_integer([1.01, 2])</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">int_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">int_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mati3inv</span><span class="p">(</span><span class="n">mat3</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invert and transpose orthogonal 3x3 matrix of INTEGER elements.</span>

<span class="sd">    Args:</span>
<span class="sd">        mat3: (3, 3) matrix-like object with integer elements</span>

<span class="sd">    Returns:</span>
<span class="sd">        |numpy-array| with the TRANSPOSE of the inverse of mat3 if trans==True.</span>
<span class="sd">        If trans==False, the inverse of mat3 is returned.</span>

<span class="sd">    .. note::</span>

<span class="sd">       Used for symmetry operations. This function applies to *ORTHOGONAL* matrices only.</span>
<span class="sd">       Since these form a group, inverses are also integer arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mat3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

    <span class="n">mit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mit</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">dd</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mit</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mit</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat3</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mit</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Make sure matrix is not singular</span>
    <span class="k">if</span> <span class="n">dd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Attempting to invert integer array: </span><span class="si">%s</span><span class="se">\n</span><span class="s2"> ==&gt; determinant is zero.&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">mat3</span><span class="p">))</span>

    <span class="n">mit</span> <span class="o">=</span> <span class="n">mit</span> <span class="o">//</span> <span class="n">dd</span>
    <span class="k">if</span> <span class="n">trans</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mit</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_det</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the determinant of a 3x3 rotation matrix mat.</span>

<span class="sd">    raises:</span>
<span class="sd">        ValueError if abs(det) != 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">det</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>\
        <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>\
        <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Determinant must be +-1 while it is </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">det</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">det</span>


<span class="k">def</span> <span class="nf">indsym_from_symrel</span><span class="p">(</span><span class="n">symrel</span><span class="p">,</span> <span class="n">tnons</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">tolsym</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each symmetry operation, find the number of the position to</span>
<span class="sd">    which each atom is sent in the unit cell by the INVERSE of the</span>
<span class="sd">    symmetry operation inv(symrel); i.e. this is the atom which, when acted</span>
<span class="sd">    upon by the given symmetry element isym, gets transformed into atom iatom.</span>
<span class="sd">    indirect indexing array for atoms, see symatm.F90.</span>

<span class="sd">    $ R^{-1} (xred(:,iat) - \tau) = xred(:,iat_sym) + R_0 $</span>
<span class="sd">    * indsym(4,  isym,iat) gives iat_sym in the original unit cell.</span>
<span class="sd">    * indsym(1:3,isym,iat) gives the lattice vector $R_0$.</span>

<span class="sd">    Args:</span>
<span class="sd">        symrel: int (nsym,3,3) array with real space symmetries expressed in reduced coordinates.</span>
<span class="sd">        tnons: float (nsym, 3) array with nonsymmorphic translations for each symmetry.</span>
<span class="sd">        structure: |Structure| object.</span>
<span class="sd">        tolsym: tolerance for the symmetries</span>

<span class="sd">    Returns:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="n">nsym</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symrel</span><span class="p">)</span>
    <span class="n">xred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">typat</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structure</span><span class="p">)}</span>

    <span class="n">rm1_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">symrel</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsym</span><span class="p">):</span>
        <span class="n">rm1_list</span><span class="p">[</span><span class="n">isym</span><span class="p">]</span> <span class="o">=</span> <span class="n">mati3inv</span><span class="p">(</span><span class="n">symrel</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span> <span class="n">trans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Start testmn out at large value</span>
    <span class="n">testmn</span> <span class="o">=</span> <span class="mi">1000000</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">indsym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">natom</span><span class="p">,</span> <span class="n">nsym</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

    <span class="c1"># Implementation is similar to Abinit routine (including the order of the loops)</span>
    <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsym</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iatom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">):</span>
            <span class="n">tratm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rm1_list</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span> <span class="n">xred</span><span class="p">[</span><span class="n">iatom</span><span class="p">]</span> <span class="o">-</span> <span class="n">tnons</span><span class="p">[</span><span class="n">isym</span><span class="p">])</span>
            <span class="c1"># Loop through atoms, when types agree, check for agreement after primitive translation</span>
            <span class="k">for</span> <span class="n">jatm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">typat</span><span class="p">[</span><span class="n">jatm</span><span class="p">]</span> <span class="o">!=</span> <span class="n">typat</span><span class="p">[</span><span class="n">iatom</span><span class="p">]:</span> <span class="k">continue</span>
                <span class="n">test_vec</span> <span class="o">=</span> <span class="n">tratm</span> <span class="o">-</span> <span class="n">xred</span><span class="p">[</span><span class="n">jatm</span><span class="p">]</span>
                <span class="c1"># Find nearest integer part of difference</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">test_vec</span><span class="p">)</span>
                <span class="c1"># Check whether, after translation, they agree</span>
                <span class="n">test_vec</span> <span class="o">=</span> <span class="n">test_vec</span> <span class="o">-</span> <span class="n">trans</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">test_vec</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c1"># Abinit uses 1e-10 but python seems to require a slightly larger value.</span>
                <span class="c1">#if diff &lt; 1e-10:</span>
                <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                    <span class="n">difmin</span> <span class="o">=</span> <span class="n">test_vec</span>
                    <span class="n">indsym</span><span class="p">[</span><span class="n">iatom</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
                    <span class="n">indsym</span><span class="p">[</span><span class="n">iatom</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jatm</span>
                    <span class="c1"># Break out of loop when agreement is within tolerance</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Keep track of smallest difference if greater than tol10</span>
                    <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">testmn</span><span class="p">:</span>
                        <span class="n">testmn</span> <span class="o">=</span> <span class="n">diff</span>
                        <span class="c1"># Note that abs() is not taken here</span>
                        <span class="n">difmin</span> <span class="o">=</span> <span class="n">test_vec</span>
                        <span class="n">indsym</span><span class="p">[</span><span class="n">iatom</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
                        <span class="n">indsym</span><span class="p">[</span><span class="n">iatom</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">jatm</span>

        <span class="c1"># Keep track of maximum difference between transformed coordinates and nearest &quot;target&quot; coordinate</span>
        <span class="n">difmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">difmin</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">err</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">difmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">difmax</span> <span class="o">&gt;</span> <span class="n">tolsym</span><span class="p">:</span>
            <span class="n">cprint</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Trouble finding symmetrically equivalent atoms.</span>
<span class="s2">Applying inverse of symm number </span><span class="si">{isym}</span><span class="s2"> to atom number </span><span class="si">{iatom}</span><span class="s2"> of typat&#39;,typat(iatom) gives tratom=&#39;,tratom(1:3)</span>
<span class="s2">This is further away from every atom in crystal than the allowed tolerance.</span>
<span class="s2">The inverse symmetry matrix is&#39;,symrec(1,1:3,isym),ch10,&amp;</span>
<span class="s2">                               &#39;,symrec(2,1:3,isym),ch10,&amp;</span>
<span class="s2">                               &#39;,symrec(3,1:3,isym)</span>
<span class="s2">and the nonsymmorphic transl. tnons =&#39;,(tnons(mu,isym),mu=1,3)</span>
<span class="s2">The nearest coordinate differs by&#39;,difmin(1:3) for indsym(nearest atom)=&#39;,indsym(4,isym,iatom)</span>

<span class="s2">This indicates that when symatm attempts to find atoms symmetrically</span>
<span class="s2">related to a given atom, the nearest candidate is further away than some tolerance.</span>
<span class="s2">Should check atomic coordinates and symmetry group input data.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(),</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="n">tolsym</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;maximum err </span><span class="si">%s</span><span class="s2"> is larger than tolsym: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">tolsym</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">indsym</span>


<span class="k">class</span> <span class="nc">Operation</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class that defines the methods that must be</span>
<span class="sd">    implemented by the concrete class representing some sort of operation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;O1 == O2&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;O1 * O2&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operation can be used as dictionary keys.&quot;&quot;&quot;</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the inverse of self.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">opconj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns X^-1 S X where X is the other symmetry operation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">isE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self is the identity operator&quot;&quot;&quot;</span>

    <span class="c1">#def commute(self, other)</span>
    <span class="c1">#    return self * other == other * self</span>

    <span class="c1">#def commutator(self, other)</span>
    <span class="c1">#    return self * other - other * self</span>

    <span class="c1">#def anticommute(self, other)</span>
    <span class="c1">#    return self * other == - other * self</span>

    <span class="c1">#def direct_product(self, other)</span>


<span class="k">class</span> <span class="nc">SymmOp</span><span class="p">(</span><span class="n">Operation</span><span class="p">,</span> <span class="n">SlotPickleMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crystalline symmetry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ATOL_TAU</span> <span class="o">=</span> <span class="mf">1e-8</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;rot_r&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rotm1_r&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tau&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time_sign&quot;</span><span class="p">,</span>
        <span class="s2">&quot;afm_sign&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rot_g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_det&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_trace&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="c1"># TODO: Add lattice?</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rot_r</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">time_sign</span><span class="p">,</span> <span class="n">afm_sign</span><span class="p">,</span> <span class="n">rot_g</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This object represents a space group symmetry i.e. a symmetry of the crystal.</span>

<span class="sd">        Args:</span>
<span class="sd">            rot_r: (3,3) integer matrix with the rotational part in real space in reduced coordinates (C order).</span>
<span class="sd">            tau: fractional translation in reduced coordinates.</span>
<span class="sd">            time_sign: -1 if time reversal can be used, +1 otherwise.</span>
<span class="sd">            afm_sign: anti-ferromagnetic part [+1, -1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rot_r</span><span class="p">)</span>

        <span class="c1"># Store R and R^{-1} in real space.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotm1_r</span> <span class="o">=</span> <span class="n">rot_r</span><span class="p">,</span> <span class="n">mati3inv</span><span class="p">(</span><span class="n">rot_r</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">=</span> <span class="n">afm_sign</span><span class="p">,</span> <span class="n">time_sign</span>
        <span class="k">assert</span> <span class="n">afm_sign</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">time_sign</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Compute symmetry matrix in reciprocal space: S = R^{-1t}</span>
        <span class="k">if</span> <span class="n">rot_g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot_g</span> <span class="o">=</span> <span class="n">mati3inv</span><span class="p">(</span><span class="n">rot_r</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">rot_g</span> <span class="o">==</span> <span class="n">mati3inv</span><span class="p">(</span><span class="n">rot_r</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rot_g</span> <span class="o">=</span> <span class="n">rot_g</span>

    <span class="c1"># operator protocol.</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note the two fractional traslations are equivalent if they differ by a lattice vector.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">rot_r</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ATOL_TAU</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">afm_sign</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time_sign</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new :class:`SymmOp` which is equivalent to apply the &quot;other&quot; :class:`SymmOp`</span>
<span class="sd">        followed by this one i.e:</span>

<span class="sd">        {R,t} {S,u} = {RS, Ru + t}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">rot_r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rot_r</span><span class="p">),</span>
                              <span class="n">tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">tau</span><span class="p">),</span>
                              <span class="n">time_sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">time_sign</span><span class="p">,</span>
                              <span class="n">afm_sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">afm_sign</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`Symmop` can be used as keys in dictionaries.</span>
<span class="sd">        Note that the hash is computed from integer values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns inverse of transformation i.e. {R^{-1}, -R^{-1} tau}.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">rot_r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotm1_r</span><span class="p">,</span>
                              <span class="n">tau</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotm1_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">),</span>
                              <span class="n">time_sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span><span class="p">,</span>
                              <span class="n">afm_sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">isE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if identity operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">))</span> <span class="ow">and</span>
                <span class="n">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ATOL_TAU</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># end operator protocol.</span>

    <span class="c1">#@lazy_property</span>
    <span class="c1">#def order(self):</span>
    <span class="c1">#    &quot;&quot;&quot;Order of the operation.&quot;&quot;&quot;</span>
    <span class="c1">#    n = 0</span>
    <span class="c1">#    o = self</span>
    <span class="c1">#    while m &lt; 1000:</span>
    <span class="c1">#        if o.isE: return n</span>
    <span class="c1">#        n += 1</span>
    <span class="c1">#        o = self * o</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        raise ValueError(&quot;Cannot find order&quot;)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">vec2str</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%2d</span><span class="s2">,</span><span class="si">%2d</span><span class="s2">,</span><span class="si">%2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">vec2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;, </span><span class="si">%.3f</span><span class="s2">]  &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">vec2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_g</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;] &quot;</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, time_sign = </span><span class="si">%+1d</span><span class="s2">, afm_sign = </span><span class="si">%+1d</span><span class="s2">, det = </span><span class="si">%+1d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_symmorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the fractional translation is non-zero.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determinant of the rotation matrix [-1, +1].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_get_det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trace of the rotation matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_r</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_proper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the rotational part has determinant == 1.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">has_timerev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if symmetry contains the time-reversal operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_fm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self if ferromagnetic symmetry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_afm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self if anti-ferromagnetic symmetry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">rotate_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the symmetry operation to the k-point given in reduced coordinates.</span>

<span class="sd">        Sk is wrapped to the first Brillouin zone if wrap_tows is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_g</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_sign</span>

        <span class="k">return</span> <span class="n">wrap_to_ws</span><span class="p">(</span><span class="n">sk</span><span class="p">)</span> <span class="k">if</span> <span class="n">wrap_tows</span> <span class="k">else</span> <span class="n">sk</span>

    <span class="k">def</span> <span class="nf">preserve_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">ret_g0</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the operation preserves the k-point modulo a reciprocal lattice vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            frac_coords: Fractional coordinates of the k-point</span>
<span class="sd">            ret_g0: False if only the boolean result is wanted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool, g0 = S(k) - k</span>

<span class="sd">            bool is True is self preserves k and g0 is an integer vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_g0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">sk</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">issamek</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rotate_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">in_ucell</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the symmetry operation to a point in real space given in reduced coordinates.</span>

<span class="sd">        .. NOTE::</span>

<span class="sd">            We use the convention: symmop(r) = R^{-1] (r - tau)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotm1_rmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotm1_r</span><span class="p">,</span> <span class="n">frac_coords</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrap_in_ucell</span><span class="p">(</span><span class="n">rotm1_rmt</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_ucell</span> <span class="k">else</span> <span class="n">rotm1_rmt</span>


<span class="k">class</span> <span class="nc">OpSequence</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class providing the basic method that are common to containers of operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equality test.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The order of the operations in self and  in other is not relevant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check if each operation in self is also present in other.</span>
        <span class="c1"># The order is irrelevant.</span>
        <span class="n">founds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="n">founds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">founds</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">founds</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;self contains duplicated ops! Likely a bug!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">show_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of occurences of operation op in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (first) index of operation op in self.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the (first) index of op in self. -1 if not found.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">is_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this set of operations represent a group.&quot;&quot;&quot;</span>
        <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Identity must be present.</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">isE</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># The inverse must be in the set.</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">check</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="c1"># The product of two members must be in the set.</span>
        <span class="n">op_prods</span> <span class="o">=</span> <span class="p">[</span><span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span> <span class="k">for</span> <span class="n">op1</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">op2</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">op12</span> <span class="ow">in</span> <span class="n">op_prods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">op12</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;op12 not in group</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">op12</span><span class="p">))</span>
                <span class="n">check</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">check</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if all operations commute with each other.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span> <span class="ow">in</span> <span class="n">iuptri</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diago</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span> <span class="o">!=</span> <span class="n">op2</span> <span class="o">*</span> <span class="n">op1</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_abelian_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if commutative group.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_group</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary where the keys are the symmetry operations and</span>
<span class="sd">        the values are the indices of the operations in the iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">op</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)}</span>

    <span class="c1">#def is_subset(self, other)</span>
    <span class="c1">#    indmap = {}</span>
    <span class="c1">#    for i, op in self:</span>
    <span class="c1">#        j = other.find(op)</span>
    <span class="c1">#        if j != -1: indmap[i] = j</span>
    <span class="c1">#    return indmap</span>

    <span class="c1">#def is_superset(self, other)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">mult_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of nsym 3x3 operations which are supposed to form a group,</span>
<span class="sd">        this routine constructs the multiplication table of the group.</span>
<span class="sd">        mtable[i,j] gives the index of the product S_i * S_j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mtable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">op1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">op2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">op12</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span>
                <span class="c1"># Save the index of op12 in self</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">op12</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">mtable</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

        <span class="k">return</span> <span class="n">mtable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_classes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of classes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_indices</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">class_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class is defined as the set of distinct elements obtained by</span>
<span class="sd">        considering for each element, S, of the group all its conjugate</span>
<span class="sd">        elements X^-1 S X where X ranges over all the elements of the group.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nested list l = [cls0_indices, cls1_indices, ...] where each sublist</span>
<span class="sd">            contains the indices of the class. len(l) equals the number of classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span><span class="p">,</span> <span class="n">class_indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="kc">False</span><span class="p">],</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

        <span class="n">num_classes</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">op1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">[</span><span class="n">ii</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="n">num_classes</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="n">op2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># Form conjugate and search it among the operations</span>
                <span class="c1"># that have not been found yet.</span>
                <span class="n">op1_conj</span> <span class="o">=</span> <span class="n">op1</span><span class="o">.</span><span class="n">opconj</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">op3</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="ow">and</span> <span class="n">op1_conj</span> <span class="o">==</span> <span class="n">op3</span><span class="p">:</span>
                        <span class="n">found</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">class_indices</span><span class="p">[</span><span class="n">num_classes</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>

        <span class="n">class_indices</span> <span class="o">=</span> <span class="n">class_indices</span><span class="p">[:</span><span class="n">num_classes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">class_indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">class_indices</span>

    <span class="k">def</span> <span class="nf">groupby_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_inds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the operations grouped in symmetry classes.</span>

<span class="sd">        Args:</span>
<span class="sd">            with_inds: If True, [op0, op1, ...], [ind_op0, ind_op1, ...] is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">with_inds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indices</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_indices</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>


<div class="viewcode-block" id="AbinitSpaceGroup"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup">[docs]</a><span class="k">class</span> <span class="nc">AbinitSpaceGroup</span><span class="p">(</span><span class="n">OpSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container storing the space group symmetries.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spgid</span><span class="p">,</span> <span class="n">symrel</span><span class="p">,</span> <span class="n">tnons</span><span class="p">,</span> <span class="n">symafm</span><span class="p">,</span> <span class="n">has_timerev</span><span class="p">,</span> <span class="n">inord</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            spgid (int): space group number (from 1 to 232, 0 if cannot be specified).</span>
<span class="sd">            symrel: (nsym,3,3) array with the rotational part of the symmetries in real</span>
<span class="sd">                space (reduced coordinates are assumed, see also `inord` for the order.</span>
<span class="sd">            tnons: (nsym,3) array with fractional translation in reduced coordinates.</span>
<span class="sd">            symafm: (nsym) array with +1 for Ferromagnetic symmetry and -1 for AFM</span>
<span class="sd">            has_timerev: True if time-reversal symmetry is included.</span>
<span class="sd">            inord: storage order of mat in symrel[:]. If inord == &quot;F&quot;, mat.T is stored</span>
<span class="sd">                as matrices are always stored in C-order. Use inord == &quot;F&quot; if you have</span>
<span class="sd">                read symrel from an external file produced by abinit.</span>

<span class="sd">        .. note::</span>

<span class="sd">            All the arrays are stored in C-order. Use as_fortran_arrays to extract data</span>
<span class="sd">            that can be passes to Fortran routines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span> <span class="o">=</span> <span class="n">spgid</span>
        <span class="k">assert</span> <span class="mi">233</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="c1"># Time reversal symmetry.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_timerev</span> <span class="o">=</span> <span class="n">has_timerev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_signs</span> <span class="o">=</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timerev</span> <span class="k">else</span> <span class="p">[</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symrel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tnons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symafm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">symrel</span><span class="p">,</span> <span class="n">tnons</span><span class="p">,</span> <span class="n">symafm</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tnons</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symafm</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;symrel, tnons and symafm must have equal shape[0]&quot;</span><span class="p">)</span>

        <span class="n">inord</span> <span class="o">=</span> <span class="n">inord</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">inord</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">inord</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
            <span class="c1"># Fortran to C.</span>
            <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_symrel</span><span class="p">[</span><span class="n">isym</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symrel</span><span class="p">[</span><span class="n">isym</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symrec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symrel</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_symrec</span><span class="p">[</span><span class="n">isym</span><span class="p">]</span> <span class="o">=</span> <span class="n">mati3inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span> <span class="n">trans</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">all_syms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">time_sign</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_signs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">)):</span>
                <span class="n">all_syms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="p">(</span><span class="n">rot_r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symrel</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span>
                                       <span class="n">tau</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tnons</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span>
                                       <span class="n">time_sign</span><span class="o">=</span><span class="n">time_sign</span><span class="p">,</span>
                                       <span class="n">afm_sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symafm</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span>
                                       <span class="n">rot_g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symrec</span><span class="p">[</span><span class="n">isym</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_syms</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitSpaceGroup.from_ncreader"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.from_ncreader">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ncreader</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">inord</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the object from a netcdf reader</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;kptopt&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">symrel</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_symmetry_matrices&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">spgid</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;space_group&quot;</span><span class="p">),</span>
                   <span class="n">symrel</span><span class="o">=</span><span class="n">symrel</span><span class="p">,</span>
                   <span class="n">tnons</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_symmetry_translations&quot;</span><span class="p">),</span>
                   <span class="n">symafm</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;symafm&quot;</span><span class="p">),</span>
                   <span class="n">has_timerev</span><span class="o">=</span><span class="n">has_timrev_from_kptopt</span><span class="p">(</span><span class="n">kptopt</span><span class="p">),</span>
                   <span class="n">inord</span><span class="o">=</span><span class="n">inord</span><span class="p">)</span></div>

    <span class="c1">#@classmethod</span>
    <span class="c1">#def from_file(cls, ncfile, inord=&quot;F&quot;):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Initialize the object from a Netcdf file.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    from abipy.iotools import as_etsfreader</span>
    <span class="c1">#    r, closeit = as_etsfreader(ncfile)</span>
    <span class="c1">#    new = cls.from_ncreader(r)</span>
    <span class="c1">#    if closeit:</span>
    <span class="c1">#        file.close()</span>

    <span class="c1">#    return new</span>

<div class="viewcode-block" id="AbinitSpaceGroup.from_structure"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.from_structure">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">has_timerev</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a |Structure| object. Uses spglib to perform various symmetry finding operations.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: |Structure| object.</span>
<span class="sd">            has_timerev: True is time-reversal symmetry is included.</span>
<span class="sd">            symprec: Tolerance for symmetry finding.</span>
<span class="sd">            angle_tolerance: Angle tolerance for symmetry finding.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            AFM symmetries are not supported.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call spglib to get the list of symmetry operations.</span>
        <span class="n">spga</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">spga</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span>
        <span class="n">symrel</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rotations&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">spgid</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">],</span>
                   <span class="n">symrel</span><span class="o">=</span><span class="n">symrel</span><span class="p">,</span>
                   <span class="n">tnons</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;translations&quot;</span><span class="p">],</span>
                   <span class="n">symafm</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">symrel</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">has_timerev</span><span class="o">=</span><span class="n">has_timerev</span><span class="p">,</span>
                   <span class="n">inord</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;spgid: </span><span class="si">%d</span><span class="s2">, num_spatial_symmetries: </span><span class="si">%d</span><span class="s2">, has_timerev: </span><span class="si">%s</span><span class="s2">, symmorphic: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_spatial_symmetries</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timerev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmorphic</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

<div class="viewcode-block" id="AbinitSpaceGroup.to_string"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.to_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;spgid: </span><span class="si">%d</span><span class="s2">, num_spatial_symmetries: </span><span class="si">%d</span><span class="s2">, has_timerev: </span><span class="si">%s</span><span class="s2">, symmorphic: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_spatial_symmetries</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timerev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmorphic</span><span class="p">)]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">(</span><span class="n">time_sign</span><span class="o">=+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitSpaceGroup.is_symmorphic"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.is_symmorphic">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_symmorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if there&#39;s at least one operation with non-zero fractional translation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_symmorphic</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_timerev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if time-reversal symmetry is present.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_timerev</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symrel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [nsym, 3, 3] int array with symmetries in reduced coordinates of the direct lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symrel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tnons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [nsym, 3] float array with fractional translations in reduced coordinates of the direct lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tnons</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symrec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [nsym, 3, 3] int array with symmetries in reduced coordinates of the reciprocal lattice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symrec</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symafm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;[nsym] int array with +1 if FM or -1 if AFM symmetry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symafm</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_spatial_symmetries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_timerev</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">afm_symmops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple with antiferromagnetic symmetries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">(</span><span class="n">time_sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">afm_sign</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fm_symmops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tuple of ferromagnetic symmetries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">(</span><span class="n">time_sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">afm_sign</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitSpaceGroup.symmops"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.symmops">[docs]</a>    <span class="k">def</span> <span class="nf">symmops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">afm_sign</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            time_sign: If specified, only symmetries with time-reversal sign time_sign are returned.</span>
<span class="sd">            afm_sign: If specified, only symmetries with anti-ferromagnetic part afm_sign are returned.</span>

<span class="sd">        returns:</span>
<span class="sd">            tuple of :class:`SymmOp` instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symmops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span><span class="p">:</span>
            <span class="n">gotit</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">time_sign</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">time_sign</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_signs</span>
                <span class="n">gotit</span> <span class="o">=</span> <span class="n">gotit</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">time_sign</span> <span class="o">==</span> <span class="n">time_sign</span>

            <span class="k">if</span> <span class="n">afm_sign</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">afm_sign</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">gotit</span> <span class="o">=</span> <span class="n">gotit</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">afm_sign</span> <span class="o">==</span> <span class="n">afm_sign</span>

            <span class="k">if</span> <span class="n">gotit</span><span class="p">:</span>
                <span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">symmops</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitSpaceGroup.symeq"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.symeq">[docs]</a>    <span class="k">def</span> <span class="nf">symeq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k1_frac_coords</span><span class="p">,</span> <span class="n">k2_frac_coords</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether two k-points in fractional coordinates are symmetry equivalent</span>
<span class="sd">        i.e. if there&#39;s a symmetry operations TO (including time-reversal T, if present)</span>
<span class="sd">        such that::</span>

<span class="sd">            TO(k1) = k2 + G0</span>

<span class="sd">        Return: namedtuple with::</span>

<span class="sd">            isym: The index of the symmetry operation such that TS(k1) = k2 + G0</span>
<span class="sd">                Set to -1 if k1 and k2 are not related by symmetry.</span>
<span class="sd">            op: Symmetry operation.</span>
<span class="sd">            g0: numpy vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">isym</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">sk_coords</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="n">k1_frac_coords</span><span class="p">,</span> <span class="n">wrap_tows</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">issamek</span><span class="p">(</span><span class="n">sk_coords</span><span class="p">,</span> <span class="n">k2_frac_coords</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                <span class="n">g0</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">rotate_k</span><span class="p">(</span><span class="n">k1_frac_coords</span><span class="p">)</span> <span class="o">-</span> <span class="n">k2_frac_coords</span>
                <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">isym</span><span class="o">=</span><span class="n">isym</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">isym</span><span class="p">],</span> <span class="n">g0</span><span class="o">=</span><span class="n">g0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dict2namedtuple</span><span class="p">(</span><span class="n">isym</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">g0</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitSpaceGroup.find_little_group"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.AbinitSpaceGroup.find_little_group">[docs]</a>    <span class="k">def</span> <span class="nf">find_little_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the little group of the kpoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoint: Accept vector with the reduced coordinates or :class:`Kpoint` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`LittleGroup` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="s2">&quot;frac_coords&quot;</span><span class="p">):</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">kpoint</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">))</span>

        <span class="n">to_spgrp</span><span class="p">,</span> <span class="n">g0vecs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="c1"># Exclude AFM operations.</span>
        <span class="k">for</span> <span class="n">isym</span><span class="p">,</span> <span class="n">symmop</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fm_symmops</span><span class="p">):</span>
            <span class="n">is_same</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">symmop</span><span class="o">.</span><span class="n">preserve_k</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_same</span><span class="p">:</span>
                <span class="n">to_spgrp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isym</span><span class="p">)</span>
                <span class="n">g0vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g0</span><span class="p">)</span>

        <span class="c1"># List with the symmetry operation that preserve the kpoint.</span>
        <span class="n">k_symmops</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_spgrp</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">LittleGroup</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">k_symmops</span><span class="p">,</span> <span class="n">g0vecs</span><span class="p">)</span></div></div>


<span class="c1"># FIXME To maintain backward compatibility.</span>
<span class="n">SpaceGroup</span> <span class="o">=</span> <span class="n">AbinitSpaceGroup</span>


<span class="k">class</span> <span class="nc">LittleGroup</span><span class="p">(</span><span class="n">OpSequence</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">symmops</span><span class="p">,</span> <span class="n">g0vecs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        k_symmops, g0vecs, indices</span>

<span class="sd">        k_symmops is a tuple with the symmetry operations that preserve the k-point i.e. Sk = k + G0</span>
<span class="sd">        g0vecs is the tuple for G0 vectors for each operation in k_symmops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kpoint</span> <span class="o">=</span> <span class="n">kpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span> <span class="o">=</span> <span class="n">symmops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g0vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">g0vecs</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g0vecs</span><span class="p">)</span>

        <span class="c1"># Find the point group of k so that we know how to access the Bilbao database.</span>
        <span class="c1"># (note that operations are in reciprocal space, afm and time_reversal are taken out</span>
        <span class="n">krots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">rot_g</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">symmops</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">has_timerev</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kgroup</span> <span class="o">=</span> <span class="n">LatticePointGroup</span><span class="p">(</span><span class="n">krots</span><span class="p">)</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_symmorphic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if there&#39;s at least one operation with non-zero fractional translation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_symmorphic</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symmops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">on_bz_border</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the k-point is on the border of the BZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpoint</span><span class="p">)</span>
        <span class="n">kreds</span> <span class="o">=</span> <span class="n">wrap_to_ws</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kreds</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_symmop_g0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">symmop</span><span class="p">,</span> <span class="n">g0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g0vecs</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">symmop</span><span class="p">,</span> <span class="n">g0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Kpoint Group: </span><span class="si">%s</span><span class="s2">, Kpoint: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgroup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of little group.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Kpoint-group: </span><span class="si">%s</span><span class="s2">, Kpoint: </span><span class="si">%s</span><span class="s2">, Symmorphic: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgroup</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmorphic</span><span class="p">)]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

        <span class="c1"># Add character_table from Bilbao database.</span>
        <span class="n">bilbao_ptgrp</span> <span class="o">=</span> <span class="n">bilbao_ptgroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kgroup</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">)</span>
        <span class="n">app</span><span class="p">(</span><span class="n">bilbao_ptgrp</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">))</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Write warning if non-symmorphic little group with k-point at zone border.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmorphic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_bz_border</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;WARNING: non-symmorphic little group with k at zone-border.&quot;</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Electronic states cannot be classified with this character table.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="c1">#def iter_symmop_g0_byclass(self):</span>


<span class="k">class</span> <span class="nc">LatticePointGroup</span><span class="p">(</span><span class="n">OpSequence</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotations</span><span class="p">):</span>
        <span class="n">rotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">LatticeRotation</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span> <span class="k">for</span> <span class="n">rot</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">]</span>

        <span class="c1"># Call spglib to get the Herm symbol.</span>
        <span class="c1"># (symbol, pointgroup_number, transformation_matrix)</span>
        <span class="n">herm_symbol</span><span class="p">,</span> <span class="n">ptg_num</span><span class="p">,</span> <span class="n">trans_mat</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_pointgroup</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span>
        <span class="c1"># Remove blanks from C string.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">herm_symbol</span> <span class="o">=</span> <span class="n">herm_symbol</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1">#print(self.herm_symbol, ptg_num, trans_mat)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot detect point group symbol! Got sch_symbol = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">)</span>

    <span class="c1">#@classmethod</span>
    <span class="c1">#def from_vectors(cls, vectors)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">herm_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">herm_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spgid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sch_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Schoenflies symbol&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">herm2sch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">herm_symbol</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spgid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID in the space group table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sch2spgid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">)</span>


<div class="viewcode-block" id="LatticeRotation"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation">[docs]</a><span class="k">class</span> <span class="nc">LatticeRotation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object defines a pure rotation of the lattice (proper, improper, mirror symmetry)</span>
<span class="sd">    that is a rotation which is compatible with a lattice. The rotation matrix is</span>
<span class="sd">    expressed in reduced coordinates, therefore its elements are integers.</span>

<span class="sd">    See:</span>
<span class="sd">        http://xrayweb2.chem.ou.edu/notes/symmetry.html#rotation</span>

<span class="sd">    .. note::</span>

<span class="sd">        This object is immutable and therefore we do not inherit from |numpy-array|.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_E3D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_order_and_rootinv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the rotation and if self is a root of the inverse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span><span class="p">,</span> <span class="n">root_inv</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ior</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
            <span class="n">rn</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">**</span> <span class="n">ior</span>

            <span class="k">if</span> <span class="n">rn</span><span class="o">.</span><span class="n">isE</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">ior</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">rn</span><span class="o">.</span><span class="n">isI</span><span class="p">:</span>
                <span class="n">root_inv</span> <span class="o">=</span> <span class="n">ior</span>

        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;LatticeRotation is not a root of unit!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">order</span><span class="p">,</span> <span class="n">root_inv</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="c1">#def __str__(self):</span>
    <span class="c1">#    lines = &quot;Rotation: &quot; + str(self.order) + &quot;, versor: &quot; + str(self.versor) + &quot;,</span>
    <span class="c1">#    lines.append(str(self.mat))</span>
    <span class="c1">#    return &quot;\n&quot;.join(lines)</span>

    <span class="c1"># operator protocol.</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">mat</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span><span class="p">)</span>

<div class="viewcode-block" id="LatticeRotation.inverse"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invert an orthogonal 3x3 matrix of INTEGER elements.</span>
<span class="sd">        Note use of integer arithmetic. Raise ValueError if not invertible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">mati3inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span></div>

<div class="viewcode-block" id="LatticeRotation.isE"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.isE">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">isE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if it is the identity&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E3D</span><span class="p">)</span></div>
    <span class="c1"># end operator protocol.</span>

    <span class="c1"># Implement the unary arithmetic operations (+, -)</span>
    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intexp</span><span class="p">,</span> <span class="n">modulo</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">intexp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3D</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intexp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="n">intexp</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">intexp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">intexp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__pow__</span><span class="p">(</span><span class="o">-</span><span class="n">intexp</span><span class="p">)</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;type </span><span class="si">%s</span><span class="s2"> is not supported in __pow__&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">intexp</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Order of the rotation.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_order_and_rootinv</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">root_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_inv</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_order_and_rootinv</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_root_inv</span>

<div class="viewcode-block" id="LatticeRotation.det"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.det">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the determinant of a symmetry matrix mat[3,3]. It must be +-1&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_get_det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">)</span></div>

<div class="viewcode-block" id="LatticeRotation.trace"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.trace">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The trace of the rotation matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span></div>

<div class="viewcode-block" id="LatticeRotation.is_proper"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.is_proper">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">is_proper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if proper rotation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span> <span class="o">==</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="LatticeRotation.isI"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.isI">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">isI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self is the inversion operation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mat</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_E3D</span><span class="p">)</span></div>

<div class="viewcode-block" id="LatticeRotation.name"><a class="viewcode-back" href="../../../api/core_api.html#abipy.core.symmetries.LatticeRotation.name">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Sign of the determinant (only if improper)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">name</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="c1"># Root of inverse?</span>
        <span class="n">name</span> <span class="o">+=</span> <span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_inv</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;+&quot;</span>

        <span class="k">return</span> <span class="n">name</span></div></div>

    <span class="c1">#@property</span>
    <span class="c1">#def rottype(self):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Receive a 3x3 orthogonal matrix and reports its type:</span>
    <span class="c1">#        1 Identity</span>
    <span class="c1">#        2 Inversion</span>
    <span class="c1">#        3 Proper rotation of an angle &lt;&gt; 180 degrees</span>
    <span class="c1">#        4 Proper rotation of 180 degrees</span>
    <span class="c1">#        5 Mirror symmetry</span>
    <span class="c1">#        6 Improper rotation</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    # Treat identity and inversion first</span>
    <span class="c1">#    if self.isE: return 1</span>
    <span class="c1">#    if self.isI: return 2</span>
    <span class="c1">#</span>
    <span class="c1">#    if self.isproper: # Proper rotation</span>
    <span class="c1">#        t = 3 # try angle != 180</span>
    <span class="c1">#        #det180 = get_sym_det(rot + self._E3D)</span>
    <span class="c1">#        if (self + identity).det == 0: t = 4 # 180 rotation</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        # Mirror symmetry or Improper rotation</span>
    <span class="c1">#        t = 6</span>
    <span class="c1">#        #detmirror = get_sym_det(rot - self._E3D)</span>
    <span class="c1">#        if (self - identity).det == 0:</span>
    <span class="c1">#            t = 5 # Mirror symmetry if an eigenvalue is 1</span>

    <span class="c1">#    return t</span>


<span class="c1"># TODO: Need to find an easy way to map classes in internal database</span>
<span class="c1"># onto classes computed by client code when calculation has been done</span>
<span class="c1"># with non-conventional settings (spglib?)</span>
<span class="k">class</span> <span class="nc">Irrep</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object represents an irreducible representation.</span>

<span class="sd">    .. attributes::</span>

<span class="sd">        traces: all_traces[nsym]. The trace of each irrep.</span>
<span class="sd">        character: character[num_classes]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">mats</span><span class="p">,</span> <span class="n">class_range</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            name:  Name of the irreducible representation.</span>
<span class="sd">            dim: Dimension of the irreducible representation.</span>
<span class="sd">            mats: Array of shape [nsym,dim,dim] with the irreducible</span>
<span class="sd">                representations of the group. mats are packed in classes.</span>
<span class="sd">            class_range: List of tuples, each tuple gives the start and stop index for the class.</span>
<span class="sd">                e.g. [(0, 2), (2,4), (4,n)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mats</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mats</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">class_range</span> <span class="o">=</span> <span class="n">class_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nclass</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_range</span><span class="p">)</span>

        <span class="c1"># Compute character table.</span>
        <span class="n">character</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclass</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">icls</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_range</span><span class="p">):</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">isok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">t0</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
            <span class="n">character</span><span class="p">[</span><span class="n">icls</span><span class="p">]</span> <span class="o">=</span> <span class="n">t0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_character</span> <span class="o">=</span> <span class="n">character</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mats</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">character</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_character</span>

    <span class="c1">#@lazy_property</span>
    <span class="c1">#def dataframe(self):</span>


<span class="k">def</span> <span class="nf">bilbao_ptgroup</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an instance of :class:`BilbaoPointGroup` from a string with the point group symbol</span>
<span class="sd">    or a number with the spacegroup ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sch_symbol</span> <span class="o">=</span> <span class="n">any2sch</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">abipy.core.irrepsdb</span> <span class="kn">import</span> <span class="n">_PTG_IRREPS_DB</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">_PTG_IRREPS_DB</span><span class="p">[</span><span class="n">sch_symbol</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">entry</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;nclass&quot;</span><span class="p">)</span>
    <span class="n">entry</span><span class="p">[</span><span class="s2">&quot;sch_symbol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sch_symbol</span>

    <span class="k">return</span> <span class="n">BilbaoPointGroup</span><span class="p">(</span><span class="o">**</span><span class="n">entry</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BilbaoPointGroup</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`BilbaoPointGroup` is a :class:`Pointgroup` with irreducible representations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sch_symbol</span><span class="p">,</span> <span class="n">rotations</span><span class="p">,</span> <span class="n">class_names</span><span class="p">,</span> <span class="n">class_range</span><span class="p">,</span> <span class="n">irreps</span><span class="p">):</span>
        <span class="c1"># Rotations are grouped in classes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="n">sch_symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_names</span> <span class="o">=</span> <span class="n">class_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nclass</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_names</span><span class="p">)</span>

        <span class="c1"># List of tuples, each tuple gives the start and stop index for the class.</span>
        <span class="c1"># e.g. [(0, 2), (2,4), (4,n)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_range</span> <span class="o">=</span> <span class="n">class_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_len</span> <span class="o">=</span> <span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">class_range</span><span class="p">]</span>

        <span class="c1"># The number of irreps must equal the number of classes.</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">irreps</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nclass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps_by_name</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">irreps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mats</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;matrices&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mats</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rots</span>
            <span class="n">irrep</span> <span class="o">=</span> <span class="n">Irrep</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;dim&quot;</span><span class="p">],</span> <span class="n">mats</span><span class="p">,</span> <span class="n">class_range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">class_range</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">irrep</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">irreps_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">irrep</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">herm_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hermann-Mauguin symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">herm2sch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spgid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ID in the space group table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sch2spgid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_rots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of rotations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_irreps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of irreducible representations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">irrep_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List with the names of the irreps.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps_by_name</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">character_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dataframe with irreps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Caveat: class names are not necessarly unique --&gt; use np.stack</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">name_mult</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; [&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mult</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_len</span><span class="p">)]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">name_mult</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">irrep</span><span class="o">.</span><span class="n">character</span> <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">])</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">irrep</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">name_mult</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Irrep&quot;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span>

        <span class="c1"># TODO</span>
        <span class="c1">#print(df)</span>
        <span class="c1"># Convert complex --&gt; real if all entries in a colums are real.</span>
        <span class="c1">#for k in name_mult:</span>
        <span class="c1">#    if np.all(np.isreal(df[k].values)):</span>
        <span class="c1">#        #df[k] = df[k].values.real</span>
        <span class="c1">#        df[k] = df[k].astype(float)</span>

        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return string with the character_table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">character_table</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="c1">#def decompose(self, character):</span>
    <span class="c1">#   od = collections.OrderedDict()</span>
    <span class="c1">#   for irrep in self.irreps:</span>
    <span class="c1">#       irrep.name</span>
    <span class="c1">#       irrep.character</span>
    <span class="c1">#   return od</span>

    <span class="c1">#def show_irrep(self, irrep_name):</span>
    <span class="c1">#    &quot;&quot;&quot;Show the mapping rotation --&gt; irrep mat.&quot;&quot;&quot;</span>
    <span class="c1">#    irrep = self.irreps_by_name[irrep_name]</span>

    <span class="c1">#def irrep_from_character(self, character, rotations, tol=None):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Main entry point for client code.</span>
    <span class="c1">#    This routine receives a character computed from the user and finds the</span>
    <span class="c1">#    irreducible representation.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>

    <span class="c1">#def map_rotclasses(self, rotations_in_classes)</span>
    <span class="c1">#def map_rotation(self, rotations_in_classes)</span>

    <span class="k">def</span> <span class="nf">auto_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform internal consistency check. Return 0 if success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#print(&quot;rotations\n&quot;, self.rotations)</span>
        <span class="n">rot_group</span> <span class="o">=</span> <span class="n">LatticePointGroup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rot_group</span><span class="o">.</span><span class="n">is_group</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rotations do not form a group!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="c1"># Symmetries should be ordered in classes.</span>
        <span class="c1"># Here we recompute the classes by calling rot_group.class_indices.</span>
        <span class="c1"># We then sort the indices and we compare the results with the ref data stored in the Bilbao database.</span>
        <span class="n">calc_class_inds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">rot_group</span><span class="o">.</span><span class="n">class_indices</span><span class="p">]</span>
        <span class="c1">#print(calc_class_inds)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">calc_class_inds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">class_range</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">calc_inds</span><span class="p">,</span> <span class="n">ref_range</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">calc_class_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_range</span><span class="p">):</span>
            <span class="n">ref_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ref_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ref_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">calc_inds</span> <span class="o">!=</span> <span class="n">ref_inds</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rotations are not ordered in classes.&quot;</span><span class="p">,</span> <span class="n">calc_inds</span><span class="p">,</span> <span class="n">ref_inds</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">2</span>

        <span class="c1"># Do we have a representation of the Group?</span>
        <span class="n">mult_table</span> <span class="o">=</span> <span class="n">rot_group</span><span class="o">.</span><span class="n">mult_table</span>
        <span class="n">max_err</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">rot1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rot_group</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">rot2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rot_group</span><span class="p">):</span>
                <span class="n">idx_prod</span> <span class="o">=</span> <span class="n">mult_table</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">irrep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">:</span>
                    <span class="n">mat_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">irrep</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="n">irrep</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="n">idx2</span><span class="p">])</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat_prod</span> <span class="o">-</span> <span class="n">irrep</span><span class="o">.</span><span class="n">mats</span><span class="p">[</span><span class="n">idx_prod</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="n">max_err</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_err</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">max_err</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Irreps do not form a representation of the group, max_err: &quot;</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">3</span>

        <span class="c1"># TODO</span>
        <span class="c1"># Test orthogonality theorem</span>

        <span class="c1"># Test the orthogonality relation of traces.</span>
        <span class="n">max_err</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">),</span> <span class="p">(</span><span class="n">irp1</span><span class="p">,</span> <span class="n">irp2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iuptri</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">irreps</span><span class="p">,</span> <span class="n">with_inds</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">trac1</span><span class="p">,</span> <span class="n">trac2</span> <span class="o">=</span> <span class="n">irp1</span><span class="o">.</span><span class="n">traces</span><span class="p">,</span> <span class="n">irp2</span><span class="o">.</span><span class="n">traces</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">trac1</span><span class="p">,</span> <span class="n">trac2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rots</span>
            <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">jj</span><span class="p">:</span> <span class="n">err</span> <span class="o">-=</span> <span class="mf">1.0</span>
            <span class="n">max_err</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_err</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">max_err</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in orthogonality relation of traces: &quot;</span><span class="p">,</span> <span class="n">max_err</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">4</span>

        <span class="c1"># Success.</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="c1"># Schoenflies, Hermann-Mauguin, spgid</span>
<span class="n">_PTG_IDS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;C1&quot;</span> <span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>     <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Ci&quot;</span> <span class="p">,</span> <span class="s2">&quot;-1&quot;</span><span class="p">,</span>    <span class="mi">2</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C2&quot;</span> <span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>     <span class="mi">3</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Cs&quot;</span> <span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span>     <span class="mi">6</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C2h&quot;</span><span class="p">,</span> <span class="s2">&quot;2/m&quot;</span><span class="p">,</span>   <span class="mi">10</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D2&quot;</span> <span class="p">,</span> <span class="s2">&quot;222&quot;</span><span class="p">,</span>   <span class="mi">16</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C2v&quot;</span><span class="p">,</span> <span class="s2">&quot;mm2&quot;</span><span class="p">,</span>   <span class="mi">25</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D2h&quot;</span><span class="p">,</span> <span class="s2">&quot;mmm&quot;</span><span class="p">,</span>   <span class="mi">47</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C4&quot;</span> <span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span>     <span class="mi">75</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;S4&quot;</span> <span class="p">,</span> <span class="s2">&quot;-4&quot;</span><span class="p">,</span>    <span class="mi">81</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C4h&quot;</span><span class="p">,</span> <span class="s2">&quot;4/m&quot;</span><span class="p">,</span>   <span class="mi">83</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D4&quot;</span> <span class="p">,</span> <span class="s2">&quot;422&quot;</span><span class="p">,</span>   <span class="mi">89</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C4v&quot;</span><span class="p">,</span> <span class="s2">&quot;4mm&quot;</span><span class="p">,</span>   <span class="mi">99</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D2d&quot;</span><span class="p">,</span> <span class="s2">&quot;-42m&quot;</span><span class="p">,</span>  <span class="mi">111</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D4h&quot;</span><span class="p">,</span> <span class="s2">&quot;4/mmm&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C3&quot;</span> <span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span>     <span class="mi">143</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C3i&quot;</span><span class="p">,</span> <span class="s2">&quot;-3&quot;</span><span class="p">,</span>    <span class="mi">147</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D3&quot;</span> <span class="p">,</span> <span class="s2">&quot;32&quot;</span><span class="p">,</span>    <span class="mi">149</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C3v&quot;</span><span class="p">,</span> <span class="s2">&quot;3m&quot;</span><span class="p">,</span>    <span class="mi">156</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D3d&quot;</span><span class="p">,</span> <span class="s2">&quot;-3m&quot;</span><span class="p">,</span>   <span class="mi">162</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C6&quot;</span> <span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span>     <span class="mi">168</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C3h&quot;</span><span class="p">,</span> <span class="s2">&quot;-6&quot;</span><span class="p">,</span>    <span class="mi">174</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C6h&quot;</span><span class="p">,</span> <span class="s2">&quot;6/m&quot;</span><span class="p">,</span>   <span class="mi">175</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D6&quot;</span> <span class="p">,</span> <span class="s2">&quot;622&quot;</span><span class="p">,</span>   <span class="mi">177</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;C6v&quot;</span><span class="p">,</span> <span class="s2">&quot;6mm&quot;</span><span class="p">,</span>   <span class="mi">183</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D3h&quot;</span><span class="p">,</span> <span class="s2">&quot;-6m2&quot;</span><span class="p">,</span>  <span class="mi">189</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;D6h&quot;</span><span class="p">,</span> <span class="s2">&quot;6/mmm&quot;</span><span class="p">,</span> <span class="mi">191</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;T&quot;</span>  <span class="p">,</span> <span class="s2">&quot;23&quot;</span><span class="p">,</span>    <span class="mi">195</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Th&quot;</span> <span class="p">,</span> <span class="s2">&quot;m-3&quot;</span><span class="p">,</span>   <span class="mi">200</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;O&quot;</span>  <span class="p">,</span> <span class="s2">&quot;432&quot;</span><span class="p">,</span>   <span class="mi">207</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Td&quot;</span> <span class="p">,</span> <span class="s2">&quot;-43m&quot;</span><span class="p">,</span>  <span class="mi">215</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">&quot;Oh&quot;</span> <span class="p">,</span> <span class="s2">&quot;m-3m&quot;</span><span class="p">,</span>  <span class="mi">221</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">_SCH2HERM</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_PTG_IDS</span><span class="p">}</span>
<span class="n">_HERM2SCH</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_PTG_IDS</span><span class="p">}</span>
<span class="n">_SPGID2SCH</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_PTG_IDS</span><span class="p">}</span>
<span class="n">_SCH2SPGID</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_PTG_IDS</span><span class="p">}</span>

<span class="n">sch_symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_SCH2HERM</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">sch2herm</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert from Schoenflies to Hermann-Mauguin.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SCH2HERM</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sch2spgid</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert from Schoenflies to the space group id.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SCH2SPGID</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sch_symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">herm2sch</span><span class="p">(</span><span class="n">herm_symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert from Hermann-Mauguin to Schoenflies.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_HERM2SCH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">herm_symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">spgid2sch</span><span class="p">(</span><span class="n">spgid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the Schoenflies symbol from the space group identifier.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_SPGID2SCH</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">spgid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">any2sch</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert string or int to Schoenflies symbol. Returns None if invalid input&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">sch_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try Hermann-Mauguin</span>
            <span class="k">return</span> <span class="n">herm2sch</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Spacegroup ID?</span>
        <span class="k">return</span> <span class="n">spgid2sch</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2018, M. Giantomassi and the AbiPy group.<br/>
      Last updated on May 29, 2020.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.<br/>
    </p>
  </div>
</footer>
  </body>
</html>