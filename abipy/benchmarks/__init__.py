from __future__ import division, print_function

from pymatgen.io.abinit.flows import Flow


def bench_main(main):
    """
    This decorator is used to decorate main functions producing `AbinitFlows`.
    It adds the initialization of the logger and an argument parser that allows one to select 
    the loglevel, the workdir of the flow as well as the YAML file with the parameters of the `TaskManager`.
    The main function shall have the signature:

        main(options)

    where options in the container with the command line options generated by `ArgumentParser`.

    Args:
        main:
            main function.
    """
    from functools import wraps

    @wraps(main)
    def wrapper(*args, **kwargs):
        import argparse
        parser = argparse.ArgumentParser()

        parser.add_argument('--loglevel', default="ERROR", type=str,
                            help="set the loglevel. Possible values: CRITICAL, ERROR (default), WARNING, INFO, DEBUG")

        parser.add_argument("-w", '--workdir', default="", type=str, help="Working directory of the flow.")

        parser.add_argument("-m", '--manager', default=None, 
                            help="YAML file with the parameters of the task manager. " 
                                 "Default None i.e. the manager is read from standard locations: "
                                 "working directory first then ~/.abinit/abipy/manager.yml.")

        parser.add_argument("--mpi-range", default=None, help="Range of MPI processors to be tested."
                            "'--mpi-range='(1,4,2)' performs benchmarks for mpi_procs in [1, 3]")

        parser.add_argument("--omp-range", default=None, help="Range of OMP threads to be tested."
                            "'--omp-range='(1,4,2)' performs benchmarks for omp_threads in [1, 3]")

	parser.add_argument("--max-ncpus", default=None, type=int, help="Maximum number of CPUs to be tested.")
        parser.add_argument('--paw', default=False, action="store_true", help="Run PAW calculation if present")
        #parser.add_argument('--paral_kgb', default=1, type=int, help="paral_kgb input variable")

        parser.add_argument("--scheduler", "-s", default=False, action="store_true", help="Run with the scheduler")

        options = parser.parse_args()

        # loglevel is bound to the string value obtained from the command line argument. 
        # Convert to upper case to allow the user to specify --loglevel=DEBUG or --loglevel=debug
        import logging
        numeric_level = getattr(logging, options.loglevel.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError('Invalid log level: %s' % options.loglevel)
        logging.basicConfig(level=numeric_level)

        # parse arguments
        if options.mpi_range is not None:
            import ast
            t = ast.literal_eval(options.mpi_range)
            assert len(t) == 3
            options.mpi_range = range(t[0], t[1], t[2])
            #print(options.mpi_range)

        if options.omp_range is not None:
            import ast
            t = ast.literal_eval(options.omp_range)
            assert len(t) == 3
            options.omp_range = range(t[0], t[1], t[2])
            #print(options.omp_range)

        # Istantiate the manager.
        from abipy.abilab import TaskManager
        options.manager = TaskManager.as_manager(options.manager)

        flow = main(options)

        if options.scheduler:
            flow.make_scheduler().start()

        return 0

    return wrapper


class BenchmarkFlow(Flow):

    def exclude_from_benchmark(self, node):
        """Exclude a task or the tasks in a Work from the benchmark analysis."""
        if not hasattr(self, "_exclude_nodeids"): self._exclude_nodeids = set()

        if node.is_work:
            for task in node:
                self._exclude_nodeids.add(task.node_id)
        else:
            assert node.is_task
            self._exclude_nodeids.add(node.node_id)

    @property
    def exclude_nodeids(self):
        if not hasattr(self, "_exclude_nodeids"): self._exclude_nodeids = set()
        return self._exclude_nodeids 

    def get_parser(self):
        """
        Parse the timing sections in the output files.
        Return AbinitTimerParser parser object for further analysis.
        """
        nids = []
        for task in self.iflat_tasks():
            if task.node_id in self.exclude_nodeids: continue
            if task.status != task.S_OK: continue
            #print("analysing task:", task)
            nids.append(task.node_id)

        parser = self.parse_timing(nids=nids)

        if parser is None: 
            print("parse_timing returned None!")
        else:
            if len(parser) != len(nids): 
                print("Not all timing sections have been parsed!")

        return parser

    #def make_tarball(self):
    #    self.make_tarfile(self, name=None, max_filesize=None, exclude_exts=None, exclude_dirs=None, verbose=0, **kwargs):

